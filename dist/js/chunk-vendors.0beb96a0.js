(self["webpackChunklive2d"]=self["webpackChunklive2d"]||[]).push([[998],{1001:function(t,e,r){"use strict";function i(t,e,r,i,n,o,s,a){var u,h="function"===typeof t?t.options:t;if(e&&(h.render=e,h.staticRenderFns=r,h._compiled=!0),i&&(h.functional=!0),o&&(h._scopeId="data-v-"+o),s?(u=function(t){t=t||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,t||"undefined"===typeof __VUE_SSR_CONTEXT__||(t=__VUE_SSR_CONTEXT__),n&&n.call(this,t),t&&t._registeredComponents&&t._registeredComponents.add(s)},h._ssrRegister=u):n&&(u=a?function(){n.call(this,(h.functional?this.parent:this).$root.$options.shadowRoot)}:n),u)if(h.functional){h._injectStyles=u;var l=h.render;h.render=function(t,e){return u.call(e),l(t,e)}}else{var c=h.beforeCreate;h.beforeCreate=c?[].concat(c,u):[u]}return{exports:t,options:h}}r.d(e,{Z:function(){return i}})},9662:function(t,e,r){var i=r(614),n=r(6330),o=TypeError;t.exports=function(t){if(i(t))return t;throw o(n(t)+" is not a function")}},6077:function(t,e,r){var i=r(614),n=String,o=TypeError;t.exports=function(t){if("object"==typeof t||i(t))return t;throw o("Can't set "+n(t)+" as a prototype")}},5787:function(t,e,r){var i=r(7976),n=TypeError;t.exports=function(t,e){if(i(e,t))return t;throw n("Incorrect invocation")}},9670:function(t,e,r){var i=r(111),n=String,o=TypeError;t.exports=function(t){if(i(t))return t;throw o(n(t)+" is not an object")}},3013:function(t){t.exports="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView},260:function(t,e,r){"use strict";var i,n,o,s=r(3013),a=r(9781),u=r(7854),h=r(614),l=r(111),c=r(2597),d=r(648),f=r(6330),p=r(8880),_=r(8052),m=r(7045),g=r(7976),v=r(9518),y=r(7674),b=r(5112),x=r(9711),T=r(9909),E=T.enforce,S=T.get,w=u.Int8Array,A=w&&w.prototype,R=u.Uint8ClampedArray,O=R&&R.prototype,I=w&&v(w),P=A&&v(A),M=Object.prototype,C=u.TypeError,D=b("toStringTag"),L=x("TYPED_ARRAY_TAG"),F="TypedArrayConstructor",N=s&&!!y&&"Opera"!==d(u.opera),B=!1,U={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},k={BigInt64Array:8,BigUint64Array:8},G=function(t){if(!l(t))return!1;var e=d(t);return"DataView"===e||c(U,e)||c(k,e)},X=function(t){var e=v(t);if(l(e)){var r=S(e);return r&&c(r,F)?r[F]:X(e)}},j=function(t){if(!l(t))return!1;var e=d(t);return c(U,e)||c(k,e)},H=function(t){if(j(t))return t;throw C("Target is not a typed array")},V=function(t){if(h(t)&&(!y||g(I,t)))return t;throw C(f(t)+" is not a typed array constructor")},z=function(t,e,r,i){if(a){if(r)for(var n in U){var o=u[n];if(o&&c(o.prototype,t))try{delete o.prototype[t]}catch(s){try{o.prototype[t]=e}catch(h){}}}P[t]&&!r||_(P,t,r?e:N&&A[t]||e,i)}},Y=function(t,e,r){var i,n;if(a){if(y){if(r)for(i in U)if(n=u[i],n&&c(n,t))try{delete n[t]}catch(o){}if(I[t]&&!r)return;try{return _(I,t,r?e:N&&I[t]||e)}catch(o){}}for(i in U)n=u[i],!n||n[t]&&!r||_(n,t,e)}};for(i in U)n=u[i],o=n&&n.prototype,o?E(o)[F]=n:N=!1;for(i in k)n=u[i],o=n&&n.prototype,o&&(E(o)[F]=n);if((!N||!h(I)||I===Function.prototype)&&(I=function(){throw C("Incorrect invocation")},N))for(i in U)u[i]&&y(u[i],I);if((!N||!P||P===M)&&(P=I.prototype,N))for(i in U)u[i]&&y(u[i].prototype,P);if(N&&v(O)!==P&&y(O,P),a&&!c(P,D))for(i in B=!0,m(P,D,{configurable:!0,get:function(){return l(this)?this[L]:void 0}}),U)u[i]&&p(u[i],L,i);t.exports={NATIVE_ARRAY_BUFFER_VIEWS:N,TYPED_ARRAY_TAG:B&&L,aTypedArray:H,aTypedArrayConstructor:V,exportTypedArrayMethod:z,exportTypedArrayStaticMethod:Y,getTypedArrayConstructor:X,isView:G,isTypedArray:j,TypedArray:I,TypedArrayPrototype:P}},7745:function(t,e,r){var i=r(6244);t.exports=function(t,e){var r=0,n=i(e),o=new t(n);while(n>r)o[r]=e[r++];return o}},1318:function(t,e,r){var i=r(5656),n=r(1400),o=r(6244),s=function(t){return function(e,r,s){var a,u=i(e),h=o(u),l=n(s,h);if(t&&r!=r){while(h>l)if(a=u[l++],a!=a)return!0}else for(;h>l;l++)if((t||l in u)&&u[l]===r)return t||l||0;return!t&&-1}};t.exports={includes:s(!0),indexOf:s(!1)}},3658:function(t,e,r){"use strict";var i=r(9781),n=r(3157),o=TypeError,s=Object.getOwnPropertyDescriptor,a=i&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(t){return t instanceof TypeError}}();t.exports=a?function(t,e){if(n(t)&&!s(t,"length").writable)throw o("Cannot set read only .length");return t.length=e}:function(t,e){return t.length=e}},206:function(t,e,r){var i=r(1702);t.exports=i([].slice)},1843:function(t,e,r){var i=r(6244);t.exports=function(t,e){for(var r=i(t),n=new e(r),o=0;o<r;o++)n[o]=t[r-o-1];return n}},1572:function(t,e,r){var i=r(6244),n=r(9303),o=RangeError;t.exports=function(t,e,r,s){var a=i(t),u=n(r),h=u<0?a+u:u;if(h>=a||h<0)throw o("Incorrect index");for(var l=new e(a),c=0;c<a;c++)l[c]=c===h?s:t[c];return l}},4326:function(t,e,r){var i=r(1702),n=i({}.toString),o=i("".slice);t.exports=function(t){return o(n(t),8,-1)}},648:function(t,e,r){var i=r(1694),n=r(614),o=r(4326),s=r(5112),a=s("toStringTag"),u=Object,h="Arguments"==o(function(){return arguments}()),l=function(t,e){try{return t[e]}catch(r){}};t.exports=i?o:function(t){var e,r,i;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=l(e=u(t),a))?r:h?o(e):"Object"==(i=o(e))&&n(e.callee)?"Arguments":i}},2128:function(t,e,r){var i=r(2597),n=r(3887),o=r(1236),s=r(3070);t.exports=function(t,e,r){for(var a=n(e),u=s.f,h=o.f,l=0;l<a.length;l++){var c=a[l];i(t,c)||r&&i(r,c)||u(t,c,h(e,c))}}},9920:function(t,e,r){var i=r(7293);t.exports=!i((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype}))},8880:function(t,e,r){var i=r(9781),n=r(3070),o=r(9114);t.exports=i?function(t,e,r){return n.f(t,e,o(1,r))}:function(t,e,r){return t[e]=r,t}},9114:function(t){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},7045:function(t,e,r){var i=r(6339),n=r(3070);t.exports=function(t,e,r){return r.get&&i(r.get,e,{getter:!0}),r.set&&i(r.set,e,{setter:!0}),n.f(t,e,r)}},8052:function(t,e,r){var i=r(614),n=r(3070),o=r(6339),s=r(3072);t.exports=function(t,e,r,a){a||(a={});var u=a.enumerable,h=void 0!==a.name?a.name:e;if(i(r)&&o(r,h,a),a.global)u?t[e]=r:s(e,r);else{try{a.unsafe?t[e]&&(u=!0):delete t[e]}catch(l){}u?t[e]=r:n.f(t,e,{value:r,enumerable:!1,configurable:!a.nonConfigurable,writable:!a.nonWritable})}return t}},3072:function(t,e,r){var i=r(7854),n=Object.defineProperty;t.exports=function(t,e){try{n(i,t,{value:e,configurable:!0,writable:!0})}catch(r){i[t]=e}return e}},5117:function(t,e,r){"use strict";var i=r(6330),n=TypeError;t.exports=function(t,e){if(!delete t[e])throw n("Cannot delete property "+i(e)+" of "+i(t))}},9781:function(t,e,r){var i=r(7293);t.exports=!i((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},4154:function(t){var e="object"==typeof document&&document.all,r="undefined"==typeof e&&void 0!==e;t.exports={all:e,IS_HTMLDDA:r}},317:function(t,e,r){var i=r(7854),n=r(111),o=i.document,s=n(o)&&n(o.createElement);t.exports=function(t){return s?o.createElement(t):{}}},7207:function(t){var e=TypeError,r=9007199254740991;t.exports=function(t){if(t>r)throw e("Maximum allowed index exceeded");return t}},3678:function(t){t.exports={IndexSizeError:{s:"INDEX_SIZE_ERR",c:1,m:1},DOMStringSizeError:{s:"DOMSTRING_SIZE_ERR",c:2,m:0},HierarchyRequestError:{s:"HIERARCHY_REQUEST_ERR",c:3,m:1},WrongDocumentError:{s:"WRONG_DOCUMENT_ERR",c:4,m:1},InvalidCharacterError:{s:"INVALID_CHARACTER_ERR",c:5,m:1},NoDataAllowedError:{s:"NO_DATA_ALLOWED_ERR",c:6,m:0},NoModificationAllowedError:{s:"NO_MODIFICATION_ALLOWED_ERR",c:7,m:1},NotFoundError:{s:"NOT_FOUND_ERR",c:8,m:1},NotSupportedError:{s:"NOT_SUPPORTED_ERR",c:9,m:1},InUseAttributeError:{s:"INUSE_ATTRIBUTE_ERR",c:10,m:1},InvalidStateError:{s:"INVALID_STATE_ERR",c:11,m:1},SyntaxError:{s:"SYNTAX_ERR",c:12,m:1},InvalidModificationError:{s:"INVALID_MODIFICATION_ERR",c:13,m:1},NamespaceError:{s:"NAMESPACE_ERR",c:14,m:1},InvalidAccessError:{s:"INVALID_ACCESS_ERR",c:15,m:1},ValidationError:{s:"VALIDATION_ERR",c:16,m:0},TypeMismatchError:{s:"TYPE_MISMATCH_ERR",c:17,m:1},SecurityError:{s:"SECURITY_ERR",c:18,m:1},NetworkError:{s:"NETWORK_ERR",c:19,m:1},AbortError:{s:"ABORT_ERR",c:20,m:1},URLMismatchError:{s:"URL_MISMATCH_ERR",c:21,m:1},QuotaExceededError:{s:"QUOTA_EXCEEDED_ERR",c:22,m:1},TimeoutError:{s:"TIMEOUT_ERR",c:23,m:1},InvalidNodeTypeError:{s:"INVALID_NODE_TYPE_ERR",c:24,m:1},DataCloneError:{s:"DATA_CLONE_ERR",c:25,m:1}}},9363:function(t){t.exports="function"==typeof Bun&&Bun&&"string"==typeof Bun.version},6833:function(t,e,r){var i=r(8113);t.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(i)},5268:function(t,e,r){var i=r(4326);t.exports="undefined"!=typeof process&&"process"==i(process)},8113:function(t){t.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},7392:function(t,e,r){var i,n,o=r(7854),s=r(8113),a=o.process,u=o.Deno,h=a&&a.versions||u&&u.version,l=h&&h.v8;l&&(i=l.split("."),n=i[0]>0&&i[0]<4?1:+(i[0]+i[1])),!n&&s&&(i=s.match(/Edge\/(\d+)/),(!i||i[1]>=74)&&(i=s.match(/Chrome\/(\d+)/),i&&(n=+i[1]))),t.exports=n},748:function(t){t.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},1060:function(t,e,r){var i=r(1702),n=Error,o=i("".replace),s=function(t){return String(n(t).stack)}("zxcasd"),a=/\n\s*at [^:]*:[^\n]*/,u=a.test(s);t.exports=function(t,e){if(u&&"string"==typeof t&&!n.prepareStackTrace)while(e--)t=o(t,a,"");return t}},2109:function(t,e,r){var i=r(7854),n=r(1236).f,o=r(8880),s=r(8052),a=r(3072),u=r(2128),h=r(4705);t.exports=function(t,e){var r,l,c,d,f,p,_=t.target,m=t.global,g=t.stat;if(l=m?i:g?i[_]||a(_,{}):(i[_]||{}).prototype,l)for(c in e){if(f=e[c],t.dontCallGetSet?(p=n(l,c),d=p&&p.value):d=l[c],r=h(m?c:_+(g?".":"#")+c,t.forced),!r&&void 0!==d){if(typeof f==typeof d)continue;u(f,d)}(t.sham||d&&d.sham)&&o(f,"sham",!0),s(l,c,f,t)}}},7293:function(t){t.exports=function(t){try{return!!t()}catch(e){return!0}}},2104:function(t,e,r){var i=r(4374),n=Function.prototype,o=n.apply,s=n.call;t.exports="object"==typeof Reflect&&Reflect.apply||(i?s.bind(o):function(){return s.apply(o,arguments)})},9974:function(t,e,r){var i=r(1470),n=r(9662),o=r(4374),s=i(i.bind);t.exports=function(t,e){return n(t),void 0===e?t:o?s(t,e):function(){return t.apply(e,arguments)}}},4374:function(t,e,r){var i=r(7293);t.exports=!i((function(){var t=function(){}.bind();return"function"!=typeof t||t.hasOwnProperty("prototype")}))},6916:function(t,e,r){var i=r(4374),n=Function.prototype.call;t.exports=i?n.bind(n):function(){return n.apply(n,arguments)}},6530:function(t,e,r){var i=r(9781),n=r(2597),o=Function.prototype,s=i&&Object.getOwnPropertyDescriptor,a=n(o,"name"),u=a&&"something"===function(){}.name,h=a&&(!i||i&&s(o,"name").configurable);t.exports={EXISTS:a,PROPER:u,CONFIGURABLE:h}},5668:function(t,e,r){var i=r(1702),n=r(9662);t.exports=function(t,e,r){try{return i(n(Object.getOwnPropertyDescriptor(t,e)[r]))}catch(o){}}},1470:function(t,e,r){var i=r(4326),n=r(1702);t.exports=function(t){if("Function"===i(t))return n(t)}},1702:function(t,e,r){var i=r(4374),n=Function.prototype,o=n.call,s=i&&n.bind.bind(o,o);t.exports=i?s:function(t){return function(){return o.apply(t,arguments)}}},5005:function(t,e,r){var i=r(7854),n=r(614),o=function(t){return n(t)?t:void 0};t.exports=function(t,e){return arguments.length<2?o(i[t]):i[t]&&i[t][e]}},8173:function(t,e,r){var i=r(9662),n=r(8554);t.exports=function(t,e){var r=t[e];return n(r)?void 0:i(r)}},7854:function(t,e,r){var i=function(t){return t&&t.Math==Math&&t};t.exports=i("object"==typeof globalThis&&globalThis)||i("object"==typeof window&&window)||i("object"==typeof self&&self)||i("object"==typeof r.g&&r.g)||function(){return this}()||Function("return this")()},2597:function(t,e,r){var i=r(1702),n=r(7908),o=i({}.hasOwnProperty);t.exports=Object.hasOwn||function(t,e){return o(n(t),e)}},3501:function(t){t.exports={}},490:function(t,e,r){var i=r(5005);t.exports=i("document","documentElement")},4664:function(t,e,r){var i=r(9781),n=r(7293),o=r(317);t.exports=!i&&!n((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},8361:function(t,e,r){var i=r(1702),n=r(7293),o=r(4326),s=Object,a=i("".split);t.exports=n((function(){return!s("z").propertyIsEnumerable(0)}))?function(t){return"String"==o(t)?a(t,""):s(t)}:s},9587:function(t,e,r){var i=r(614),n=r(111),o=r(7674);t.exports=function(t,e,r){var s,a;return o&&i(s=e.constructor)&&s!==r&&n(a=s.prototype)&&a!==r.prototype&&o(t,a),t}},2788:function(t,e,r){var i=r(1702),n=r(614),o=r(5465),s=i(Function.toString);n(o.inspectSource)||(o.inspectSource=function(t){return s(t)}),t.exports=o.inspectSource},9909:function(t,e,r){var i,n,o,s=r(4811),a=r(7854),u=r(111),h=r(8880),l=r(2597),c=r(5465),d=r(6200),f=r(3501),p="Object already initialized",_=a.TypeError,m=a.WeakMap,g=function(t){return o(t)?n(t):i(t,{})},v=function(t){return function(e){var r;if(!u(e)||(r=n(e)).type!==t)throw _("Incompatible receiver, "+t+" required");return r}};if(s||c.state){var y=c.state||(c.state=new m);y.get=y.get,y.has=y.has,y.set=y.set,i=function(t,e){if(y.has(t))throw _(p);return e.facade=t,y.set(t,e),e},n=function(t){return y.get(t)||{}},o=function(t){return y.has(t)}}else{var b=d("state");f[b]=!0,i=function(t,e){if(l(t,b))throw _(p);return e.facade=t,h(t,b,e),e},n=function(t){return l(t,b)?t[b]:{}},o=function(t){return l(t,b)}}t.exports={set:i,get:n,has:o,enforce:g,getterFor:v}},3157:function(t,e,r){var i=r(4326);t.exports=Array.isArray||function(t){return"Array"==i(t)}},4067:function(t,e,r){var i=r(648);t.exports=function(t){var e=i(t);return"BigInt64Array"==e||"BigUint64Array"==e}},614:function(t,e,r){var i=r(4154),n=i.all;t.exports=i.IS_HTMLDDA?function(t){return"function"==typeof t||t===n}:function(t){return"function"==typeof t}},4705:function(t,e,r){var i=r(7293),n=r(614),o=/#|\.prototype\./,s=function(t,e){var r=u[a(t)];return r==l||r!=h&&(n(e)?i(e):!!e)},a=s.normalize=function(t){return String(t).replace(o,".").toLowerCase()},u=s.data={},h=s.NATIVE="N",l=s.POLYFILL="P";t.exports=s},8554:function(t){t.exports=function(t){return null===t||void 0===t}},111:function(t,e,r){var i=r(614),n=r(4154),o=n.all;t.exports=n.IS_HTMLDDA?function(t){return"object"==typeof t?null!==t:i(t)||t===o}:function(t){return"object"==typeof t?null!==t:i(t)}},1913:function(t){t.exports=!1},2190:function(t,e,r){var i=r(5005),n=r(614),o=r(7976),s=r(3307),a=Object;t.exports=s?function(t){return"symbol"==typeof t}:function(t){var e=i("Symbol");return n(e)&&o(e.prototype,a(t))}},6244:function(t,e,r){var i=r(7466);t.exports=function(t){return i(t.length)}},6339:function(t,e,r){var i=r(1702),n=r(7293),o=r(614),s=r(2597),a=r(9781),u=r(6530).CONFIGURABLE,h=r(2788),l=r(9909),c=l.enforce,d=l.get,f=String,p=Object.defineProperty,_=i("".slice),m=i("".replace),g=i([].join),v=a&&!n((function(){return 8!==p((function(){}),"length",{value:8}).length})),y=String(String).split("String"),b=t.exports=function(t,e,r){"Symbol("===_(f(e),0,7)&&(e="["+m(f(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),r&&r.getter&&(e="get "+e),r&&r.setter&&(e="set "+e),(!s(t,"name")||u&&t.name!==e)&&(a?p(t,"name",{value:e,configurable:!0}):t.name=e),v&&r&&s(r,"arity")&&t.length!==r.arity&&p(t,"length",{value:r.arity});try{r&&s(r,"constructor")&&r.constructor?a&&p(t,"prototype",{writable:!1}):t.prototype&&(t.prototype=void 0)}catch(n){}var i=c(t);return s(i,"source")||(i.source=g(y,"string"==typeof e?e:"")),t};Function.prototype.toString=b((function(){return o(this)&&d(this).source||h(this)}),"toString")},4758:function(t){var e=Math.ceil,r=Math.floor;t.exports=Math.trunc||function(t){var i=+t;return(i>0?r:e)(i)}},6277:function(t,e,r){var i=r(1340);t.exports=function(t,e){return void 0===t?arguments.length<2?"":e:i(t)}},3070:function(t,e,r){var i=r(9781),n=r(4664),o=r(3353),s=r(9670),a=r(4948),u=TypeError,h=Object.defineProperty,l=Object.getOwnPropertyDescriptor,c="enumerable",d="configurable",f="writable";e.f=i?o?function(t,e,r){if(s(t),e=a(e),s(r),"function"===typeof t&&"prototype"===e&&"value"in r&&f in r&&!r[f]){var i=l(t,e);i&&i[f]&&(t[e]=r.value,r={configurable:d in r?r[d]:i[d],enumerable:c in r?r[c]:i[c],writable:!1})}return h(t,e,r)}:h:function(t,e,r){if(s(t),e=a(e),s(r),n)try{return h(t,e,r)}catch(i){}if("get"in r||"set"in r)throw u("Accessors not supported");return"value"in r&&(t[e]=r.value),t}},1236:function(t,e,r){var i=r(9781),n=r(6916),o=r(5296),s=r(9114),a=r(5656),u=r(4948),h=r(2597),l=r(4664),c=Object.getOwnPropertyDescriptor;e.f=i?c:function(t,e){if(t=a(t),e=u(e),l)try{return c(t,e)}catch(r){}if(h(t,e))return s(!n(o.f,t,e),t[e])}},8006:function(t,e,r){var i=r(6324),n=r(748),o=n.concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return i(t,o)}},5181:function(t,e){e.f=Object.getOwnPropertySymbols},9518:function(t,e,r){var i=r(2597),n=r(614),o=r(7908),s=r(6200),a=r(9920),u=s("IE_PROTO"),h=Object,l=h.prototype;t.exports=a?h.getPrototypeOf:function(t){var e=o(t);if(i(e,u))return e[u];var r=e.constructor;return n(r)&&e instanceof r?r.prototype:e instanceof h?l:null}},7976:function(t,e,r){var i=r(1702);t.exports=i({}.isPrototypeOf)},6324:function(t,e,r){var i=r(1702),n=r(2597),o=r(5656),s=r(1318).indexOf,a=r(3501),u=i([].push);t.exports=function(t,e){var r,i=o(t),h=0,l=[];for(r in i)!n(a,r)&&n(i,r)&&u(l,r);while(e.length>h)n(i,r=e[h++])&&(~s(l,r)||u(l,r));return l}},5296:function(t,e){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,n=i&&!r.call({1:2},1);e.f=n?function(t){var e=i(this,t);return!!e&&e.enumerable}:r},7674:function(t,e,r){var i=r(5668),n=r(9670),o=r(6077);t.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,r={};try{t=i(Object.prototype,"__proto__","set"),t(r,[]),e=r instanceof Array}catch(s){}return function(r,i){return n(r),o(i),e?t(r,i):r.__proto__=i,r}}():void 0)},2140:function(t,e,r){var i=r(6916),n=r(614),o=r(111),s=TypeError;t.exports=function(t,e){var r,a;if("string"===e&&n(r=t.toString)&&!o(a=i(r,t)))return a;if(n(r=t.valueOf)&&!o(a=i(r,t)))return a;if("string"!==e&&n(r=t.toString)&&!o(a=i(r,t)))return a;throw s("Can't convert object to primitive value")}},3887:function(t,e,r){var i=r(5005),n=r(1702),o=r(8006),s=r(5181),a=r(9670),u=n([].concat);t.exports=i("Reflect","ownKeys")||function(t){var e=o.f(a(t)),r=s.f;return r?u(e,r(t)):e}},7066:function(t,e,r){"use strict";var i=r(9670);t.exports=function(){var t=i(this),e="";return t.hasIndices&&(e+="d"),t.global&&(e+="g"),t.ignoreCase&&(e+="i"),t.multiline&&(e+="m"),t.dotAll&&(e+="s"),t.unicode&&(e+="u"),t.unicodeSets&&(e+="v"),t.sticky&&(e+="y"),e}},4488:function(t,e,r){var i=r(8554),n=TypeError;t.exports=function(t){if(i(t))throw n("Can't call method on "+t);return t}},7152:function(t,e,r){"use strict";var i=r(7854),n=r(2104),o=r(614),s=r(9363),a=r(8113),u=r(206),h=r(8053),l=i.Function,c=/MSIE .\./.test(a)||s&&function(){var t=i.Bun.version.split(".");return t.length<3||0==t[0]&&(t[1]<3||3==t[1]&&0==t[2])}();t.exports=function(t,e){var r=e?2:1;return c?function(i,s){var a=h(arguments.length,1)>r,c=o(i)?i:l(i),d=a?u(arguments,r):[],f=a?function(){n(c,this,d)}:c;return e?t(f,s):t(f)}:t}},6200:function(t,e,r){var i=r(2309),n=r(9711),o=i("keys");t.exports=function(t){return o[t]||(o[t]=n(t))}},5465:function(t,e,r){var i=r(7854),n=r(3072),o="__core-js_shared__",s=i[o]||n(o,{});t.exports=s},2309:function(t,e,r){var i=r(1913),n=r(5465);(t.exports=function(t,e){return n[t]||(n[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.30.1",mode:i?"pure":"global",copyright:"Â© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.30.1/LICENSE",source:"https://github.com/zloirock/core-js"})},6293:function(t,e,r){var i=r(7392),n=r(7293);t.exports=!!Object.getOwnPropertySymbols&&!n((function(){var t=Symbol();return!String(t)||!(Object(t)instanceof Symbol)||!Symbol.sham&&i&&i<41}))},261:function(t,e,r){var i,n,o,s,a=r(7854),u=r(2104),h=r(9974),l=r(614),c=r(2597),d=r(7293),f=r(490),p=r(206),_=r(317),m=r(8053),g=r(6833),v=r(5268),y=a.setImmediate,b=a.clearImmediate,x=a.process,T=a.Dispatch,E=a.Function,S=a.MessageChannel,w=a.String,A=0,R={},O="onreadystatechange";d((function(){i=a.location}));var I=function(t){if(c(R,t)){var e=R[t];delete R[t],e()}},P=function(t){return function(){I(t)}},M=function(t){I(t.data)},C=function(t){a.postMessage(w(t),i.protocol+"//"+i.host)};y&&b||(y=function(t){m(arguments.length,1);var e=l(t)?t:E(t),r=p(arguments,1);return R[++A]=function(){u(e,void 0,r)},n(A),A},b=function(t){delete R[t]},v?n=function(t){x.nextTick(P(t))}:T&&T.now?n=function(t){T.now(P(t))}:S&&!g?(o=new S,s=o.port2,o.port1.onmessage=M,n=h(s.postMessage,s)):a.addEventListener&&l(a.postMessage)&&!a.importScripts&&i&&"file:"!==i.protocol&&!d(C)?(n=C,a.addEventListener("message",M,!1)):n=O in _("script")?function(t){f.appendChild(_("script"))[O]=function(){f.removeChild(this),I(t)}}:function(t){setTimeout(P(t),0)}),t.exports={set:y,clear:b}},1400:function(t,e,r){var i=r(9303),n=Math.max,o=Math.min;t.exports=function(t,e){var r=i(t);return r<0?n(r+e,0):o(r,e)}},4599:function(t,e,r){var i=r(7593),n=TypeError;t.exports=function(t){var e=i(t,"number");if("number"==typeof e)throw n("Can't convert number to bigint");return BigInt(e)}},5656:function(t,e,r){var i=r(8361),n=r(4488);t.exports=function(t){return i(n(t))}},9303:function(t,e,r){var i=r(4758);t.exports=function(t){var e=+t;return e!==e||0===e?0:i(e)}},7466:function(t,e,r){var i=r(9303),n=Math.min;t.exports=function(t){return t>0?n(i(t),9007199254740991):0}},7908:function(t,e,r){var i=r(4488),n=Object;t.exports=function(t){return n(i(t))}},7593:function(t,e,r){var i=r(6916),n=r(111),o=r(2190),s=r(8173),a=r(2140),u=r(5112),h=TypeError,l=u("toPrimitive");t.exports=function(t,e){if(!n(t)||o(t))return t;var r,u=s(t,l);if(u){if(void 0===e&&(e="default"),r=i(u,t,e),!n(r)||o(r))return r;throw h("Can't convert object to primitive value")}return void 0===e&&(e="number"),a(t,e)}},4948:function(t,e,r){var i=r(7593),n=r(2190);t.exports=function(t){var e=i(t,"string");return n(e)?e:e+""}},1694:function(t,e,r){var i=r(5112),n=i("toStringTag"),o={};o[n]="z",t.exports="[object z]"===String(o)},1340:function(t,e,r){var i=r(648),n=String;t.exports=function(t){if("Symbol"===i(t))throw TypeError("Cannot convert a Symbol value to a string");return n(t)}},6330:function(t){var e=String;t.exports=function(t){try{return e(t)}catch(r){return"Object"}}},9711:function(t,e,r){var i=r(1702),n=0,o=Math.random(),s=i(1..toString);t.exports=function(t){return"Symbol("+(void 0===t?"":t)+")_"+s(++n+o,36)}},3307:function(t,e,r){var i=r(6293);t.exports=i&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},3353:function(t,e,r){var i=r(9781),n=r(7293);t.exports=i&&n((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},8053:function(t){var e=TypeError;t.exports=function(t,r){if(t<r)throw e("Not enough arguments");return t}},4811:function(t,e,r){var i=r(7854),n=r(614),o=i.WeakMap;t.exports=n(o)&&/native code/.test(String(o))},5112:function(t,e,r){var i=r(7854),n=r(2309),o=r(2597),s=r(9711),a=r(6293),u=r(3307),h=i.Symbol,l=n("wks"),c=u?h["for"]||h:h&&h.withoutSetter||s;t.exports=function(t){return o(l,t)||(l[t]=a&&o(h,t)?h[t]:c("Symbol."+t)),l[t]}},7658:function(t,e,r){"use strict";var i=r(2109),n=r(7908),o=r(6244),s=r(3658),a=r(7207),u=r(7293),h=u((function(){return 4294967297!==[].push.call({length:4294967296},1)})),l=function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(t){return t instanceof TypeError}},c=h||!l();i({target:"Array",proto:!0,arity:1,forced:c},{push:function(t){var e=n(this),r=o(e),i=arguments.length;a(r+i);for(var u=0;u<i;u++)e[r]=arguments[u],r++;return s(e,r),r}})},541:function(t,e,r){"use strict";var i=r(2109),n=r(7908),o=r(6244),s=r(3658),a=r(5117),u=r(7207),h=1!==[].unshift(0),l=function(){try{Object.defineProperty([],"length",{writable:!1}).unshift()}catch(t){return t instanceof TypeError}},c=h||!l();i({target:"Array",proto:!0,arity:1,forced:c},{unshift:function(t){var e=n(this),r=o(e),i=arguments.length;if(i){u(r+i);var h=r;while(h--){var l=h+i;h in e?e[l]=e[h]:a(e,l)}for(var c=0;c<i;c++)e[c]=arguments[c]}return s(e,r+i)}})},2087:function(t,e,r){var i=r(7854),n=r(9781),o=r(7045),s=r(7066),a=r(7293),u=i.RegExp,h=u.prototype,l=n&&a((function(){var t=!0;try{u(".","d")}catch(l){t=!1}var e={},r="",i=t?"dgimsy":"gimsy",n=function(t,i){Object.defineProperty(e,t,{get:function(){return r+=i,!0}})},o={dotAll:"s",global:"g",ignoreCase:"i",multiline:"m",sticky:"y"};for(var s in t&&(o.hasIndices="d"),o)n(s,o[s]);var a=Object.getOwnPropertyDescriptor(h,"flags").get.call(e);return a!==i||r!==i}));l&&o(h,"flags",{configurable:!0,get:s})},1439:function(t,e,r){"use strict";var i=r(1843),n=r(260),o=n.aTypedArray,s=n.exportTypedArrayMethod,a=n.getTypedArrayConstructor;s("toReversed",(function(){return i(o(this),a(this))}))},7585:function(t,e,r){"use strict";var i=r(260),n=r(1702),o=r(9662),s=r(7745),a=i.aTypedArray,u=i.getTypedArrayConstructor,h=i.exportTypedArrayMethod,l=n(i.TypedArrayPrototype.sort);h("toSorted",(function(t){void 0!==t&&o(t);var e=a(this),r=s(u(e),e);return l(r,t)}))},5315:function(t,e,r){"use strict";var i=r(1572),n=r(260),o=r(4067),s=r(9303),a=r(4599),u=n.aTypedArray,h=n.getTypedArrayConstructor,l=n.exportTypedArrayMethod,c=!!function(){try{new Int8Array(1)["with"](2,{valueOf:function(){throw 8}})}catch(t){return 8===t}}();l("with",{with:function(t,e){var r=u(this),n=s(t),l=o(r)?a(e):+e;return i(r,h(r),n,l)}}["with"],!c)},3767:function(t,e,r){r(1439)},8585:function(t,e,r){r(7585)},8696:function(t,e,r){r(5315)},1091:function(t,e,r){var i=r(2109),n=r(7854),o=r(261).clear;i({global:!0,bind:!0,enumerable:!0,forced:n.clearImmediate!==o},{clearImmediate:o})},2801:function(t,e,r){"use strict";var i=r(2109),n=r(7854),o=r(5005),s=r(9114),a=r(3070).f,u=r(2597),h=r(5787),l=r(9587),c=r(6277),d=r(3678),f=r(1060),p=r(9781),_=r(1913),m="DOMException",g=o("Error"),v=o(m),y=function(){h(this,b);var t=arguments.length,e=c(t<1?void 0:arguments[0]),r=c(t<2?void 0:arguments[1],"Error"),i=new v(e,r),n=g(e);return n.name=m,a(i,"stack",s(1,f(n.stack,1))),l(i,this,y),i},b=y.prototype=v.prototype,x="stack"in g(m),T="stack"in new v(1,2),E=v&&p&&Object.getOwnPropertyDescriptor(n,m),S=!!E&&!(E.writable&&E.configurable),w=x&&!S&&!T;i({global:!0,constructor:!0,forced:_||w},{DOMException:w?y:v});var A=o(m),R=A.prototype;if(R.constructor!==A)for(var O in _||a(R,"constructor",s(1,A)),d)if(u(d,O)){var I=d[O],P=I.s;u(A,P)||a(A,P,s(6,I.c))}},4633:function(t,e,r){r(1091),r(2986)},2986:function(t,e,r){var i=r(2109),n=r(7854),o=r(261).set,s=r(7152),a=n.setImmediate?s(o,!1):o;i({global:!0,bind:!0,enumerable:!0,forced:n.setImmediate!==a},{setImmediate:a})},1907:function(t,e,r){"use strict";r(7658);var i=Object.prototype.hasOwnProperty,n="~";function o(){}function s(t,e,r){this.fn=t,this.context=e,this.once=r||!1}function a(t,e,r,i,o){if("function"!==typeof r)throw new TypeError("The listener must be a function");var a=new s(r,i||t,o),u=n?n+e:e;return t._events[u]?t._events[u].fn?t._events[u]=[t._events[u],a]:t._events[u].push(a):(t._events[u]=a,t._eventsCount++),t}function u(t,e){0===--t._eventsCount?t._events=new o:delete t._events[e]}function h(){this._events=new o,this._eventsCount=0}Object.create&&(o.prototype=Object.create(null),(new o).__proto__||(n=!1)),h.prototype.eventNames=function(){var t,e,r=[];if(0===this._eventsCount)return r;for(e in t=this._events)i.call(t,e)&&r.push(n?e.slice(1):e);return Object.getOwnPropertySymbols?r.concat(Object.getOwnPropertySymbols(t)):r},h.prototype.listeners=function(t){var e=n?n+t:t,r=this._events[e];if(!r)return[];if(r.fn)return[r.fn];for(var i=0,o=r.length,s=new Array(o);i<o;i++)s[i]=r[i].fn;return s},h.prototype.listenerCount=function(t){var e=n?n+t:t,r=this._events[e];return r?r.fn?1:r.length:0},h.prototype.emit=function(t,e,r,i,o,s){var a=n?n+t:t;if(!this._events[a])return!1;var u,h,l=this._events[a],c=arguments.length;if(l.fn){switch(l.once&&this.removeListener(t,l.fn,void 0,!0),c){case 1:return l.fn.call(l.context),!0;case 2:return l.fn.call(l.context,e),!0;case 3:return l.fn.call(l.context,e,r),!0;case 4:return l.fn.call(l.context,e,r,i),!0;case 5:return l.fn.call(l.context,e,r,i,o),!0;case 6:return l.fn.call(l.context,e,r,i,o,s),!0}for(h=1,u=new Array(c-1);h<c;h++)u[h-1]=arguments[h];l.fn.apply(l.context,u)}else{var d,f=l.length;for(h=0;h<f;h++)switch(l[h].once&&this.removeListener(t,l[h].fn,void 0,!0),c){case 1:l[h].fn.call(l[h].context);break;case 2:l[h].fn.call(l[h].context,e);break;case 3:l[h].fn.call(l[h].context,e,r);break;case 4:l[h].fn.call(l[h].context,e,r,i);break;default:if(!u)for(d=1,u=new Array(c-1);d<c;d++)u[d-1]=arguments[d];l[h].fn.apply(l[h].context,u)}}return!0},h.prototype.on=function(t,e,r){return a(this,t,e,r,!1)},h.prototype.once=function(t,e,r){return a(this,t,e,r,!0)},h.prototype.removeListener=function(t,e,r,i){var o=n?n+t:t;if(!this._events[o])return this;if(!e)return u(this,o),this;var s=this._events[o];if(s.fn)s.fn!==e||i&&!s.once||r&&s.context!==r||u(this,o);else{for(var a=0,h=[],l=s.length;a<l;a++)(s[a].fn!==e||i&&!s[a].once||r&&s[a].context!==r)&&h.push(s[a]);h.length?this._events[o]=1===h.length?h[0]:h:u(this,o)}return this},h.prototype.removeAllListeners=function(t){var e;return t?(e=n?n+t:t,this._events[e]&&u(this,e)):(this._events=new o,this._eventsCount=0),this},h.prototype.off=h.prototype.removeListener,h.prototype.addListener=h.prototype.on,h.prefixed=n,h.EventEmitter=h,t.exports=h},8745:function(t,e,r){"use strict";function i(t,e,r){r=r||2;var i,o,a,u,h,l,d,f=e&&e.length,p=f?e[0]*r:t.length,_=n(t,0,p,r,!0),m=[];if(!_||_.next===_.prev)return m;if(f&&(_=c(t,e,_,r)),t.length>80*r){i=a=t[0],o=u=t[1];for(var g=r;g<p;g+=r)h=t[g],l=t[g+1],h<i&&(i=h),l<o&&(o=l),h>a&&(a=h),l>u&&(u=l);d=Math.max(a-i,u-o),d=0!==d?32767/d:0}return s(_,m,r,i,o,d,0),m}function n(t,e,r,i,n){var o,s;if(n===L(t,e,r,i)>0)for(o=e;o<r;o+=i)s=M(o,t[o],t[o+1],s);else for(o=r-i;o>=e;o-=i)s=M(o,t[o],t[o+1],s);return s&&E(s,s.next)&&(C(s),s=s.next),s}function o(t,e){if(!t)return t;e||(e=t);var r,i=t;do{if(r=!1,i.steiner||!E(i,i.next)&&0!==T(i.prev,i,i.next))i=i.next;else{if(C(i),i=e=i.prev,i===i.next)break;r=!0}}while(r||i!==e);return e}function s(t,e,r,i,n,c,d){if(t){!d&&c&&m(t,i,n,c);var f,p,_=t;while(t.prev!==t.next)if(f=t.prev,p=t.next,c?u(t,i,n,c):a(t))e.push(f.i/r|0),e.push(t.i/r|0),e.push(p.i/r|0),C(t),t=p.next,_=p.next;else if(t=p,t===_){d?1===d?(t=h(o(t),e,r),s(t,e,r,i,n,c,2)):2===d&&l(t,e,r,i,n,c):s(o(t),e,r,i,n,c,1);break}}}function a(t){var e=t.prev,r=t,i=t.next;if(T(e,r,i)>=0)return!1;var n=e.x,o=r.x,s=i.x,a=e.y,u=r.y,h=i.y,l=n<o?n<s?n:s:o<s?o:s,c=a<u?a<h?a:h:u<h?u:h,d=n>o?n>s?n:s:o>s?o:s,f=a>u?a>h?a:h:u>h?u:h,p=i.next;while(p!==e){if(p.x>=l&&p.x<=d&&p.y>=c&&p.y<=f&&b(n,a,o,u,s,h,p.x,p.y)&&T(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function u(t,e,r,i){var n=t.prev,o=t,s=t.next;if(T(n,o,s)>=0)return!1;var a=n.x,u=o.x,h=s.x,l=n.y,c=o.y,d=s.y,f=a<u?a<h?a:h:u<h?u:h,p=l<c?l<d?l:d:c<d?c:d,_=a>u?a>h?a:h:u>h?u:h,m=l>c?l>d?l:d:c>d?c:d,g=v(f,p,e,r,i),y=v(_,m,e,r,i),x=t.prevZ,E=t.nextZ;while(x&&x.z>=g&&E&&E.z<=y){if(x.x>=f&&x.x<=_&&x.y>=p&&x.y<=m&&x!==n&&x!==s&&b(a,l,u,c,h,d,x.x,x.y)&&T(x.prev,x,x.next)>=0)return!1;if(x=x.prevZ,E.x>=f&&E.x<=_&&E.y>=p&&E.y<=m&&E!==n&&E!==s&&b(a,l,u,c,h,d,E.x,E.y)&&T(E.prev,E,E.next)>=0)return!1;E=E.nextZ}while(x&&x.z>=g){if(x.x>=f&&x.x<=_&&x.y>=p&&x.y<=m&&x!==n&&x!==s&&b(a,l,u,c,h,d,x.x,x.y)&&T(x.prev,x,x.next)>=0)return!1;x=x.prevZ}while(E&&E.z<=y){if(E.x>=f&&E.x<=_&&E.y>=p&&E.y<=m&&E!==n&&E!==s&&b(a,l,u,c,h,d,E.x,E.y)&&T(E.prev,E,E.next)>=0)return!1;E=E.nextZ}return!0}function h(t,e,r){var i=t;do{var n=i.prev,s=i.next.next;!E(n,s)&&S(n,i,i.next,s)&&O(n,s)&&O(s,n)&&(e.push(n.i/r|0),e.push(i.i/r|0),e.push(s.i/r|0),C(i),C(i.next),i=t=s),i=i.next}while(i!==t);return o(i)}function l(t,e,r,i,n,a){var u=t;do{var h=u.next.next;while(h!==u.prev){if(u.i!==h.i&&x(u,h)){var l=P(u,h);return u=o(u,u.next),l=o(l,l.next),s(u,e,r,i,n,a,0),void s(l,e,r,i,n,a,0)}h=h.next}u=u.next}while(u!==t)}function c(t,e,r,i){var o,s,a,u,h,l=[];for(o=0,s=e.length;o<s;o++)a=e[o]*i,u=o<s-1?e[o+1]*i:t.length,h=n(t,a,u,i,!1),h===h.next&&(h.steiner=!0),l.push(y(h));for(l.sort(d),o=0;o<l.length;o++)r=f(l[o],r);return r}function d(t,e){return t.x-e.x}function f(t,e){var r=p(t,e);if(!r)return e;var i=P(r,t);return o(i,i.next),o(r,r.next)}function p(t,e){var r,i=e,n=t.x,o=t.y,s=-1/0;do{if(o<=i.y&&o>=i.next.y&&i.next.y!==i.y){var a=i.x+(o-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(a<=n&&a>s&&(s=a,r=i.x<i.next.x?i:i.next,a===n))return r}i=i.next}while(i!==e);if(!r)return null;var u,h=r,l=r.x,c=r.y,d=1/0;i=r;do{n>=i.x&&i.x>=l&&n!==i.x&&b(o<c?n:s,o,l,c,o<c?s:n,o,i.x,i.y)&&(u=Math.abs(o-i.y)/(n-i.x),O(i,t)&&(u<d||u===d&&(i.x>r.x||i.x===r.x&&_(r,i)))&&(r=i,d=u)),i=i.next}while(i!==h);return r}function _(t,e){return T(t.prev,t,e.prev)<0&&T(e.next,t,t.next)<0}function m(t,e,r,i){var n=t;do{0===n.z&&(n.z=v(n.x,n.y,e,r,i)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next}while(n!==t);n.prevZ.nextZ=null,n.prevZ=null,g(n)}function g(t){var e,r,i,n,o,s,a,u,h=1;do{r=t,t=null,o=null,s=0;while(r){for(s++,i=r,a=0,e=0;e<h;e++)if(a++,i=i.nextZ,!i)break;u=h;while(a>0||u>0&&i)0!==a&&(0===u||!i||r.z<=i.z)?(n=r,r=r.nextZ,a--):(n=i,i=i.nextZ,u--),o?o.nextZ=n:t=n,n.prevZ=o,o=n;r=i}o.nextZ=null,h*=2}while(s>1);return t}function v(t,e,r,i,n){return t=(t-r)*n|0,e=(e-i)*n|0,t=16711935&(t|t<<8),t=252645135&(t|t<<4),t=858993459&(t|t<<2),t=1431655765&(t|t<<1),e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),t|e<<1}function y(t){var e=t,r=t;do{(e.x<r.x||e.x===r.x&&e.y<r.y)&&(r=e),e=e.next}while(e!==t);return r}function b(t,e,r,i,n,o,s,a){return(n-s)*(e-a)>=(t-s)*(o-a)&&(t-s)*(i-a)>=(r-s)*(e-a)&&(r-s)*(o-a)>=(n-s)*(i-a)}function x(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!R(t,e)&&(O(t,e)&&O(e,t)&&I(t,e)&&(T(t.prev,t,e.prev)||T(t,e.prev,e))||E(t,e)&&T(t.prev,t,t.next)>0&&T(e.prev,e,e.next)>0)}function T(t,e,r){return(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y)}function E(t,e){return t.x===e.x&&t.y===e.y}function S(t,e,r,i){var n=A(T(t,e,r)),o=A(T(t,e,i)),s=A(T(r,i,t)),a=A(T(r,i,e));return n!==o&&s!==a||(!(0!==n||!w(t,r,e))||(!(0!==o||!w(t,i,e))||(!(0!==s||!w(r,t,i))||!(0!==a||!w(r,e,i)))))}function w(t,e,r){return e.x<=Math.max(t.x,r.x)&&e.x>=Math.min(t.x,r.x)&&e.y<=Math.max(t.y,r.y)&&e.y>=Math.min(t.y,r.y)}function A(t){return t>0?1:t<0?-1:0}function R(t,e){var r=t;do{if(r.i!==t.i&&r.next.i!==t.i&&r.i!==e.i&&r.next.i!==e.i&&S(r,r.next,t,e))return!0;r=r.next}while(r!==t);return!1}function O(t,e){return T(t.prev,t,t.next)<0?T(t,e,t.next)>=0&&T(t,t.prev,e)>=0:T(t,e,t.prev)<0||T(t,t.next,e)<0}function I(t,e){var r=t,i=!1,n=(t.x+e.x)/2,o=(t.y+e.y)/2;do{r.y>o!==r.next.y>o&&r.next.y!==r.y&&n<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(i=!i),r=r.next}while(r!==t);return i}function P(t,e){var r=new D(t.i,t.x,t.y),i=new D(e.i,e.x,e.y),n=t.next,o=e.prev;return t.next=e,e.prev=t,r.next=n,n.prev=r,i.next=r,r.prev=i,o.next=i,i.prev=o,i}function M(t,e,r,i){var n=new D(t,e,r);return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function C(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function D(t,e,r){this.i=t,this.x=e,this.y=r,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function L(t,e,r,i){for(var n=0,o=e,s=r-i;o<r;o+=i)n+=(t[s]-t[o])*(t[o+1]+t[s+1]),s=o;return n}r(7658),t.exports=i,t.exports["default"]=i,i.deviation=function(t,e,r,i){var n=e&&e.length,o=n?e[0]*r:t.length,s=Math.abs(L(t,0,o,r));if(n)for(var a=0,u=e.length;a<u;a++){var h=e[a]*r,l=a<u-1?e[a+1]*r:t.length;s-=Math.abs(L(t,h,l,r))}var c=0;for(a=0;a<i.length;a+=3){var d=i[a]*r,f=i[a+1]*r,p=i[a+2]*r;c+=Math.abs((t[d]-t[p])*(t[f+1]-t[d+1])-(t[d]-t[f])*(t[p+1]-t[d+1]))}return 0===s&&0===c?0:Math.abs((c-s)/s)},i.flatten=function(t){for(var e=t[0][0].length,r={vertices:[],holes:[],dimensions:e},i=0,n=0;n<t.length;n++){for(var o=0;o<t[n].length;o++)for(var s=0;s<e;s++)r.vertices.push(t[n][o][s]);n>0&&(i+=t[n-1].length,r.holes.push(i))}return r}},7167:function(t){"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/var e = Object.getOwnPropertySymbols, r = Object.prototype.hasOwnProperty, i = Object.prototype.propertyIsEnumerable; function n(t) { if (null === t || void 0 === t) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } function o() { try { if (!Object.assign) return !1; var t = new String("abc"); if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1; for (var e = {}, r = 0; r < 10; r++)e["_" + String.fromCharCode(r)] = r; var i = Object.getOwnPropertyNames(e).map((function (t) { return e[t] })); if ("0123456789" !== i.join("")) return !1; var n = {}; return "abcdefghijklmnopqrst".split("").forEach((function (t) { n[t] = t })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n)).join("") } catch (o) { return !1 } } t.exports = o() ? Object.assign : function (t, o) { for (var s, a, u = n(t), h = 1; h < arguments.length; h++) { for (var l in s = Object(arguments[h]), s) r.call(s, l) && (u[l] = s[l]); if (e) { a = e(s); for (var c = 0; c < a.length; c++)i.call(s, a[c]) && (u[a[c]] = s[a[c]]) } } return u }
    }, 7063: function (t, e, r) { "use strict"; r.d(e, { _Y: function () { return lr } }); r(7658), r(3767), r(8585), r(8696), r(541); var i = r(5506), n = r(565), o = r(1493), s = r(9782), a = Math.pow, u = (t, e, r) => new Promise(((i, n) => { var o = t => { try { a(r.next(t)) } catch (e) { n(e) } }, s = t => { try { a(r.throw(t)) } catch (e) { n(e) } }, a = t => t.done ? i(t.value) : Promise.resolve(t.value).then(o, s); a((r = r.apply(t, e)).next()) })); class h { constructor() { this._breathParameters = [], this._currentTime = 0 } static create() { return new h } setParameters(t) { this._breathParameters = t } getParameters() { return this._breathParameters } updateParameters(t, e) { this._currentTime += e; const r = 2 * this._currentTime * 3.14159; for (let i = 0; i < this._breathParameters.length; ++i) { const e = this._breathParameters[i]; t.addParameterValueById(e.parameterId, e.offset + e.peak * Math.sin(r / e.cycle), e.weight) } } } class l { constructor(t, e, r, i, n) { this.parameterId = void 0 == t ? void 0 : t, this.offset = void 0 == e ? 0 : e, this.peak = void 0 == r ? 0 : r, this.cycle = void 0 == i ? 0 : i, this.weight = void 0 == n ? 0 : n } } const c = class { static create(t) { return new c(t) } setBlinkingInterval(t) { this._blinkingIntervalSeconds = t } setBlinkingSetting(t, e, r) { this._closingSeconds = t, this._closedSeconds = e, this._openingSeconds = r } setParameterIds(t) { this._parameterIds = t } getParameterIds() { return this._parameterIds } updateParameters(t, e) { let r; this._userTimeSeconds += e; let i = 0; switch (this._blinkingState) { case f.EyeState_Closing: i = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closingSeconds, i >= 1 && (i = 1, this._blinkingState = f.EyeState_Closed, this._stateStartTimeSeconds = this._userTimeSeconds), r = 1 - i; break; case f.EyeState_Closed: i = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closedSeconds, i >= 1 && (this._blinkingState = f.EyeState_Opening, this._stateStartTimeSeconds = this._userTimeSeconds), r = 0; break; case f.EyeState_Opening: i = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._openingSeconds, i >= 1 && (i = 1, this._blinkingState = f.EyeState_Interval, this._nextBlinkingTime = this.determinNextBlinkingTiming()), r = i; break; case f.EyeState_Interval: this._nextBlinkingTime < this._userTimeSeconds && (this._blinkingState = f.EyeState_Closing, this._stateStartTimeSeconds = this._userTimeSeconds), r = 1; break; case f.EyeState_First: default: this._blinkingState = f.EyeState_Interval, this._nextBlinkingTime = this.determinNextBlinkingTiming(), r = 1; break }c.CloseIfZero || (r = -r); for (let n = 0; n < this._parameterIds.length; ++n)t.setParameterValueById(this._parameterIds[n], r) } constructor(t) { var e, r; this._blinkingState = f.EyeState_First, this._nextBlinkingTime = 0, this._stateStartTimeSeconds = 0, this._blinkingIntervalSeconds = 4, this._closingSeconds = .1, this._closedSeconds = .05, this._openingSeconds = .15, this._userTimeSeconds = 0, this._parameterIds = [], null != t && (this._parameterIds = null != (r = null == (e = t.getEyeBlinkParameters()) ? void 0 : e.slice()) ? r : this._parameterIds) } determinNextBlinkingTiming() { const t = Math.random(); return this._userTimeSeconds + t * (2 * this._blinkingIntervalSeconds - 1) } }; let d = c; d.CloseIfZero = !0; var f = (t => (t[t["EyeState_First"] = 0] = "EyeState_First", t[t["EyeState_Interval"] = 1] = "EyeState_Interval", t[t["EyeState_Closing"] = 2] = "EyeState_Closing", t[t["EyeState_Closed"] = 3] = "EyeState_Closed", t[t["EyeState_Opening"] = 4] = "EyeState_Opening", t))(f || {}); const p = .001, _ = .5; class m { static create(t) { const e = new m; "number" === typeof t.FadeInTime && (e._fadeTimeSeconds = t.FadeInTime, e._fadeTimeSeconds <= 0 && (e._fadeTimeSeconds = _)); const r = t.Groups, i = r.length; for (let n = 0; n < i; ++n) { const t = r[n], i = t.length; let o = 0; for (let r = 0; r < i; ++r) { const i = t[r], n = new g; n.partId = i.Id; const s = i.Link; if (s) { const t = s.length; for (let e = 0; e < t; ++e) { const t = new g; t.partId = s[e], n.link.push(t) } } e._partGroups.push(n), ++o } e._partGroupCounts.push(o) } return e } updateParameters(t, e) { t != this._lastModel && this.reset(t), this._lastModel = t, e < 0 && (e = 0); let r = 0; for (let i = 0; i < this._partGroupCounts.length; i++) { const n = this._partGroupCounts[i]; this.doFade(t, e, r, n), r += n } this.copyPartOpacities(t) } reset(t) { let e = 0; for (let r = 0; r < this._partGroupCounts.length; ++r) { const i = this._partGroupCounts[r]; for (let r = e; r < e + i; ++r) { this._partGroups[r].initialize(t); const i = this._partGroups[r].partIndex, n = this._partGroups[r].parameterIndex; if (!(i < 0)) { t.setPartOpacityByIndex(i, r == e ? 1 : 0), t.setParameterValueByIndex(n, r == e ? 1 : 0); for (let e = 0; e < this._partGroups[r].link.length; ++e)this._partGroups[r].link[e].initialize(t) } } e += i } } copyPartOpacities(t) { for (let e = 0; e < this._partGroups.length; ++e) { const r = this._partGroups[e]; if (0 == r.link.length) continue; const i = this._partGroups[e].partIndex, n = t.getPartOpacityByIndex(i); for (let e = 0; e < r.link.length; ++e) { const i = r.link[e], o = i.partIndex; o < 0 || t.setPartOpacityByIndex(o, n) } } } doFade(t, e, r, i) { let n = -1, o = 1; const s = .5, a = .15; for (let u = r; u < r + i; ++u) { const r = this._partGroups[u].partIndex, i = this._partGroups[u].parameterIndex; if (t.getParameterValueByIndex(i) > p) { if (n >= 0) break; n = u, o = t.getPartOpacityByIndex(r), o += e / this._fadeTimeSeconds, o > 1 && (o = 1) } } n < 0 && (n = 0, o = 1); for (let u = r; u < r + i; ++u) { const e = this._partGroups[u].partIndex; if (n == u) t.setPartOpacityByIndex(e, o); else { let r, i = t.getPartOpacityByIndex(e); r = o < s ? o * (s - 1) / s + 1 : (1 - o) * s / (1 - s); const n = (1 - r) * (1 - o); n > a && (r = 1 - a / (1 - o)), i > r && (i = r), t.setPartOpacityByIndex(e, i) } } } constructor() { this._fadeTimeSeconds = _, this._lastModel = void 0, this._partGroups = [], this._partGroupCounts = [] } } class g { constructor(t) { this.parameterIndex = 0, this.partIndex = 0, this.partId = "", this.link = [], void 0 != t && this.assignment(t) } assignment(t) { return this.partId = t.partId, this.link = t.link.map((t => t.clone())), this } initialize(t) { this.parameterIndex = t.getParameterIndex(this.partId), this.partIndex = t.getPartIndex(this.partId), t.setParameterValueByIndex(this.parameterIndex, 1) } clone() { const t = new g; return t.partId = this.partId, t.parameterIndex = this.parameterIndex, t.partIndex = this.partIndex, t.link = this.link.map((t => t.clone())), t } } class v { constructor(t, e) { this.x = t || 0, this.y = e || 0 } add(t) { const e = new v(0, 0); return e.x = this.x + t.x, e.y = this.y + t.y, e } substract(t) { const e = new v(0, 0); return e.x = this.x - t.x, e.y = this.y - t.y, e } multiply(t) { const e = new v(0, 0); return e.x = this.x * t.x, e.y = this.y * t.y, e } multiplyByScaler(t) { return this.multiply(new v(t, t)) } division(t) { const e = new v(0, 0); return e.x = this.x / t.x, e.y = this.y / t.y, e } divisionByScalar(t) { return this.division(new v(t, t)) } getLength() { return Math.sqrt(this.x * this.x + this.y * this.y) } getDistanceWith(t) { return Math.sqrt((this.x - t.x) * (this.x - t.x) + (this.y - t.y) * (this.y - t.y)) } dot(t) { return this.x * t.x + this.y * t.y } normalize() { const t = Math.pow(this.x * this.x + this.y * this.y, .5); this.x = this.x / t, this.y = this.y / t } isEqual(t) { return this.x == t.x && this.y == t.y } isNotEqual(t) { return !this.isEqual(t) } } const y = class { static range(t, e, r) { return t < e ? t = e : t > r && (t = r), t } static sin(t) { return Math.sin(t) } static cos(t) { return Math.cos(t) } static abs(t) { return Math.abs(t) } static sqrt(t) { return Math.sqrt(t) } static cbrt(t) { if (0 === t) return t; let e = t; const r = e < 0; let i; return r && (e = -e), e === 1 / 0 ? i = 1 / 0 : (i = Math.exp(Math.log(e) / 3), i = (e / (i * i) + 2 * i) / 3), r ? -i : i } static getEasingSine(t) { return t < 0 ? 0 : t > 1 ? 1 : .5 - .5 * this.cos(t * Math.PI) } static max(t, e) { return t > e ? t : e } static min(t, e) { return t > e ? e : t } static degreesToRadian(t) { return t / 180 * Math.PI } static radianToDegrees(t) { return 180 * t / Math.PI } static directionToRadian(t, e) { const r = Math.atan2(e.y, e.x), i = Math.atan2(t.y, t.x); let n = r - i; while (n < -Math.PI) n += 2 * Math.PI; while (n > Math.PI) n -= 2 * Math.PI; return n } static directionToDegrees(t, e) { const r = this.directionToRadian(t, e); let i = this.radianToDegrees(r); return e.x - t.x > 0 && (i = -i), i } static radianToDirection(t) { const e = new v; return e.x = this.sin(t), e.y = this.cos(t), e } static quadraticEquation(t, e, r) { return this.abs(t) < y.Epsilon ? this.abs(e) < y.Epsilon ? -r : -r / e : -(e + this.sqrt(e * e - 4 * t * r)) / (2 * t) } static cardanoAlgorithmForBezier(t, e, r, i) { if (this.sqrt(t) < y.Epsilon) return this.range(this.quadraticEquation(e, r, i), 0, 1); const n = e / t, o = r / t, s = i / t, a = (3 * o - n * n) / 3, u = a / 3, h = (2 * n * n * n - 9 * n * o + 27 * s) / 27, l = h / 2, c = l * l + u * u * u, d = .5, f = d + .01; if (c < 0) { const t = -a / 3, e = t * t * t, r = this.sqrt(e), i = -h / (2 * r), o = this.range(i, -1, 1), s = Math.acos(o), u = this.cbrt(r), l = 2 * u, c = l * this.cos(s / 3) - n / 3; if (this.abs(c - d) < f) return this.range(c, 0, 1); const p = l * this.cos((s + 2 * Math.PI) / 3) - n / 3; if (this.abs(p - d) < f) return this.range(p, 0, 1); const _ = l * this.cos((s + 4 * Math.PI) / 3) - n / 3; return this.range(_, 0, 1) } if (0 == c) { let t; t = l < 0 ? this.cbrt(-l) : -this.cbrt(l); const e = 2 * t - n / 3; if (this.abs(e - d) < f) return this.range(e, 0, 1); const r = -t - n / 3; return this.range(r, 0, 1) } const p = this.sqrt(c), _ = this.cbrt(p - l), m = this.cbrt(p + l), g = _ - m - n / 3; return this.range(g, 0, 1) } constructor() { } }; let b = y; b.Epsilon = 1e-5; class x { constructor() { this._tr = new Float32Array(16), this.loadIdentity() } static multiply(t, e, r) { const i = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), n = 4; for (let o = 0; o < n; ++o)for (let r = 0; r < n; ++r)for (let s = 0; s < n; ++s)i[r + 4 * o] += t[s + 4 * o] * e[r + 4 * s]; for (let o = 0; o < 16; ++o)r[o] = i[o] } loadIdentity() { const t = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]); this.setMatrix(t) } setMatrix(t) { for (let e = 0; e < 16; ++e)this._tr[e] = t[e] } getArray() { return this._tr } getScaleX() { return this._tr[0] } getScaleY() { return this._tr[5] } getTranslateX() { return this._tr[12] } getTranslateY() { return this._tr[13] } transformX(t) { return this._tr[0] * t + this._tr[12] } transformY(t) { return this._tr[5] * t + this._tr[13] } invertTransformX(t) { return (t - this._tr[12]) / this._tr[0] } invertTransformY(t) { return (t - this._tr[13]) / this._tr[5] } translateRelative(t, e) { const r = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, e, 0, 1]); x.multiply(r, this._tr, this._tr) } translate(t, e) { this._tr[12] = t, this._tr[13] = e } translateX(t) { this._tr[12] = t } translateY(t) { this._tr[13] = t } scaleRelative(t, e) { const r = new Float32Array([t, 0, 0, 0, 0, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]); x.multiply(r, this._tr, this._tr) } scale(t, e) { this._tr[0] = t, this._tr[5] = e } multiplyByMatrix(t) { x.multiply(t.getArray(), this._tr, this._tr) } clone() { const t = new x; for (let e = 0; e < this._tr.length; e++)t._tr[e] = this._tr[e]; return t } } class T { initialize(t) { this._model = t } drawModel() { null != this.getModel() && this.doDrawModel() } setMvpMatrix(t) { this._mvpMatrix4x4.setMatrix(t.getArray()) } getMvpMatrix() { return this._mvpMatrix4x4 } setModelColor(t, e, r, i) { t < 0 ? t = 0 : t > 1 && (t = 1), e < 0 ? e = 0 : e > 1 && (e = 1), r < 0 ? r = 0 : r > 1 && (r = 1), i < 0 ? i = 0 : i > 1 && (i = 1), this._modelColor.R = t, this._modelColor.G = e, this._modelColor.B = r, this._modelColor.A = i } getModelColor() { return Object.assign({}, this._modelColor) } setIsPremultipliedAlpha(t) { this._isPremultipliedAlpha = t } isPremultipliedAlpha() { return this._isPremultipliedAlpha } setIsCulling(t) { this._isCulling = t } isCulling() { return this._isCulling } setAnisotropy(t) { this._anisortopy = t } getAnisotropy() { return this._anisortopy } getModel() { return this._model } constructor() { this._isCulling = !1, this._isPremultipliedAlpha = !1, this._anisortopy = 0, this._modelColor = new S, this._mvpMatrix4x4 = new x, this._mvpMatrix4x4.loadIdentity() } } var E = (t => (t[t["CubismBlendMode_Normal"] = 0] = "CubismBlendMode_Normal", t[t["CubismBlendMode_Additive"] = 1] = "CubismBlendMode_Additive", t[t["CubismBlendMode_Multiplicative"] = 2] = "CubismBlendMode_Multiplicative", t))(E || {}); class S { constructor() { this.R = 1, this.G = 1, this.B = 1, this.A = 1 } } let w, A = !1, R = !1; const O = { vertexOffset: 0, vertexStep: 2 }; class I { static startUp(t) { if (A) return D("CubismFramework.startUp() is already done."), A; if (Live2DCubismCore._isStarted) return A = !0, !0; if (Live2DCubismCore._isStarted = !0, w = t, w && Live2DCubismCore.Logging.csmSetLogFunction(w.logFunction), A = !0, A) { const t = Live2DCubismCore.Version.csmGetVersion(), e = (4278190080 & t) >> 24, r = (16711680 & t) >> 16, i = 65535 & t, n = t; D("Live2D Cubism Core version: {0}.{1}.{2} ({3})", ("00" + e).slice(-2), ("00" + r).slice(-2), ("0000" + i).slice(-4), n) } return D("CubismFramework.startUp() is complete."), A } static cleanUp() { A = !1, R = !1, w = void 0 } static initialize() { A ? R ? L("CubismFramework.initialize() skipped, already initialized.") : (R = !0, D("CubismFramework.initialize() is complete.")) : L("CubismFramework is not started.") } static dispose() { A ? R ? (T.staticRelease(), R = !1, D("CubismFramework.dispose() is complete.")) : L("CubismFramework.dispose() skipped, not initialized.") : L("CubismFramework is not started.") } static isStarted() { return A } static isInitialized() { return R } static coreLogFunction(t) { Live2DCubismCore.Logging.csmGetLogFunction() && Live2DCubismCore.Logging.csmGetLogFunction()(t) } static getLoggingLevel() { return null != w ? w.loggingLevel : P.LogLevel_Off } constructor() { } } var P = (t => (t[t["LogLevel_Verbose"] = 0] = "LogLevel_Verbose", t[t["LogLevel_Debug"] = 1] = "LogLevel_Debug", t[t["LogLevel_Info"] = 2] = "LogLevel_Info", t[t["LogLevel_Warning"] = 3] = "LogLevel_Warning", t[t["LogLevel_Error"] = 4] = "LogLevel_Error", t[t["LogLevel_Off"] = 5] = "LogLevel_Off", t))(P || {}); const M = () => { }; function C(t, ...e) { N.print(P.LogLevel_Debug, "[CSM][D]" + t + "\n", e) } function D(t, ...e) { N.print(P.LogLevel_Info, "[CSM][I]" + t + "\n", e) } function L(t, ...e) { N.print(P.LogLevel_Warning, "[CSM][W]" + t + "\n", e) } function F(t, ...e) { N.print(P.LogLevel_Error, "[CSM][E]" + t + "\n", e) } class N { static print(t, e, r) { if (t < I.getLoggingLevel()) return; const i = I.coreLogFunction; if (!i) return; const n = e.replace(/{(\d+)}/g, ((t, e) => r[e])); i(n) } static dumpBytes(t, e, r) { for (let i = 0; i < r; i++)i % 16 == 0 && i > 0 ? this.print(t, "\n") : i % 8 == 0 && i > 0 && this.print(t, "  "), this.print(t, "{0} ", [255 & e[i]]); this.print(t, "\n") } constructor() { } } class B { update() { this._model.update(), this._model.drawables.resetDynamicFlags() } getCanvasWidth() { return null == this._model ? 0 : this._model.canvasinfo.CanvasWidth / this._model.canvasinfo.PixelsPerUnit } getCanvasHeight() { return null == this._model ? 0 : this._model.canvasinfo.CanvasHeight / this._model.canvasinfo.PixelsPerUnit } saveParameters() { const t = this._model.parameters.count, e = this._savedParameters.length; for (let r = 0; r < t; ++r)r < e ? this._savedParameters[r] = this._parameterValues[r] : this._savedParameters.push(this._parameterValues[r]) } getModel() { return this._model } getPartIndex(t) { let e; const r = this._model.parts.count; for (e = 0; e < r; ++e)if (t == this._partIds[e]) return e; return t in this._notExistPartId ? this._notExistPartId[t] : (e = r + this._notExistPartId.length, this._notExistPartId[t] = e, this._notExistPartOpacities[e] = 0, e) } getPartCount() { return this._model.parts.count } setPartOpacityByIndex(t, e) { t in this._notExistPartOpacities ? this._notExistPartOpacities[t] = e : (M(0 <= t && t < this.getPartCount()), this._partOpacities[t] = e) } setPartOpacityById(t, e) { const r = this.getPartIndex(t); r < 0 || this.setPartOpacityByIndex(r, e) } getPartOpacityByIndex(t) { return t in this._notExistPartOpacities ? this._notExistPartOpacities[t] : (M(0 <= t && t < this.getPartCount()), this._partOpacities[t]) } getPartOpacityById(t) { const e = this.getPartIndex(t); return e < 0 ? 0 : this.getPartOpacityByIndex(e) } getParameterIndex(t) { let e; const r = this._model.parameters.count; for (e = 0; e < r; ++e)if (t == this._parameterIds[e]) return e; return t in this._notExistParameterId ? this._notExistParameterId[t] : (e = this._model.parameters.count + Object.keys(this._notExistParameterId).length, this._notExistParameterId[t] = e, this._notExistParameterValues[e] = 0, e) } getParameterCount() { return this._model.parameters.count } getParameterMaximumValue(t) { return this._model.parameters.maximumValues[t] } getParameterMinimumValue(t) { return this._model.parameters.minimumValues[t] } getParameterDefaultValue(t) { return this._model.parameters.defaultValues[t] } getParameterValueByIndex(t) { return t in this._notExistParameterValues ? this._notExistParameterValues[t] : (M(0 <= t && t < this.getParameterCount()), this._parameterValues[t]) } getParameterValueById(t) { const e = this.getParameterIndex(t); return this.getParameterValueByIndex(e) } setParameterValueByIndex(t, e, r = 1) { t in this._notExistParameterValues ? this._notExistParameterValues[t] = 1 == r ? e : this._notExistParameterValues[t] * (1 - r) + e * r : (M(0 <= t && t < this.getParameterCount()), this._model.parameters.maximumValues[t] < e && (e = this._model.parameters.maximumValues[t]), this._model.parameters.minimumValues[t] > e && (e = this._model.parameters.minimumValues[t]), this._parameterValues[t] = 1 == r ? e : this._parameterValues[t] = this._parameterValues[t] * (1 - r) + e * r) } setParameterValueById(t, e, r = 1) { const i = this.getParameterIndex(t); this.setParameterValueByIndex(i, e, r) } addParameterValueByIndex(t, e, r = 1) { this.setParameterValueByIndex(t, this.getParameterValueByIndex(t) + e * r) } addParameterValueById(t, e, r = 1) { const i = this.getParameterIndex(t); this.addParameterValueByIndex(i, e, r) } multiplyParameterValueById(t, e, r = 1) { const i = this.getParameterIndex(t); this.multiplyParameterValueByIndex(i, e, r) } multiplyParameterValueByIndex(t, e, r = 1) { this.setParameterValueByIndex(t, this.getParameterValueByIndex(t) * (1 + (e - 1) * r)) } getDrawableIds() { return this._drawableIds.slice() } getDrawableIndex(t) { const e = this._model.drawables.count; for (let r = 0; r < e; ++r)if (this._drawableIds[r] == t) return r; return -1 } getDrawableCount() { return this._model.drawables.count } getDrawableId(t) { return this._model.drawables.ids[t] } getDrawableRenderOrders() { return this._model.drawables.renderOrders } getDrawableTextureIndices(t) { return this._model.drawables.textureIndices[t] } getDrawableDynamicFlagVertexPositionsDidChange(t) { const e = this._model.drawables.dynamicFlags; return Live2DCubismCore.Utils.hasVertexPositionsDidChangeBit(e[t]) } getDrawableVertexIndexCount(t) { return this._model.drawables.indexCounts[t] } getDrawableVertexCount(t) { return this._model.drawables.vertexCounts[t] } getDrawableVertices(t) { return this.getDrawableVertexPositions(t) } getDrawableVertexIndices(t) { return this._model.drawables.indices[t] } getDrawableVertexPositions(t) { return this._model.drawables.vertexPositions[t] } getDrawableVertexUvs(t) { return this._model.drawables.vertexUvs[t] } getDrawableOpacity(t) { return this._model.drawables.opacities[t] } getDrawableCulling(t) { const e = this._model.drawables.constantFlags; return !Live2DCubismCore.Utils.hasIsDoubleSidedBit(e[t]) } getDrawableBlendMode(t) { const e = this._model.drawables.constantFlags; return Live2DCubismCore.Utils.hasBlendAdditiveBit(e[t]) ? E.CubismBlendMode_Additive : Live2DCubismCore.Utils.hasBlendMultiplicativeBit(e[t]) ? E.CubismBlendMode_Multiplicative : E.CubismBlendMode_Normal } getDrawableInvertedMaskBit(t) { const e = this._model.drawables.constantFlags; return Live2DCubismCore.Utils.hasIsInvertedMaskBit(e[t]) } getDrawableMasks() { return this._model.drawables.masks } getDrawableMaskCounts() { return this._model.drawables.maskCounts } isUsingMasking() { for (let t = 0; t < this._model.drawables.count; ++t)if (!(this._model.drawables.maskCounts[t] <= 0)) return !0; return !1 } getDrawableDynamicFlagIsVisible(t) { const e = this._model.drawables.dynamicFlags; return Live2DCubismCore.Utils.hasIsVisibleBit(e[t]) } getDrawableDynamicFlagVisibilityDidChange(t) { const e = this._model.drawables.dynamicFlags; return Live2DCubismCore.Utils.hasVisibilityDidChangeBit(e[t]) } getDrawableDynamicFlagOpacityDidChange(t) { const e = this._model.drawables.dynamicFlags; return Live2DCubismCore.Utils.hasOpacityDidChangeBit(e[t]) } getDrawableDynamicFlagRenderOrderDidChange(t) { const e = this._model.drawables.dynamicFlags; return Live2DCubismCore.Utils.hasRenderOrderDidChangeBit(e[t]) } loadParameters() { let t = this._model.parameters.count; const e = this._savedParameters.length; t > e && (t = e); for (let r = 0; r < t; ++r)this._parameterValues[r] = this._savedParameters[r] } initialize() { this._parameterValues = this._model.parameters.values, this._partOpacities = this._model.parts.opacities, this._parameterMaximumValues = this._model.parameters.maximumValues, this._parameterMinimumValues = this._model.parameters.minimumValues; { const t = this._model.parameters.ids, e = this._model.parameters.count; for (let r = 0; r < e; ++r)this._parameterIds.push(t[r]) } { const t = this._model.parts.ids, e = this._model.parts.count; for (let r = 0; r < e; ++r)this._partIds.push(t[r]) } { const t = this._model.drawables.ids, e = this._model.drawables.count; for (let r = 0; r < e; ++r)this._drawableIds.push(t[r]) } } constructor(t) { this._model = t, this._savedParameters = [], this._parameterIds = [], this._drawableIds = [], this._partIds = [], this._notExistPartId = {}, this._notExistParameterId = {}, this._notExistParameterValues = {}, this._notExistPartOpacities = {}, this.initialize() } release() { this._model.release(), this._model = void 0 } } class U { static create(t) { const e = Live2DCubismCore.Moc.fromArrayBuffer(t); if (e) return new U(e); throw new Error("Unknown error") } createModel() { let t; const e = Live2DCubismCore.Model.fromMoc(this._moc); if (e) return t = new B(e), ++this._modelCount, t; throw new Error("Unknown error") } deleteModel(t) { null != t && --this._modelCount } constructor(t) { this._moc = t, this._modelCount = 0 } release() { this._moc._release(), this._moc = void 0 } } class k { constructor() { this._fadeInSeconds = -1, this._fadeOutSeconds = -1, this._weight = 1, this._offsetSeconds = 0, this._firedEventValues = [] } release() { this._weight = 0 } updateParameters(t, e, r) { if (!e.isAvailable() || e.isFinished()) return; if (!e.isStarted()) { e.setIsStarted(!0), e.setStartTime(r - this._offsetSeconds), e.setFadeInStartTime(r); const t = this.getDuration(); e.getEndTime() < 0 && e.setEndTime(t <= 0 ? -1 : e.getStartTime() + t) } let i = this._weight; const n = 0 == this._fadeInSeconds ? 1 : b.getEasingSine((r - e.getFadeInStartTime()) / this._fadeInSeconds), o = 0 == this._fadeOutSeconds || e.getEndTime() < 0 ? 1 : b.getEasingSine((e.getEndTime() - r) / this._fadeOutSeconds); i = i * n * o, e.setState(r, i), this.doUpdateParameters(t, r, i, e), e.getEndTime() > 0 && e.getEndTime() < r && e.setIsFinished(!0) } setFadeInTime(t) { this._fadeInSeconds = t } setFadeOutTime(t) { this._fadeOutSeconds = t } getFadeOutTime() { return this._fadeOutSeconds } getFadeInTime() { return this._fadeInSeconds } setWeight(t) { this._weight = t } getWeight() { return this._weight } getDuration() { return -1 } getLoopDuration() { return -1 } setOffsetTime(t) { this._offsetSeconds = t } getFiredEvent(t, e) { return this._firedEventValues } setFinishedMotionHandler(t) { this._onFinishedMotion = t } getFinishedMotionHandler() { return this._onFinishedMotion } } const G = 1; class X extends k { constructor() { super(), this._parameters = [] } static create(t) { const e = new X, r = t.FadeInTime, i = t.FadeOutTime; e.setFadeInTime(void 0 !== r ? r : G), e.setFadeOutTime(void 0 !== i ? i : G); const n = t.Parameters || []; for (let o = 0; o < n.length; ++o) { const t = n[o], r = t.Id, i = t.Value; let s; switch (t.Blend) { case "Multiply": s = H.ExpressionBlendType_Multiply; break; case "Overwrite": s = H.ExpressionBlendType_Overwrite; break; case "Add": default: s = H.ExpressionBlendType_Add; break }const a = { parameterId: r, blendType: s, value: i }; e._parameters.push(a) } return e } doUpdateParameters(t, e, r, i) { for (let n = 0; n < this._parameters.length; ++n) { const e = this._parameters[n]; switch (e.blendType) { case H.ExpressionBlendType_Add: t.addParameterValueById(e.parameterId, e.value, r); break; case H.ExpressionBlendType_Multiply: t.multiplyParameterValueById(e.parameterId, e.value, r); break; case H.ExpressionBlendType_Overwrite: t.setParameterValueById(e.parameterId, e.value, r); break } } } } var j, H = (t => (t[t["ExpressionBlendType_Add"] = 0] = "ExpressionBlendType_Add", t[t["ExpressionBlendType_Multiply"] = 1] = "ExpressionBlendType_Multiply", t[t["ExpressionBlendType_Overwrite"] = 2] = "ExpressionBlendType_Overwrite", t))(H || {}); (t => { t.supportMoreMaskDivisions = !0, t.setOpacityFromMotion = !1 })(j || (j = {})); var V = (t => (t[t["CubismMotionCurveTarget_Model"] = 0] = "CubismMotionCurveTarget_Model", t[t["CubismMotionCurveTarget_Parameter"] = 1] = "CubismMotionCurveTarget_Parameter", t[t["CubismMotionCurveTarget_PartOpacity"] = 2] = "CubismMotionCurveTarget_PartOpacity", t))(V || {}), z = (t => (t[t["CubismMotionSegmentType_Linear"] = 0] = "CubismMotionSegmentType_Linear", t[t["CubismMotionSegmentType_Bezier"] = 1] = "CubismMotionSegmentType_Bezier", t[t["CubismMotionSegmentType_Stepped"] = 2] = "CubismMotionSegmentType_Stepped", t[t["CubismMotionSegmentType_InverseStepped"] = 3] = "CubismMotionSegmentType_InverseStepped", t))(z || {}); class Y { constructor(t = 0, e = 0) { this.time = t, this.value = e } } class W { constructor() { this.basePointIndex = 0, this.segmentType = 0 } } class $ { constructor() { this.id = "", this.type = 0, this.segmentCount = 0, this.baseSegmentIndex = 0, this.fadeInTime = 0, this.fadeOutTime = 0 } } class q { constructor() { this.fireTime = 0, this.value = "" } } class K { constructor() { this.duration = 0, this.loop = !1, this.curveCount = 0, this.eventCount = 0, this.fps = 0, this.curves = [], this.segments = [], this.points = [], this.events = [] } } class Z { constructor(t) { this._json = t } release() { this._json = void 0 } getMotionDuration() { return this._json.Meta.Duration } isMotionLoop() { return this._json.Meta.Loop || !1 } getEvaluationOptionFlag(t) { return J.EvaluationOptionFlag_AreBeziersRistricted == t && !!this._json.Meta.AreBeziersRestricted } getMotionCurveCount() { return this._json.Meta.CurveCount } getMotionFps() { return this._json.Meta.Fps } getMotionTotalSegmentCount() { return this._json.Meta.TotalSegmentCount } getMotionTotalPointCount() { return this._json.Meta.TotalPointCount } getMotionFadeInTime() { return this._json.Meta.FadeInTime } getMotionFadeOutTime() { return this._json.Meta.FadeOutTime } getMotionCurveTarget(t) { return this._json.Curves[t].Target } getMotionCurveId(t) { return this._json.Curves[t].Id } getMotionCurveFadeInTime(t) { return this._json.Curves[t].FadeInTime } getMotionCurveFadeOutTime(t) { return this._json.Curves[t].FadeOutTime } getMotionCurveSegmentCount(t) { return this._json.Curves[t].Segments.length } getMotionCurveSegment(t, e) { return this._json.Curves[t].Segments[e] } getEventCount() { return this._json.Meta.UserDataCount || 0 } getTotalEventValueSize() { return this._json.Meta.TotalUserDataSize } getEventTime(t) { return this._json.UserData[t].Time } getEventValue(t) { return this._json.UserData[t].Value } } var J = (t => (t[t["EvaluationOptionFlag_AreBeziersRistricted"] = 0] = "EvaluationOptionFlag_AreBeziersRistricted", t))(J || {}); const Q = "EyeBlink", tt = "LipSync", et = "Model", rt = "Parameter", it = "PartOpacity", nt = !1; function ot(t, e, r) { const i = new Y; return i.time = t.time + (e.time - t.time) * r, i.value = t.value + (e.value - t.value) * r, i } function st(t, e) { let r = (e - t[0].time) / (t[1].time - t[0].time); return r < 0 && (r = 0), t[0].value + (t[1].value - t[0].value) * r } function at(t, e) { let r = (e - t[0].time) / (t[3].time - t[0].time); r < 0 && (r = 0); const i = ot(t[0], t[1], r), n = ot(t[1], t[2], r), o = ot(t[2], t[3], r), s = ot(i, n, r), a = ot(n, o, r); return ot(s, a, r).value } function ut(t, e) { const r = e, i = t[0].time, n = t[3].time, o = t[1].time, s = t[2].time, a = n - 3 * s + 3 * o - i, u = 3 * s - 6 * o + 3 * i, h = 3 * o - 3 * i, l = i - r, c = b.cardanoAlgorithmForBezier(a, u, h, l), d = ot(t[0], t[1], c), f = ot(t[1], t[2], c), p = ot(t[2], t[3], c), _ = ot(d, f, c), m = ot(f, p, c); return ot(_, m, c).value } function ht(t, e) { return t[0].value } function lt(t, e) { return t[1].value } function ct(t, e, r) { const i = t.curves[e]; let n = -1; const o = i.baseSegmentIndex + i.segmentCount; let s = 0; for (let u = i.baseSegmentIndex; u < o; ++u)if (s = t.segments[u].basePointIndex + (t.segments[u].segmentType == z.CubismMotionSegmentType_Bezier ? 3 : 1), t.points[s].time > r) { n = u; break } if (-1 == n) return t.points[s].value; const a = t.segments[n]; return a.evaluate(t.points.slice(a.basePointIndex), r) } class dt extends k { constructor() { super(), this._eyeBlinkParameterIds = [], this._lipSyncParameterIds = [], this._sourceFrameRate = 30, this._loopDurationSeconds = -1, this._isLoop = !1, this._isLoopFadeIn = !0, this._lastWeight = 0 } static create(t, e) { const r = new dt; return r.parse(t), r._sourceFrameRate = r._motionData.fps, r._loopDurationSeconds = r._motionData.duration, r._onFinishedMotion = e, r } doUpdateParameters(t, e, r, i) { null == this._modelCurveIdEyeBlink && (this._modelCurveIdEyeBlink = Q), null == this._modelCurveIdLipSync && (this._modelCurveIdLipSync = tt); let n = e - i.getStartTime(); n < 0 && (n = 0); let o = Number.MAX_VALUE, s = Number.MAX_VALUE; const a = 64; let u = 0, h = 0; this._eyeBlinkParameterIds.length > a && C("too many eye blink targets : {0}", this._eyeBlinkParameterIds.length), this._lipSyncParameterIds.length > a && C("too many lip sync targets : {0}", this._lipSyncParameterIds.length); const l = this._fadeInSeconds <= 0 ? 1 : b.getEasingSine((e - i.getFadeInStartTime()) / this._fadeInSeconds), c = this._fadeOutSeconds <= 0 || i.getEndTime() < 0 ? 1 : b.getEasingSine((i.getEndTime() - e) / this._fadeOutSeconds); let d, f, p, _ = n; if (this._isLoop) while (_ > this._motionData.duration) _ -= this._motionData.duration; const m = this._motionData.curves; for (f = 0; f < this._motionData.curveCount && m[f].type == V.CubismMotionCurveTarget_Model; ++f)d = ct(this._motionData, f, _), m[f].id == this._modelCurveIdEyeBlink ? s = d : m[f].id == this._modelCurveIdLipSync && (o = d); for (; f < this._motionData.curveCount && m[f].type == V.CubismMotionCurveTarget_Parameter; ++f) { if (p = t.getParameterIndex(m[f].id), -1 == p) continue; const n = t.getParameterValueByIndex(p); if (d = ct(this._motionData, f, _), s != Number.MAX_VALUE) for (let t = 0; t < this._eyeBlinkParameterIds.length && t < a; ++t)if (this._eyeBlinkParameterIds[t] == m[f].id) { d *= s, h |= 1 << t; break } if (o != Number.MAX_VALUE) for (let t = 0; t < this._lipSyncParameterIds.length && t < a; ++t)if (this._lipSyncParameterIds[t] == m[f].id) { d += o, u |= 1 << t; break } let g; if (m[f].fadeInTime < 0 && m[f].fadeOutTime < 0) g = n + (d - n) * r; else { let t, r; t = m[f].fadeInTime < 0 ? l : 0 == m[f].fadeInTime ? 1 : b.getEasingSine((e - i.getFadeInStartTime()) / m[f].fadeInTime), r = m[f].fadeOutTime < 0 ? c : 0 == m[f].fadeOutTime || i.getEndTime() < 0 ? 1 : b.getEasingSine((i.getEndTime() - e) / m[f].fadeOutTime); const o = this._weight * t * r; g = n + (d - n) * o } t.setParameterValueByIndex(p, g, 1) } if (s != Number.MAX_VALUE) for (let g = 0; g < this._eyeBlinkParameterIds.length && g < a; ++g) { const e = t.getParameterValueById(this._eyeBlinkParameterIds[g]); if (h >> g & 1) continue; const i = e + (s - e) * r; t.setParameterValueById(this._eyeBlinkParameterIds[g], i) } if (o != Number.MAX_VALUE) for (let g = 0; g < this._lipSyncParameterIds.length && g < a; ++g) { const e = t.getParameterValueById(this._lipSyncParameterIds[g]); if (u >> g & 1) continue; const i = e + (o - e) * r; t.setParameterValueById(this._lipSyncParameterIds[g], i) } for (; f < this._motionData.curveCount && m[f].type == V.CubismMotionCurveTarget_PartOpacity; ++f)if (d = ct(this._motionData, f, _), j.setOpacityFromMotion) t.setPartOpacityById(m[f].id, d); else { if (p = t.getParameterIndex(m[f].id), -1 == p) continue; t.setParameterValueByIndex(p, d) } n >= this._motionData.duration && (this._isLoop ? (i.setStartTime(e), this._isLoopFadeIn && i.setFadeInStartTime(e)) : (this._onFinishedMotion && this._onFinishedMotion(this), i.setIsFinished(!0))), this._lastWeight = r } setIsLoop(t) { this._isLoop = t } isLoop() { return this._isLoop } setIsLoopFadeIn(t) { this._isLoopFadeIn = t } isLoopFadeIn() { return this._isLoopFadeIn } getDuration() { return this._isLoop ? -1 : this._loopDurationSeconds } getLoopDuration() { return this._loopDurationSeconds } setParameterFadeInTime(t, e) { const r = this._motionData.curves; for (let i = 0; i < this._motionData.curveCount; ++i)if (t == r[i].id) return void (r[i].fadeInTime = e) } setParameterFadeOutTime(t, e) { const r = this._motionData.curves; for (let i = 0; i < this._motionData.curveCount; ++i)if (t == r[i].id) return void (r[i].fadeOutTime = e) } getParameterFadeInTime(t) { const e = this._motionData.curves; for (let r = 0; r < this._motionData.curveCount; ++r)if (t == e[r].id) return e[r].fadeInTime; return -1 } getParameterFadeOutTime(t) { const e = this._motionData.curves; for (let r = 0; r < this._motionData.curveCount; ++r)if (t == e[r].id) return e[r].fadeOutTime; return -1 } setEffectIds(t, e) { this._eyeBlinkParameterIds = t, this._lipSyncParameterIds = e } release() { this._motionData = void 0 } parse(t) { this._motionData = new K; let e = new Z(t); this._motionData.duration = e.getMotionDuration(), this._motionData.loop = e.isMotionLoop(), this._motionData.curveCount = e.getMotionCurveCount(), this._motionData.fps = e.getMotionFps(), this._motionData.eventCount = e.getEventCount(); const r = e.getEvaluationOptionFlag(J.EvaluationOptionFlag_AreBeziersRistricted), i = e.getMotionFadeInTime(), n = e.getMotionFadeOutTime(); this._fadeInSeconds = void 0 !== i ? i < 0 ? 1 : i : 1, this._fadeOutSeconds = void 0 !== n ? n < 0 ? 1 : n : 1, this._motionData.curves = Array.from({ length: this._motionData.curveCount }).map((() => new $)), this._motionData.segments = Array.from({ length: e.getMotionTotalSegmentCount() }).map((() => new W)), this._motionData.events = Array.from({ length: this._motionData.eventCount }).map((() => new q)), this._motionData.points = []; let o = 0, s = 0; for (let a = 0; a < this._motionData.curveCount; ++a) { const t = this._motionData.curves[a]; switch (e.getMotionCurveTarget(a)) { case et: t.type = V.CubismMotionCurveTarget_Model; break; case rt: t.type = V.CubismMotionCurveTarget_Parameter; break; case it: t.type = V.CubismMotionCurveTarget_PartOpacity; break; default: L('Warning : Unable to get segment type from Curve! The number of "CurveCount" may be incorrect!') }t.id = e.getMotionCurveId(a), t.baseSegmentIndex = s; const i = e.getMotionCurveFadeInTime(a), n = e.getMotionCurveFadeOutTime(a); t.fadeInTime = void 0 !== i ? i : -1, t.fadeOutTime = void 0 !== n ? n : -1; for (let u = 0; u < e.getMotionCurveSegmentCount(a);) { 0 == u ? (this._motionData.segments[s].basePointIndex = o, this._motionData.points[o] = new Y(e.getMotionCurveSegment(a, u), e.getMotionCurveSegment(a, u + 1)), o += 1, u += 2) : this._motionData.segments[s].basePointIndex = o - 1; const i = e.getMotionCurveSegment(a, u); switch (i) { case z.CubismMotionSegmentType_Linear: this._motionData.segments[s].segmentType = z.CubismMotionSegmentType_Linear, this._motionData.segments[s].evaluate = st, this._motionData.points[o] = new Y(e.getMotionCurveSegment(a, u + 1), e.getMotionCurveSegment(a, u + 2)), o += 1, u += 3; break; case z.CubismMotionSegmentType_Bezier: this._motionData.segments[s].segmentType = z.CubismMotionSegmentType_Bezier, this._motionData.segments[s].evaluate = r || nt ? at : ut, this._motionData.points[o] = new Y(e.getMotionCurveSegment(a, u + 1), e.getMotionCurveSegment(a, u + 2)), this._motionData.points[o + 1] = new Y(e.getMotionCurveSegment(a, u + 3), e.getMotionCurveSegment(a, u + 4)), this._motionData.points[o + 2] = new Y(e.getMotionCurveSegment(a, u + 5), e.getMotionCurveSegment(a, u + 6)), o += 3, u += 7; break; case z.CubismMotionSegmentType_Stepped: this._motionData.segments[s].segmentType = z.CubismMotionSegmentType_Stepped, this._motionData.segments[s].evaluate = ht, this._motionData.points[o] = new Y(e.getMotionCurveSegment(a, u + 1), e.getMotionCurveSegment(a, u + 2)), o += 1, u += 3; break; case z.CubismMotionSegmentType_InverseStepped: this._motionData.segments[s].segmentType = z.CubismMotionSegmentType_InverseStepped, this._motionData.segments[s].evaluate = lt, this._motionData.points[o] = new Y(e.getMotionCurveSegment(a, u + 1), e.getMotionCurveSegment(a, u + 2)), o += 1, u += 3; break }++t.segmentCount, ++s } this._motionData.curves.push(t) } for (let a = 0; a < e.getEventCount(); ++a)this._motionData.events[a].fireTime = e.getEventTime(a), this._motionData.events[a].value = e.getEventValue(a); e.release() } getFiredEvent(t, e) { this._firedEventValues.length = 0; for (let r = 0; r < this._motionData.eventCount; ++r)this._motionData.events[r].fireTime > t && this._motionData.events[r].fireTime <= e && this._firedEventValues.push(this._motionData.events[r].value); return this._firedEventValues } } class ft { constructor() { this._autoDelete = !1, this._available = !0, this._finished = !1, this._started = !1, this._startTimeSeconds = -1, this._fadeInStartTimeSeconds = 0, this._endTimeSeconds = -1, this._stateTimeSeconds = 0, this._stateWeight = 0, this._lastEventCheckSeconds = 0, this._motionQueueEntryHandle = this, this._fadeOutSeconds = 0, this._isTriggeredFadeOut = !1 } release() { this._autoDelete && this._motion && this._motion.release() } setFadeOut(t) { this._fadeOutSeconds = t, this._isTriggeredFadeOut = !0 } startFadeOut(t, e) { const r = e + t; this._isTriggeredFadeOut = !0, (this._endTimeSeconds < 0 || r < this._endTimeSeconds) && (this._endTimeSeconds = r) } isFinished() { return this._finished } isStarted() { return this._started } getStartTime() { return this._startTimeSeconds } getFadeInStartTime() { return this._fadeInStartTimeSeconds } getEndTime() { return this._endTimeSeconds } setStartTime(t) { this._startTimeSeconds = t } setFadeInStartTime(t) { this._fadeInStartTimeSeconds = t } setEndTime(t) { this._endTimeSeconds = t } setIsFinished(t) { this._finished = t } setIsStarted(t) { this._started = t } isAvailable() { return this._available } setIsAvailable(t) { this._available = t } setState(t, e) { this._stateTimeSeconds = t, this._stateWeight = e } getStateTime() { return this._stateTimeSeconds } getStateWeight() { return this._stateWeight } getLastCheckEventSeconds() { return this._lastEventCheckSeconds } setLastCheckEventSeconds(t) { this._lastEventCheckSeconds = t } isTriggeredFadeOut() { return this._isTriggeredFadeOut } getFadeOutSeconds() { return this._fadeOutSeconds } } class pt { constructor() { this._userTimeSeconds = 0, this._eventCustomData = null, this._motions = [] } release() { for (let t = 0; t < this._motions.length; ++t)this._motions[t] && this._motions[t].release(); this._motions = void 0 } startMotion(t, e, r) { if (null == t) return _t; let i; for (let n = 0; n < this._motions.length; ++n)i = this._motions[n], null != i && i.setFadeOut(i._motion.getFadeOutTime()); return i = new ft, i._autoDelete = e, i._motion = t, this._motions.push(i), i._motionQueueEntryHandle } isFinished() { let t = 0; while (t < this._motions.length) { const e = this._motions[t]; if (null == e) { this._motions.splice(t, 1); continue } const r = e._motion; if (null != r) { if (!e.isFinished()) return !1; t++ } else e.release(), this._motions.splice(t, 1) } return !0 } isFinishedByHandle(t) { for (let e = 0; e < this._motions.length; e++) { const r = this._motions[e]; if (null != r && (r._motionQueueEntryHandle == t && !r.isFinished())) return !1 } return !0 } stopAllMotions() { for (let t = 0; t < this._motions.length; t++) { const e = this._motions[t]; null != e && e.release() } this._motions = [] } getCubismMotionQueueEntry(t) { return this._motions.find((e => null != e && e._motionQueueEntryHandle == t)) } setEventCallback(t, e = null) { this._eventCallBack = t, this._eventCustomData = e } doUpdateMotion(t, e) { let r = !1, i = 0; while (i < this._motions.length) { const n = this._motions[i]; if (null == n) { this._motions.splice(i, 1); continue } const o = n._motion; if (null == o) { n.release(), this._motions.splice(i, 1); continue } o.updateParameters(t, n, e), r = !0; const s = o.getFiredEvent(n.getLastCheckEventSeconds() - n.getStartTime(), e - n.getStartTime()); for (let t = 0; t < s.length; ++t)this._eventCallBack(this, s[t], this._eventCustomData); n.setLastCheckEventSeconds(e), n.isFinished() ? (n.release(), this._motions.splice(i, 1)) : (n.isTriggeredFadeOut() && n.startFadeOut(n.getFadeOutSeconds(), e), i++) } return r } } const _t = -1; var mt = (t => (t[t["CubismPhysicsTargetType_Parameter"] = 0] = "CubismPhysicsTargetType_Parameter", t))(mt || {}), gt = (t => (t[t["CubismPhysicsSource_X"] = 0] = "CubismPhysicsSource_X", t[t["CubismPhysicsSource_Y"] = 1] = "CubismPhysicsSource_Y", t[t["CubismPhysicsSource_Angle"] = 2] = "CubismPhysicsSource_Angle", t))(gt || {}); class vt { constructor() { this.initialPosition = new v(0, 0), this.position = new v(0, 0), this.lastPosition = new v(0, 0), this.lastGravity = new v(0, 0), this.force = new v(0, 0), this.velocity = new v(0, 0) } } class yt { constructor() { this.normalizationPosition = {}, this.normalizationAngle = {} } } class bt { constructor() { this.source = {} } } class xt { constructor() { this.destination = {}, this.translationScale = new v(0, 0) } } class Tt { constructor() { this.settings = [], this.inputs = [], this.outputs = [], this.particles = [], this.gravity = new v(0, 0), this.wind = new v(0, 0) } } class Et { constructor(t) { this._json = t } release() { this._json = void 0 } getGravity() { const t = new v(0, 0); return t.x = this._json.Meta.EffectiveForces.Gravity.X, t.y = this._json.Meta.EffectiveForces.Gravity.Y, t } getWind() { const t = new v(0, 0); return t.x = this._json.Meta.EffectiveForces.Wind.X, t.y = this._json.Meta.EffectiveForces.Wind.Y, t } getSubRigCount() { return this._json.Meta.PhysicsSettingCount } getTotalInputCount() { return this._json.Meta.TotalInputCount } getTotalOutputCount() { return this._json.Meta.TotalOutputCount } getVertexCount() { return this._json.Meta.VertexCount } getNormalizationPositionMinimumValue(t) { return this._json.PhysicsSettings[t].Normalization.Position.Minimum } getNormalizationPositionMaximumValue(t) { return this._json.PhysicsSettings[t].Normalization.Position.Maximum } getNormalizationPositionDefaultValue(t) { return this._json.PhysicsSettings[t].Normalization.Position.Default } getNormalizationAngleMinimumValue(t) { return this._json.PhysicsSettings[t].Normalization.Angle.Minimum } getNormalizationAngleMaximumValue(t) { return this._json.PhysicsSettings[t].Normalization.Angle.Maximum } getNormalizationAngleDefaultValue(t) { return this._json.PhysicsSettings[t].Normalization.Angle.Default } getInputCount(t) { return this._json.PhysicsSettings[t].Input.length } getInputWeight(t, e) { return this._json.PhysicsSettings[t].Input[e].Weight } getInputReflect(t, e) { return this._json.PhysicsSettings[t].Input[e].Reflect } getInputType(t, e) { return this._json.PhysicsSettings[t].Input[e].Type } getInputSourceId(t, e) { return this._json.PhysicsSettings[t].Input[e].Source.Id } getOutputCount(t) { return this._json.PhysicsSettings[t].Output.length } getOutputVertexIndex(t, e) { return this._json.PhysicsSettings[t].Output[e].VertexIndex } getOutputAngleScale(t, e) { return this._json.PhysicsSettings[t].Output[e].Scale } getOutputWeight(t, e) { return this._json.PhysicsSettings[t].Output[e].Weight } getOutputDestinationId(t, e) { return this._json.PhysicsSettings[t].Output[e].Destination.Id } getOutputType(t, e) { return this._json.PhysicsSettings[t].Output[e].Type } getOutputReflect(t, e) { return this._json.PhysicsSettings[t].Output[e].Reflect } getParticleCount(t) { return this._json.PhysicsSettings[t].Vertices.length } getParticleMobility(t, e) { return this._json.PhysicsSettings[t].Vertices[e].Mobility } getParticleDelay(t, e) { return this._json.PhysicsSettings[t].Vertices[e].Delay } getParticleAcceleration(t, e) { return this._json.PhysicsSettings[t].Vertices[e].Acceleration } getParticleRadius(t, e) { return this._json.PhysicsSettings[t].Vertices[e].Radius } getParticlePosition(t, e) { const r = new v(0, 0); return r.x = this._json.PhysicsSettings[t].Vertices[e].Position.X, r.y = this._json.PhysicsSettings[t].Vertices[e].Position.Y, r } } const St = "X", wt = "Y", At = "Angle", Rt = 5, Ot = 100, It = .001; class Pt { static create(t) { const e = new Pt; return e.parse(t), e._physicsRig.gravity.y = 0, e } evaluate(t, e) { let r, i, n, o; const s = new v; let a, u, h, l, c, d, f, p; c = t.getModel().parameters.values, d = t.getModel().parameters.maximumValues, f = t.getModel().parameters.minimumValues, p = t.getModel().parameters.defaultValues; for (let _ = 0; _ < this._physicsRig.subRigCount; ++_) { r = { angle: 0 }, s.x = 0, s.y = 0, a = this._physicsRig.settings[_], u = this._physicsRig.inputs.slice(a.baseInputIndex), h = this._physicsRig.outputs.slice(a.baseOutputIndex), l = this._physicsRig.particles.slice(a.baseParticleIndex); for (let e = 0; e < a.inputCount; ++e)i = u[e].weight / Ot, -1 == u[e].sourceParameterIndex && (u[e].sourceParameterIndex = t.getParameterIndex(u[e].source.id)), u[e].getNormalizedParameterValue(s, r, c[u[e].sourceParameterIndex], f[u[e].sourceParameterIndex], d[u[e].sourceParameterIndex], p[u[e].sourceParameterIndex], a.normalizationPosition, a.normalizationAngle, u[e].reflect, i); n = b.degreesToRadian(-r.angle), s.x = s.x * b.cos(n) - s.y * b.sin(n), s.y = s.x * b.sin(n) + s.y * b.cos(n), Ht(l, a.particleCount, s, r.angle, this._options.wind, It * a.normalizationPosition.maximum, e, Rt); for (let e = 0; e < a.outputCount; ++e) { const r = h[e].vertexIndex; if (r < 1 || r >= a.particleCount) break; -1 == h[e].destinationParameterIndex && (h[e].destinationParameterIndex = t.getParameterIndex(h[e].destination.id)); const i = new v; i.x = l[r].position.x - l[r - 1].position.x, i.y = l[r].position.y - l[r - 1].position.y, o = h[e].getValue(i, l, r, h[e].reflect, this._options.gravity); const n = h[e].destinationParameterIndex, s = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(JSON.stringify(c.subarray(n))) : c.slice(n); Vt(s, f[n], d[n], o, h[e]); for (let t = n, e = 0; t < c.length; t++, e++)c[t] = s[e] } } } setOptions(t) { this._options = t } getOption() { return this._options } constructor() { this._options = new Mt, this._options.gravity.y = -1, this._options.gravity.x = 0, this._options.wind.x = 0, this._options.wind.y = 0 } release() { this._physicsRig = void 0 } parse(t) { this._physicsRig = new Tt; let e = new Et(t); this._physicsRig.gravity = e.getGravity(), this._physicsRig.wind = e.getWind(), this._physicsRig.subRigCount = e.getSubRigCount(); let r = 0, i = 0, n = 0; for (let o = 0; o < this._physicsRig.subRigCount; ++o) { const t = new yt; t.normalizationPosition.minimum = e.getNormalizationPositionMinimumValue(o), t.normalizationPosition.maximum = e.getNormalizationPositionMaximumValue(o), t.normalizationPosition.defalut = e.getNormalizationPositionDefaultValue(o), t.normalizationAngle.minimum = e.getNormalizationAngleMinimumValue(o), t.normalizationAngle.maximum = e.getNormalizationAngleMaximumValue(o), t.normalizationAngle.defalut = e.getNormalizationAngleDefaultValue(o), t.inputCount = e.getInputCount(o), t.baseInputIndex = r, r += t.inputCount; for (let r = 0; r < t.inputCount; ++r) { const t = new bt; switch (t.sourceParameterIndex = -1, t.weight = e.getInputWeight(o, r), t.reflect = e.getInputReflect(o, r), e.getInputType(o, r)) { case St: t.type = gt.CubismPhysicsSource_X, t.getNormalizedParameterValue = Ct; break; case wt: t.type = gt.CubismPhysicsSource_Y, t.getNormalizedParameterValue = Dt; break; case At: t.type = gt.CubismPhysicsSource_Angle, t.getNormalizedParameterValue = Lt; break }t.source.targetType = mt.CubismPhysicsTargetType_Parameter, t.source.id = e.getInputSourceId(o, r), this._physicsRig.inputs.push(t) } t.outputCount = e.getOutputCount(o), t.baseOutputIndex = i, i += t.outputCount; for (let r = 0; r < t.outputCount; ++r) { const t = new xt; switch (t.destinationParameterIndex = -1, t.vertexIndex = e.getOutputVertexIndex(o, r), t.angleScale = e.getOutputAngleScale(o, r), t.weight = e.getOutputWeight(o, r), t.destination.targetType = mt.CubismPhysicsTargetType_Parameter, t.destination.id = e.getOutputDestinationId(o, r), e.getOutputType(o, r)) { case St: t.type = gt.CubismPhysicsSource_X, t.getValue = Ft, t.getScale = Gt; break; case wt: t.type = gt.CubismPhysicsSource_Y, t.getValue = Nt, t.getScale = Xt; break; case At: t.type = gt.CubismPhysicsSource_Angle, t.getValue = Bt, t.getScale = jt; break }t.reflect = e.getOutputReflect(o, r), this._physicsRig.outputs.push(t) } t.particleCount = e.getParticleCount(o), t.baseParticleIndex = n, n += t.particleCount; for (let r = 0; r < t.particleCount; ++r) { const t = new vt; t.mobility = e.getParticleMobility(o, r), t.delay = e.getParticleDelay(o, r), t.acceleration = e.getParticleAcceleration(o, r), t.radius = e.getParticleRadius(o, r), t.position = e.getParticlePosition(o, r), this._physicsRig.particles.push(t) } this._physicsRig.settings.push(t) } this.initialize(), e.release() } initialize() { let t, e, r; for (let i = 0; i < this._physicsRig.subRigCount; ++i) { e = this._physicsRig.settings[i], t = this._physicsRig.particles.slice(e.baseParticleIndex), t[0].initialPosition = new v(0, 0), t[0].lastPosition = new v(t[0].initialPosition.x, t[0].initialPosition.y), t[0].lastGravity = new v(0, -1), t[0].lastGravity.y *= -1, t[0].velocity = new v(0, 0), t[0].force = new v(0, 0); for (let i = 1; i < e.particleCount; ++i)r = new v(0, 0), r.y = t[i].radius, t[i].initialPosition = new v(t[i - 1].initialPosition.x + r.x, t[i - 1].initialPosition.y + r.y), t[i].position = new v(t[i].initialPosition.x, t[i].initialPosition.y), t[i].lastPosition = new v(t[i].initialPosition.x, t[i].initialPosition.y), t[i].lastGravity = new v(0, -1), t[i].lastGravity.y *= -1, t[i].velocity = new v(0, 0), t[i].force = new v(0, 0) } } } class Mt { constructor() { this.gravity = new v(0, 0), this.wind = new v(0, 0) } } function Ct(t, e, r, i, n, o, s, a, u, h) { t.x += zt(r, i, n, o, s.minimum, s.maximum, s.defalut, u) * h } function Dt(t, e, r, i, n, o, s, a, u, h) { t.y += zt(r, i, n, o, s.minimum, s.maximum, s.defalut, u) * h } function Lt(t, e, r, i, n, o, s, a, u, h) { e.angle += zt(r, i, n, o, a.minimum, a.maximum, a.defalut, u) * h } function Ft(t, e, r, i, n) { let o = t.x; return i && (o *= -1), o } function Nt(t, e, r, i, n) { let o = t.y; return i && (o *= -1), o } function Bt(t, e, r, i, n) { let o; return n = r >= 2 ? e[r - 1].position.substract(e[r - 2].position) : n.multiplyByScaler(-1), o = b.directionToRadian(n, t), i && (o *= -1), o } function Ut(t, e) { return Math.abs(Math.max(t, e) - Math.min(t, e)) } function kt(t, e) { const r = Math.min(t, e); return r + Ut(t, e) / 2 } function Gt(t, e) { return t.x } function Xt(t, e) { return t.y } function jt(t, e) { return e } function Ht(t, e, r, i, n, o, s, a) { let u, h, l, c, d = new v(0, 0), f = new v(0, 0), p = new v(0, 0), _ = new v(0, 0); t[0].position = new v(r.x, r.y), u = b.degreesToRadian(i), c = b.radianToDirection(u), c.normalize(); for (let m = 1; m < e; ++m)t[m].force = c.multiplyByScaler(t[m].acceleration).add(n), t[m].lastPosition = new v(t[m].position.x, t[m].position.y), h = t[m].delay * s * 30, d = t[m].position.substract(t[m - 1].position), l = b.directionToRadian(t[m].lastGravity, c) / a, d.x = b.cos(l) * d.x - d.y * b.sin(l), d.y = b.sin(l) * d.x + d.y * b.cos(l), t[m].position = t[m - 1].position.add(d), f = t[m].velocity.multiplyByScaler(h), p = t[m].force.multiplyByScaler(h).multiplyByScaler(h), t[m].position = t[m].position.add(f).add(p), _ = t[m].position.substract(t[m - 1].position), _.normalize(), t[m].position = t[m - 1].position.add(_.multiplyByScaler(t[m].radius)), b.abs(t[m].position.x) < o && (t[m].position.x = 0), 0 != h && (t[m].velocity = t[m].position.substract(t[m].lastPosition), t[m].velocity = t[m].velocity.divisionByScalar(h), t[m].velocity = t[m].velocity.multiplyByScaler(t[m].mobility)), t[m].force = new v(0, 0), t[m].lastGravity = new v(c.x, c.y) } function Vt(t, e, r, i, n) { let o, s, a; o = n.getScale(n.translationScale, n.angleScale), s = i * o, s < e ? (s < n.valueBelowMinimum && (n.valueBelowMinimum = s), s = e) : s > r && (s > n.valueExceededMaximum && (n.valueExceededMaximum = s), s = r), a = n.weight / Ot, a >= 1 || (s = t[0] * (1 - a) + s * a), t[0] = s } function zt(t, e, r, i, n, o, s, a) { let u = 0; const h = b.max(r, e); h < t && (t = h); const l = b.min(r, e); l > t && (t = l); const c = b.min(n, o), d = b.max(n, o), f = s, p = kt(l, h), _ = t - p; switch (Math.sign(_)) { case 1: { const t = d - f, e = h - p; 0 != e && (u = _ * (t / e), u += f); break } case -1: { const t = c - f, e = l - p; 0 != e && (u = _ * (t / e), u += f); break } case 0: u = f; break }return a ? u : -1 * u } class Yt { constructor(t = 0, e = 0, r = 0, i = 0) { this.x = t, this.y = e, this.width = r, this.height = i } getCenterX() { return this.x + .5 * this.width } getCenterY() { return this.y + .5 * this.height } getRight() { return this.x + this.width } getBottom() { return this.y + this.height } setRect(t) { this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height } expand(t, e) { this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e } } const Wt = 4, $t = 10; let qt, Kt, Zt; class Jt { getChannelFlagAsColor(t) { return this._channelColors[t] } getMaskRenderTexture() { let t = 0; if (this._maskTexture && 0 != this._maskTexture.texture && (this._maskTexture.frameNo = this._currentFrameNo, t = this._maskTexture.texture), 0 == t) { const e = this._clippingMaskBufferSize; this._colorBuffer = this.gl.createTexture(), this.gl.bindTexture(this.gl.TEXTURE_2D, this._colorBuffer), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, e, e, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.bindTexture(this.gl.TEXTURE_2D, null), t = this.gl.createFramebuffer(), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, t), this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this._colorBuffer, 0), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, Zt), this._maskTexture = new Qt(this._currentFrameNo, t) } return t } setGL(t) { this.gl = t } calcClippedDrawTotalBounds(t, e) { let r = Number.MAX_VALUE, i = Number.MAX_VALUE, n = Number.MIN_VALUE, o = Number.MIN_VALUE; const s = e._clippedDrawableIndexList.length; for (let a = 0; a < s; a++) { const s = e._clippedDrawableIndexList[a], u = t.getDrawableVertexCount(s), h = t.getDrawableVertices(s); let l = Number.MAX_VALUE, c = Number.MAX_VALUE, d = Number.MIN_VALUE, f = Number.MIN_VALUE; const p = u * O.vertexStep; for (let t = O.vertexOffset; t < p; t += O.vertexStep) { const e = h[t], r = h[t + 1]; e < l && (l = e), e > d && (d = e), r < c && (c = r), r > f && (f = r) } if (l != Number.MAX_VALUE) if (l < r && (r = l), c < i && (i = c), d > n && (n = d), f > o && (o = f), r == Number.MAX_VALUE) e._allClippedDrawRect.x = 0, e._allClippedDrawRect.y = 0, e._allClippedDrawRect.width = 0, e._allClippedDrawRect.height = 0, e._isUsing = !1; else { e._isUsing = !0; const t = n - r, s = o - i; e._allClippedDrawRect.x = r, e._allClippedDrawRect.y = i, e._allClippedDrawRect.width = t, e._allClippedDrawRect.height = s } } } constructor() { this._maskRenderTexture = null, this._colorBuffer = null, this._currentFrameNo = 0, this._clippingMaskBufferSize = 256, this._clippingContextListForMask = [], this._clippingContextListForDraw = [], this._channelColors = [], this._tmpBoundsOnModel = new Yt, this._tmpMatrix = new x, this._tmpMatrixForMask = new x, this._tmpMatrixForDraw = new x; let t = new S; t.R = 1, t.G = 0, t.B = 0, t.A = 0, this._channelColors.push(t), t = new S, t.R = 0, t.G = 1, t.B = 0, t.A = 0, this._channelColors.push(t), t = new S, t.R = 0, t.G = 0, t.B = 1, t.A = 0, this._channelColors.push(t), t = new S, t.R = 0, t.G = 0, t.B = 0, t.A = 1, this._channelColors.push(t) } release() { var t, e, r; const i = this; for (let n = 0; n < this._clippingContextListForMask.length; n++)this._clippingContextListForMask[n] && (null == (t = this._clippingContextListForMask[n]) || t.release()); i._clippingContextListForMask = void 0, i._clippingContextListForDraw = void 0, this._maskTexture && (null == (e = this.gl) || e.deleteFramebuffer(this._maskTexture.texture), i._maskTexture = void 0), i._channelColors = void 0, null == (r = this.gl) || r.deleteTexture(this._colorBuffer), this._colorBuffer = null } initialize(t, e, r, i) { for (let n = 0; n < e; n++) { if (i[n] <= 0) { this._clippingContextListForDraw.push(null); continue } let t = this.findSameClip(r[n], i[n]); null == t && (t = new te(this, r[n], i[n]), this._clippingContextListForMask.push(t)), t.addClippedDrawable(n), this._clippingContextListForDraw.push(t) } } setupClippingContext(t, e) { this._currentFrameNo++; let r = 0; for (let i = 0; i < this._clippingContextListForMask.length; i++) { const e = this._clippingContextListForMask[i]; this.calcClippedDrawTotalBounds(t, e), e._isUsing && r++ } if (r > 0) { this.gl.viewport(0, 0, this._clippingMaskBufferSize, this._clippingMaskBufferSize), this._maskRenderTexture = this.getMaskRenderTexture(), e.getMvpMatrix(), e.preDraw(), this.setupLayoutBounds(r), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._maskRenderTexture), this.gl.clearColor(1, 1, 1, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT); for (let r = 0; r < this._clippingContextListForMask.length; r++) { const i = this._clippingContextListForMask[r], n = i._allClippedDrawRect, o = i._layoutBounds, s = .05; this._tmpBoundsOnModel.setRect(n), this._tmpBoundsOnModel.expand(n.width * s, n.height * s); const a = o.width / this._tmpBoundsOnModel.width, u = o.height / this._tmpBoundsOnModel.height; this._tmpMatrix.loadIdentity(), this._tmpMatrix.translateRelative(-1, -1), this._tmpMatrix.scaleRelative(2, 2), this._tmpMatrix.translateRelative(o.x, o.y), this._tmpMatrix.scaleRelative(a, u), this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y), this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray()), this._tmpMatrix.loadIdentity(), this._tmpMatrix.translateRelative(o.x, o.y), this._tmpMatrix.scaleRelative(a, u), this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y), this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray()), i._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray()), i._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray()); const h = i._clippingIdCount; for (let r = 0; r < h; r++) { const n = i._clippingIdList[r]; t.getDrawableDynamicFlagVertexPositionsDidChange(n) && (e.setIsCulling(0 != t.getDrawableCulling(n)), e.setClippingContextBufferForMask(i), e.drawMesh(t.getDrawableTextureIndices(n), t.getDrawableVertexIndexCount(n), t.getDrawableVertexCount(n), t.getDrawableVertexIndices(n), t.getDrawableVertices(n), t.getDrawableVertexUvs(n), t.getDrawableOpacity(n), E.CubismBlendMode_Normal, !1)) } } this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, Zt), e.setClippingContextBufferForMask(null), this.gl.viewport(Kt[0], Kt[1], Kt[2], Kt[3]) } } findSameClip(t, e) { for (let r = 0; r < this._clippingContextListForMask.length; r++) { const i = this._clippingContextListForMask[r], n = i._clippingIdCount; if (n != e) continue; let o = 0; for (let e = 0; e < n; e++) { const r = i._clippingIdList[e]; for (let e = 0; e < n; e++)if (t[e] == r) { o++; break } } if (o == n) return i } return null } setupLayoutBounds(t) { let e = t / Wt, r = t % Wt; e = ~~e, r = ~~r; let i = 0; for (let n = 0; n < Wt; n++) { const t = e + (n < r ? 1 : 0); if (0 == t); else if (1 == t) { const t = this._clippingContextListForMask[i++]; t._layoutChannelNo = n, t._layoutBounds.x = 0, t._layoutBounds.y = 0, t._layoutBounds.width = 1, t._layoutBounds.height = 1 } else if (2 == t) for (let e = 0; e < t; e++) { let t = e % 2; t = ~~t; const r = this._clippingContextListForMask[i++]; r._layoutChannelNo = n, r._layoutBounds.x = .5 * t, r._layoutBounds.y = 0, r._layoutBounds.width = .5, r._layoutBounds.height = 1 } else if (t <= 4) for (let e = 0; e < t; e++) { let t = e % 2, r = e / 2; t = ~~t, r = ~~r; const o = this._clippingContextListForMask[i++]; o._layoutChannelNo = n, o._layoutBounds.x = .5 * t, o._layoutBounds.y = .5 * r, o._layoutBounds.width = .5, o._layoutBounds.height = .5 } else if (t <= 9) for (let e = 0; e < t; e++) { let t = e % 3, r = e / 3; t = ~~t, r = ~~r; const o = this._clippingContextListForMask[i++]; o._layoutChannelNo = n, o._layoutBounds.x = t / 3, o._layoutBounds.y = r / 3, o._layoutBounds.width = 1 / 3, o._layoutBounds.height = 1 / 3 } else if (j.supportMoreMaskDivisions && t <= 16) for (let e = 0; e < t; e++) { let t = e % 4, r = e / 4; t = ~~t, r = ~~r; const o = this._clippingContextListForMask[i++]; o._layoutChannelNo = n, o._layoutBounds.x = t / 4, o._layoutBounds.y = r / 4, o._layoutBounds.width = 1 / 4, o._layoutBounds.height = 1 / 4 } else F("not supported mask count : {0}", t) } } getColorBuffer() { return this._colorBuffer } getClippingContextListForDraw() { return this._clippingContextListForDraw } setClippingMaskBufferSize(t) { this._clippingMaskBufferSize = t } getClippingMaskBufferSize() { return this._clippingMaskBufferSize } } class Qt { constructor(t, e) { this.frameNo = t, this.texture = e } } class te { constructor(t, e, r) { this._isUsing = !1, this._owner = t, this._clippingIdList = e, this._clippingIdCount = r, this._allClippedDrawRect = new Yt, this._layoutBounds = new Yt, this._clippedDrawableIndexList = [], this._matrixForMask = new x, this._matrixForDraw = new x } release() { const t = this; t._layoutBounds = void 0, t._allClippedDrawRect = void 0, t._clippedDrawableIndexList = void 0 } addClippedDrawable(t) { this._clippedDrawableIndexList.push(t) } getClippingManager() { return this._owner } setGl(t) { this._owner.setGL(t) } } class ee { static getInstance() { return null == qt ? (qt = new ee, qt) : qt } static deleteInstance() { qt && (qt.release(), qt = void 0) } constructor() { this._shaderSets = [] } release() { this.releaseShaderProgram() } setupShaderProgram(t, e, r, i, n, o, s, a, u, h, l, c, d) { let f, p, _, m; l || F("NoPremultipliedAlpha is not allowed"), 0 == this._shaderSets.length && this.generateShaders(); const g = t.getClippingContextBufferForMask(); if (null != g) { const t = this._shaderSets[re.ShaderNames_SetupMask]; this.gl.useProgram(t.shaderProgram), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, e), this.gl.uniform1i(t.samplerTexture0Location, 0), null == s.vertex && (s.vertex = this.gl.createBuffer()), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, s.vertex), this.gl.bufferData(this.gl.ARRAY_BUFFER, i, this.gl.DYNAMIC_DRAW), this.gl.enableVertexAttribArray(t.attributePositionLocation), this.gl.vertexAttribPointer(t.attributePositionLocation, 2, this.gl.FLOAT, !1, 0, 0), null == s.uv && (s.uv = this.gl.createBuffer()), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, s.uv), this.gl.bufferData(this.gl.ARRAY_BUFFER, o, this.gl.DYNAMIC_DRAW), this.gl.enableVertexAttribArray(t.attributeTexCoordLocation), this.gl.vertexAttribPointer(t.attributeTexCoordLocation, 2, this.gl.FLOAT, !1, 0, 0); const r = g._layoutChannelNo, n = g.getClippingManager().getChannelFlagAsColor(r); this.gl.uniform4f(t.uniformChannelFlagLocation, n.R, n.G, n.B, n.A), this.gl.uniformMatrix4fv(t.uniformClipMatrixLocation, !1, g._matrixForMask.getArray()); const a = g._layoutBounds; this.gl.uniform4f(t.uniformBaseColorLocation, 2 * a.x - 1, 2 * a.y - 1, 2 * a.getRight() - 1, 2 * a.getBottom() - 1), f = this.gl.ZERO, p = this.gl.ONE_MINUS_SRC_COLOR, _ = this.gl.ZERO, m = this.gl.ONE_MINUS_SRC_ALPHA } else { const r = t.getClippingContextBufferForDraw(), n = null != r, a = n ? d ? 2 : 1 : 0; let l; switch (u) { case E.CubismBlendMode_Normal: default: l = this._shaderSets[re.ShaderNames_NormalPremultipliedAlpha + a], f = this.gl.ONE, p = this.gl.ONE_MINUS_SRC_ALPHA, _ = this.gl.ONE, m = this.gl.ONE_MINUS_SRC_ALPHA; break; case E.CubismBlendMode_Additive: l = this._shaderSets[re.ShaderNames_AddPremultipliedAlpha + a], f = this.gl.ONE, p = this.gl.ONE, _ = this.gl.ZERO, m = this.gl.ONE; break; case E.CubismBlendMode_Multiplicative: l = this._shaderSets[re.ShaderNames_MultPremultipliedAlpha + a], f = this.gl.DST_COLOR, p = this.gl.ONE_MINUS_SRC_ALPHA, _ = this.gl.ZERO, m = this.gl.ONE; break }if (this.gl.useProgram(l.shaderProgram), null == s.vertex && (s.vertex = this.gl.createBuffer()), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, s.vertex), this.gl.bufferData(this.gl.ARRAY_BUFFER, i, this.gl.DYNAMIC_DRAW), this.gl.enableVertexAttribArray(l.attributePositionLocation), this.gl.vertexAttribPointer(l.attributePositionLocation, 2, this.gl.FLOAT, !1, 0, 0), null == s.uv && (s.uv = this.gl.createBuffer()), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, s.uv), this.gl.bufferData(this.gl.ARRAY_BUFFER, o, this.gl.DYNAMIC_DRAW), this.gl.enableVertexAttribArray(l.attributeTexCoordLocation), this.gl.vertexAttribPointer(l.attributeTexCoordLocation, 2, this.gl.FLOAT, !1, 0, 0), null != r) { this.gl.activeTexture(this.gl.TEXTURE1); const t = r.getClippingManager().getColorBuffer(); this.gl.bindTexture(this.gl.TEXTURE_2D, t), this.gl.uniform1i(l.samplerTexture1Location, 1), this.gl.uniformMatrix4fv(l.uniformClipMatrixLocation, !1, r._matrixForDraw.getArray()); const e = r._layoutChannelNo, i = r.getClippingManager().getChannelFlagAsColor(e); this.gl.uniform4f(l.uniformChannelFlagLocation, i.R, i.G, i.B, i.A) } this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, e), this.gl.uniform1i(l.samplerTexture0Location, 0), this.gl.uniformMatrix4fv(l.uniformMatrixLocation, !1, c.getArray()), this.gl.uniform4f(l.uniformBaseColorLocation, h.R, h.G, h.B, h.A) } null == s.index && (s.index = this.gl.createBuffer()), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, s.index), this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, n, this.gl.DYNAMIC_DRAW), this.gl.blendFuncSeparate(f, p, _, m) } releaseShaderProgram() { for (let t = 0; t < this._shaderSets.length; t++)this.gl.deleteProgram(this._shaderSets[t].shaderProgram), this._shaderSets[t].shaderProgram = 0; this._shaderSets = [] } generateShaders() { for (let t = 0; t < $t; t++)this._shaderSets.push({}); this._shaderSets[0].shaderProgram = this.loadShaderProgram(ie, ne), this._shaderSets[1].shaderProgram = this.loadShaderProgram(oe, ae), this._shaderSets[2].shaderProgram = this.loadShaderProgram(se, ue), this._shaderSets[3].shaderProgram = this.loadShaderProgram(se, he), this._shaderSets[4].shaderProgram = this._shaderSets[1].shaderProgram, this._shaderSets[5].shaderProgram = this._shaderSets[2].shaderProgram, this._shaderSets[6].shaderProgram = this._shaderSets[3].shaderProgram, this._shaderSets[7].shaderProgram = this._shaderSets[1].shaderProgram, this._shaderSets[8].shaderProgram = this._shaderSets[2].shaderProgram, this._shaderSets[9].shaderProgram = this._shaderSets[3].shaderProgram, this._shaderSets[0].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[0].shaderProgram, "a_position"), this._shaderSets[0].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[0].shaderProgram, "a_texCoord"), this._shaderSets[0].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, "s_texture0"), this._shaderSets[0].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, "u_clipMatrix"), this._shaderSets[0].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, "u_channelFlag"), this._shaderSets[0].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, "u_baseColor"), this._shaderSets[1].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[1].shaderProgram, "a_position"), this._shaderSets[1].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[1].shaderProgram, "a_texCoord"), this._shaderSets[1].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[1].shaderProgram, "s_texture0"), this._shaderSets[1].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[1].shaderProgram, "u_matrix"), this._shaderSets[1].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[1].shaderProgram, "u_baseColor"), this._shaderSets[2].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[2].shaderProgram, "a_position"), this._shaderSets[2].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[2].shaderProgram, "a_texCoord"), this._shaderSets[2].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, "s_texture0"), this._shaderSets[2].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, "s_texture1"), this._shaderSets[2].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, "u_matrix"), this._shaderSets[2].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, "u_clipMatrix"), this._shaderSets[2].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, "u_channelFlag"), this._shaderSets[2].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, "u_baseColor"), this._shaderSets[3].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[3].shaderProgram, "a_position"), this._shaderSets[3].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[3].shaderProgram, "a_texCoord"), this._shaderSets[3].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, "s_texture0"), this._shaderSets[3].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, "s_texture1"), this._shaderSets[3].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, "u_matrix"), this._shaderSets[3].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, "u_clipMatrix"), this._shaderSets[3].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, "u_channelFlag"), this._shaderSets[3].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, "u_baseColor"), this._shaderSets[4].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[4].shaderProgram, "a_position"), this._shaderSets[4].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[4].shaderProgram, "a_texCoord"), this._shaderSets[4].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[4].shaderProgram, "s_texture0"), this._shaderSets[4].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[4].shaderProgram, "u_matrix"), this._shaderSets[4].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[4].shaderProgram, "u_baseColor"), this._shaderSets[5].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[5].shaderProgram, "a_position"), this._shaderSets[5].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[5].shaderProgram, "a_texCoord"), this._shaderSets[5].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, "s_texture0"), this._shaderSets[5].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, "s_texture1"), this._shaderSets[5].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, "u_matrix"), this._shaderSets[5].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, "u_clipMatrix"), this._shaderSets[5].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, "u_channelFlag"), this._shaderSets[5].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, "u_baseColor"), this._shaderSets[6].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[6].shaderProgram, "a_position"), this._shaderSets[6].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[6].shaderProgram, "a_texCoord"), this._shaderSets[6].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, "s_texture0"), this._shaderSets[6].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, "s_texture1"), this._shaderSets[6].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, "u_matrix"), this._shaderSets[6].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, "u_clipMatrix"), this._shaderSets[6].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, "u_channelFlag"), this._shaderSets[6].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, "u_baseColor"), this._shaderSets[7].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[7].shaderProgram, "a_position"), this._shaderSets[7].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[7].shaderProgram, "a_texCoord"), this._shaderSets[7].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[7].shaderProgram, "s_texture0"), this._shaderSets[7].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[7].shaderProgram, "u_matrix"), this._shaderSets[7].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[7].shaderProgram, "u_baseColor"), this._shaderSets[8].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[8].shaderProgram, "a_position"), this._shaderSets[8].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[8].shaderProgram, "a_texCoord"), this._shaderSets[8].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, "s_texture0"), this._shaderSets[8].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, "s_texture1"), this._shaderSets[8].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, "u_matrix"), this._shaderSets[8].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, "u_clipMatrix"), this._shaderSets[8].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, "u_channelFlag"), this._shaderSets[8].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, "u_baseColor"), this._shaderSets[9].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[9].shaderProgram, "a_position"), this._shaderSets[9].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[9].shaderProgram, "a_texCoord"), this._shaderSets[9].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, "s_texture0"), this._shaderSets[9].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, "s_texture1"), this._shaderSets[9].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, "u_matrix"), this._shaderSets[9].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, "u_clipMatrix"), this._shaderSets[9].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, "u_channelFlag"), this._shaderSets[9].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, "u_baseColor") } loadShaderProgram(t, e) { let r = this.gl.createProgram(), i = this.compileShaderSource(this.gl.VERTEX_SHADER, t); if (!i) return F("Vertex shader compile error!"), 0; let n = this.compileShaderSource(this.gl.FRAGMENT_SHADER, e); if (!n) return F("Vertex shader compile error!"), 0; this.gl.attachShader(r, i), this.gl.attachShader(r, n), this.gl.linkProgram(r); const o = this.gl.getProgramParameter(r, this.gl.LINK_STATUS); return o ? (this.gl.deleteShader(i), this.gl.deleteShader(n), r) : (F("Failed to link program: {0}", r), this.gl.deleteShader(i), this.gl.deleteShader(n), r && this.gl.deleteProgram(r), 0) } compileShaderSource(t, e) { const r = e, i = this.gl.createShader(t); if (this.gl.shaderSource(i, r), this.gl.compileShader(i), !i) { const t = this.gl.getShaderInfoLog(i); F("Shader compile log: {0} ", t) } const n = this.gl.getShaderParameter(i, this.gl.COMPILE_STATUS); return n ? i : (this.gl.deleteShader(i), null) } setGl(t) { this.gl = t } } var re = (t => (t[t["ShaderNames_SetupMask"] = 0] = "ShaderNames_SetupMask", t[t["ShaderNames_NormalPremultipliedAlpha"] = 1] = "ShaderNames_NormalPremultipliedAlpha", t[t["ShaderNames_NormalMaskedPremultipliedAlpha"] = 2] = "ShaderNames_NormalMaskedPremultipliedAlpha", t[t["ShaderNames_NomralMaskedInvertedPremultipliedAlpha"] = 3] = "ShaderNames_NomralMaskedInvertedPremultipliedAlpha", t[t["ShaderNames_AddPremultipliedAlpha"] = 4] = "ShaderNames_AddPremultipliedAlpha", t[t["ShaderNames_AddMaskedPremultipliedAlpha"] = 5] = "ShaderNames_AddMaskedPremultipliedAlpha", t[t["ShaderNames_AddMaskedPremultipliedAlphaInverted"] = 6] = "ShaderNames_AddMaskedPremultipliedAlphaInverted", t[t["ShaderNames_MultPremultipliedAlpha"] = 7] = "ShaderNames_MultPremultipliedAlpha", t[t["ShaderNames_MultMaskedPremultipliedAlpha"] = 8] = "ShaderNames_MultMaskedPremultipliedAlpha", t[t["ShaderNames_MultMaskedPremultipliedAlphaInverted"] = 9] = "ShaderNames_MultMaskedPremultipliedAlphaInverted", t))(re || {}); const ie = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_myPos;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_clipMatrix * a_position;   v_myPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}", ne = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_myPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;void main(){   float isInside =        step(u_baseColor.x, v_myPos.x/v_myPos.w)       * step(u_baseColor.y, v_myPos.y/v_myPos.w)       * step(v_myPos.x/v_myPos.w, u_baseColor.z)       * step(v_myPos.y/v_myPos.w, u_baseColor.w);   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;}", oe = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;uniform mat4       u_matrix;void main(){   gl_Position = u_matrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}", se = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform mat4       u_matrix;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_matrix * a_position;   v_clipPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}", ae = "precision mediump float;varying vec2       v_texCoord;uniform vec4       u_baseColor;uniform sampler2D  s_texture0;void main(){   gl_FragColor = texture2D(s_texture0 , v_texCoord) * u_baseColor;}", ue = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;uniform sampler2D  s_texture1;void main(){   vec4 col_formask = texture2D(s_texture0 , v_texCoord) * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * maskVal;   gl_FragColor = col_formask;}", he = "precision mediump float;varying vec2 v_texCoord;varying vec4 v_clipPos;uniform sampler2D s_texture0;uniform sampler2D s_texture1;uniform vec4 u_channelFlag;uniform vec4 u_baseColor;void main(){vec4 col_formask = texture2D(s_texture0, v_texCoord) * u_baseColor;vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;col_formask = col_formask * (1.0 - maskVal);gl_FragColor = col_formask;}"; class le extends T { constructor() { super(), this._clippingContextBufferForMask = null, this._clippingContextBufferForDraw = null, this._clippingManager = new Jt, this.firstDraw = !0, this._textures = {}, this._sortedDrawableIndexList = [], this._bufferData = { vertex: null, uv: null, index: null } } initialize(t) { t.isUsingMasking() && (this._clippingManager = new Jt, this._clippingManager.initialize(t, t.getDrawableCount(), t.getDrawableMasks(), t.getDrawableMaskCounts())); for (let e = t.getDrawableCount() - 1; e >= 0; e--)this._sortedDrawableIndexList[e] = 0; super.initialize(t) } bindTexture(t, e) { this._textures[t] = e } getBindedTextures() { return this._textures } setClippingMaskBufferSize(t) { this._clippingManager.release(), this._clippingManager = new Jt, this._clippingManager.setClippingMaskBufferSize(t), this._clippingManager.initialize(this.getModel(), this.getModel().getDrawableCount(), this.getModel().getDrawableMasks(), this.getModel().getDrawableMaskCounts()) } getClippingMaskBufferSize() { return this._clippingManager.getClippingMaskBufferSize() } release() { var t, e, r; const i = this; this._clippingManager.release(), i._clippingManager = void 0, null == (t = this.gl) || t.deleteBuffer(this._bufferData.vertex), this._bufferData.vertex = null, null == (e = this.gl) || e.deleteBuffer(this._bufferData.uv), this._bufferData.uv = null, null == (r = this.gl) || r.deleteBuffer(this._bufferData.index), this._bufferData.index = null, i._bufferData = void 0, i._textures = void 0 } doDrawModel() { this.preDraw(), null != this._clippingManager && this._clippingManager.setupClippingContext(this.getModel(), this); const t = this.getModel().getDrawableCount(), e = this.getModel().getDrawableRenderOrders(); for (let r = 0; r < t; ++r) { const t = e[r]; this._sortedDrawableIndexList[t] = r } for (let r = 0; r < t; ++r) { const t = this._sortedDrawableIndexList[r]; this.getModel().getDrawableDynamicFlagIsVisible(t) && (this.setClippingContextBufferForDraw(null != this._clippingManager ? this._clippingManager.getClippingContextListForDraw()[t] : null), this.setIsCulling(this.getModel().getDrawableCulling(t)), this.drawMesh(this.getModel().getDrawableTextureIndices(t), this.getModel().getDrawableVertexIndexCount(t), this.getModel().getDrawableVertexCount(t), this.getModel().getDrawableVertexIndices(t), this.getModel().getDrawableVertices(t), this.getModel().getDrawableVertexUvs(t), this.getModel().getDrawableOpacity(t), this.getModel().getDrawableBlendMode(t), this.getModel().getDrawableInvertedMaskBit(t))) } } drawMesh(t, e, r, i, n, o, s, a, u) { this.isCulling() ? this.gl.enable(this.gl.CULL_FACE) : this.gl.disable(this.gl.CULL_FACE), this.gl.frontFace(this.gl.CCW); const h = this.getModelColor(); null == this.getClippingContextBufferForMask() && (h.A *= s, this.isPremultipliedAlpha() && (h.R *= h.A, h.G *= h.A, h.B *= h.A)); let l = null; null != this._textures[t] && (l = this._textures[t]), ee.getInstance().setupShaderProgram(this, l, r, n, i, o, this._bufferData, s, a, h, this.isPremultipliedAlpha(), this.getMvpMatrix(), u), this.gl.drawElements(this.gl.TRIANGLES, e, this.gl.UNSIGNED_SHORT, 0), this.gl.useProgram(null), this.setClippingContextBufferForDraw(null), this.setClippingContextBufferForMask(null) } static doStaticRelease() { ee.deleteInstance() } setRenderState(t, e) { Zt = t, Kt = e } preDraw() { this.firstDraw && (this.firstDraw = !1, this._anisortopy = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic")), this.gl.disable(this.gl.SCISSOR_TEST), this.gl.disable(this.gl.STENCIL_TEST), this.gl.disable(this.gl.DEPTH_TEST), this.gl.frontFace(this.gl.CW), this.gl.enable(this.gl.BLEND), this.gl.colorMask(!0, !0, !0, !0), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null) } setClippingContextBufferForMask(t) { this._clippingContextBufferForMask = t } getClippingContextBufferForMask() { return this._clippingContextBufferForMask } setClippingContextBufferForDraw(t) { this._clippingContextBufferForDraw = t } getClippingContextBufferForDraw() { return this._clippingContextBufferForDraw } startUp(t) { this.gl = t, this._clippingManager.setGL(t), ee.getInstance().setGl(t) } } T.staticRelease = () => { le.doStaticRelease() }; class ce { constructor(t) { this.groups = t.Groups, this.hitAreas = t.HitAreas, this.layout = t.Layout, this.moc = t.FileReferences.Moc, this.expressions = t.FileReferences.Expressions, this.motions = t.FileReferences.Motions, this.textures = t.FileReferences.Textures, this.physics = t.FileReferences.Physics, this.pose = t.FileReferences.Pose } getEyeBlinkParameters() { var t, e; return null == (e = null == (t = this.groups) ? void 0 : t.find((t => "EyeBlink" === t.Name))) ? void 0 : e.Ids } getLipSyncParameters() { var t, e; return null == (e = null == (t = this.groups) ? void 0 : t.find((t => "LipSync" === t.Name))) ? void 0 : e.Ids } } const de = "ParamAngleX", fe = "ParamAngleY", pe = "ParamAngleZ", _e = "ParamEyeBallX", me = "ParamEyeBallY", ge = "ParamBodyAngleX", ve = "ParamBreath", ye = 2, be = 2; var xe; (t => { t.LOG_LEVEL_VERBOSE = 0, t.LOG_LEVEL_WARNING = 1, t.LOG_LEVEL_ERROR = 2, t.LOG_LEVEL_NONE = 999, t.logLevel = t.LOG_LEVEL_WARNING, t.sound = !0, t.motionSync = !0, t.motionFadingDuration = 500, t.idleMotionFadingDuration = 2e3, t.expressionFadingDuration = 500, t.preserveExpressionOnMotion = !0, t.cubism4 = j })(xe || (xe = {})); const Te = { log(t, ...e) { xe.logLevel <= xe.LOG_LEVEL_VERBOSE && console.log(`[${t}]`, ...e) }, warn(t, ...e) { xe.logLevel <= xe.LOG_LEVEL_WARNING && console.warn(`[${t}]`, ...e) }, error(t, ...e) { xe.logLevel <= xe.LOG_LEVEL_ERROR && console.error(`[${t}]`, ...e) } }; function Ee(t, e, r) { return t < e ? e : t > r ? r : t } function Se(t, e) { e.forEach((e => { Object.getOwnPropertyNames(e.prototype).forEach((r => { "constructor" !== r && Object.defineProperty(t.prototype, r, Object.getOwnPropertyDescriptor(e.prototype, r)) })) })) } function we(t) { let e = t.lastIndexOf("/"); return -1 != e && (t = t.slice(0, e)), e = t.lastIndexOf("/"), -1 !== e && (t = t.slice(e + 1)), t } function Ae(t, e) { const r = t.indexOf(e); -1 !== r && t.splice(r, 1) } class Re extends i.EventEmitter { constructor(t, e) { super(), this.expressions = [], this.reserveExpressionIndex = -1, this.destroyed = !1, this.settings = t, this.tag = `ExpressionManager(${t.name})` } init() { this.defaultExpression = this.createExpression({}, void 0), this.currentExpression = this.defaultExpression, this.stopAllExpressions() } loadExpression(t) { return u(this, null, (function* () { if (!this.definitions[t]) return void Te.warn(this.tag, `Undefined expression at [${t}]`); if (null === this.expressions[t]) return void Te.warn(this.tag, `Cannot set expression at [${t}] because it's already failed in loading.`); if (this.expressions[t]) return this.expressions[t]; const e = yield this._loadExpression(t); return this.expressions[t] = e, e })) } _loadExpression(t) { throw new Error("Not implemented.") } setRandomExpression() { return u(this, null, (function* () { if (this.definitions.length) { const t = []; for (let e = 0; e < this.definitions.length; e++)null !== this.expressions[e] && this.expressions[e] !== this.currentExpression && e !== this.reserveExpressionIndex && t.push(e); if (t.length) { const e = Math.floor(Math.random() * t.length); return this.setExpression(e) } } return !1 })) } resetExpression() { this._setExpression(this.defaultExpression) } restoreExpression() { this._setExpression(this.currentExpression) } setExpression(t) { return u(this, null, (function* () { if ("number" !== typeof t && (t = this.getExpressionIndex(t)), !(t > -1 && t < this.definitions.length)) return !1; if (t === this.expressions.indexOf(this.currentExpression)) return !1; this.reserveExpressionIndex = t; const e = yield this.loadExpression(t); return !(!e || this.reserveExpressionIndex !== t) && (this.reserveExpressionIndex = -1, this.currentExpression = e, this._setExpression(e), !0) })) } update(t, e) { return !this.isFinished() && this.updateParameters(t, e) } destroy() { this.destroyed = !0, this.emit("destroy"); const t = this; t.definitions = void 0, t.expressions = void 0 } } const Oe = .01, Ie = 40 / 7.5, Pe = 1 / 150; class Me { constructor() { this.targetX = 0, this.targetY = 0, this.x = 0, this.y = 0, this.vx = 0, this.vy = 0 } focus(t, e, r = !1) { this.targetX = Ee(t, -1, 1), this.targetY = Ee(e, -1, 1), r && (this.x = this.targetX, this.y = this.targetY) } update(t) { const e = this.targetX - this.x, r = this.targetY - this.y; if (Math.abs(e) < Oe && Math.abs(r) < Oe) return; const i = Math.sqrt(a(e, 2) + a(r, 2)), n = Ie / (1e3 / t); let o = n * (e / i) - this.vx, s = n * (r / i) - this.vy; const u = Math.sqrt(a(o, 2) + a(s, 2)), h = n * Pe * t; u > h && (o *= h / u, s *= h / u), this.vx += o, this.vy += s; const l = Math.sqrt(a(this.vx, 2) + a(this.vy, 2)), c = .5 * (Math.sqrt(a(h, 2) + 8 * h * i) - h); l > c && (this.vx *= c / l, this.vy *= c / l), this.x += this.vx, this.y += this.vy } } class Ce { constructor(t) { this.json = t; let e = t.url; if ("string" !== typeof e) throw new TypeError("The `url` field in settings JSON must be defined as a string."); this.url = e, this.name = we(this.url) } resolveURL(t) { return i.url.resolve(this.url, t) } replaceFiles(t) { this.moc = t(this.moc, "moc"), void 0 !== this.pose && (this.pose = t(this.pose, "pose")), void 0 !== this.physics && (this.physics = t(this.physics, "physics")); for (let e = 0; e < this.textures.length; e++)this.textures[e] = t(this.textures[e], `textures[${e}]`) } getDefinedFiles() { const t = []; return this.replaceFiles((e => (t.push(e), e))), t } validateFiles(t) { const e = (e, r) => { const i = this.resolveURL(e); if (!t.includes(i)) { if (r) throw new Error(`File "${e}" is defined in settings, but doesn't exist in given files`); return !1 } return !0 }, r = [this.moc, ...this.textures]; r.forEach((t => e(t, !0))); const i = this.getDefinedFiles(); return i.filter((t => e(t, !1))) } } var De = (t => (t[t["NONE"] = 0] = "NONE", t[t["IDLE"] = 1] = "IDLE", t[t["NORMAL"] = 2] = "NORMAL", t[t["FORCE"] = 3] = "FORCE", t))(De || {}); class Le { constructor() { this.debug = !1, this.currentPriority = 0, this.reservePriority = 0 } reserve(t, e, r) { if (r <= 0) return Te.log(this.tag, "Cannot start a motion with MotionPriority.NONE."), !1; if (t === this.currentGroup && e === this.currentIndex) return Te.log(this.tag, "Motion is already playing.", this.dump(t, e)), !1; if (t === this.reservedGroup && e === this.reservedIndex || t === this.reservedIdleGroup && e === this.reservedIdleIndex) return Te.log(this.tag, "Motion is already reserved.", this.dump(t, e)), !1; if (1 === r) { if (0 !== this.currentPriority) return Te.log(this.tag, "Cannot start idle motion because another motion is playing.", this.dump(t, e)), !1; if (void 0 !== this.reservedIdleGroup) return Te.log(this.tag, "Cannot start idle motion because another idle motion has reserved.", this.dump(t, e)), !1; this.setReservedIdle(t, e) } else { if (r < 3) { if (r <= this.currentPriority) return Te.log(this.tag, "Cannot start motion because another motion is playing as an equivalent or higher priority.", this.dump(t, e)), !1; if (r <= this.reservePriority) return Te.log(this.tag, "Cannot start motion because another motion has reserved as an equivalent or higher priority.", this.dump(t, e)), !1 } this.setReserved(t, e, r) } return !0 } start(t, e, r, i) { if (1 === i) { if (this.setReservedIdle(void 0, void 0), 0 !== this.currentPriority) return Te.log(this.tag, "Cannot start idle motion because another motion is playing.", this.dump(e, r)), !1 } else { if (e !== this.reservedGroup || r !== this.reservedIndex) return Te.log(this.tag, "Cannot start motion because another motion has taken the place.", this.dump(e, r)), !1; this.setReserved(void 0, void 0, 0) } return !!t && (this.setCurrent(e, r, i), !0) } complete() { this.setCurrent(void 0, void 0, 0) } setCurrent(t, e, r) { this.currentPriority = r, this.currentGroup = t, this.currentIndex = e } setReserved(t, e, r) { this.reservePriority = r, this.reservedGroup = t, this.reservedIndex = e } setReservedIdle(t, e) { this.reservedIdleGroup = t, this.reservedIdleIndex = e } isActive(t, e) { return t === this.currentGroup && e === this.currentIndex || t === this.reservedGroup && e === this.reservedIndex || t === this.reservedIdleGroup && e === this.reservedIdleIndex } reset() { this.setCurrent(void 0, void 0, 0), this.setReserved(void 0, void 0, 0), this.setReservedIdle(void 0, void 0) } shouldRequestIdleMotion() { return void 0 === this.currentGroup && void 0 === this.reservedIdleGroup } shouldOverrideExpression() { return !xe.preserveExpressionOnMotion && this.currentPriority > 1 } dump(t, e) { if (this.debug) { const r = ["currentPriority", "reservePriority", "currentGroup", "currentIndex", "reservedGroup", "reservedIndex", "reservedIdleGroup", "reservedIdleIndex"]; return `\n<Requested> group = "${t}", index = ${e}\n` + r.map((t => "[" + t + "] " + this[t])).join("\n") } return "" } } const Fe = "SoundManager", Ne = .5; class Be { static get volume() { return this._volume } static set volume(t) { this._volume = (t > 1 ? 1 : t < 0 ? 0 : t) || 0, this.audios.forEach((t => t.volume = this._volume)) } static add(t, e, r) { const i = new Audio(t); return i.volume = this._volume, i.preload = "auto", i.addEventListener("ended", (() => { this.dispose(i), null == e || e() })), i.addEventListener("error", (e => { this.dispose(i), Te.warn(Fe, `Error occurred on "${t}"`, e.error), null == r || r(e.error) })), this.audios.push(i), i } static play(t) { return new Promise(((e, r) => { var i; null == (i = t.play()) || i.catch((e => { t.dispatchEvent(new ErrorEvent("error", { error: e })), r(e) })), t.readyState === t.HAVE_ENOUGH_DATA ? e() : t.addEventListener("canplaythrough", e) })) } static dispose(t) { t.pause(), t.removeAttribute("src"), Ae(this.audios, t) } static destroy() { for (let t = this.audios.length - 1; t >= 0; t--)this.dispose(this.audios[t]) } } Be.audios = [], Be._volume = Ne; class Ue extends i.EventEmitter { constructor(t, e) { super(), this.motionGroups = {}, this.state = new Le, this.playing = !1, this.destroyed = !1, this.settings = t, this.tag = `MotionManager(${t.name})`, this.state.tag = this.tag } init(t) { (null == t ? void 0 : t.idleMotionGroup) && (this.groups.idle = t.idleMotionGroup), this.setupMotions(t), this.stopAllMotions() } setupMotions(t) { for (const r of Object.keys(this.definitions)) this.motionGroups[r] = []; let e; switch (null == t ? void 0 : t.motionPreload) { case "NONE": return; case "ALL": e = Object.keys(this.definitions); break; case "IDLE": default: e = [this.groups.idle]; break }for (const r of e) if (this.definitions[r]) for (let t = 0; t < this.definitions[r].length; t++)this.loadMotion(r, t).then() } loadMotion(t, e) { return u(this, null, (function* () { var r; if (!(null == (r = this.definitions[t]) ? void 0 : r[e])) return void Te.warn(this.tag, `Undefined motion at "${t}"[${e}]`); if (null === this.motionGroups[t][e]) return void Te.warn(this.tag, `Cannot start motion at "${t}"[${e}] because it's already failed in loading.`); if (this.motionGroups[t][e]) return this.motionGroups[t][e]; const i = yield this._loadMotion(t, e); return this.destroyed ? void 0 : (this.motionGroups[t][e] = null != i ? i : null, i) })) } _loadMotion(t, e) { throw new Error("Not implemented.") } startMotion(t, e) { return u(this, arguments, (function* (t, e, r = De.NORMAL) { var i; if (!this.state.reserve(t, e, r)) return !1; const n = null == (i = this.definitions[t]) ? void 0 : i[e]; if (!n) return !1; let o; if (this.currentAudio && Be.dispose(this.currentAudio), xe.sound) { const t = this.getSoundFile(n); if (t) try { o = Be.add(this.settings.resolveURL(t), (() => this.currentAudio = void 0), (() => this.currentAudio = void 0)), this.currentAudio = o } catch (a) { Te.warn(this.tag, "Failed to create audio", t, a) } } const s = yield this.loadMotion(t, e); if (o) { const t = Be.play(o).catch((t => Te.warn(this.tag, "Failed to play audio", o.src, t))); xe.motionSync && (yield t) } return this.state.start(s, t, e, r) ? (Te.log(this.tag, "Start motion:", this.getMotionName(n)), this.emit("motionStart", t, e, o), this.state.shouldOverrideExpression() && this.expressionManager && this.expressionManager.resetExpression(), this.playing = !0, this._startMotion(s), !0) : (o && (Be.dispose(o), this.currentAudio = void 0), !1) })) } startRandomMotion(t, e) { return u(this, null, (function* () { const r = this.definitions[t]; if (null == r ? void 0 : r.length) { const i = []; for (let e = 0; e < r.length; e++)null === this.motionGroups[t][e] || this.state.isActive(t, e) || i.push(e); if (i.length) { const r = Math.floor(Math.random() * i.length); return this.startMotion(t, i[r], e) } } return !1 })) } stopAllMotions() { this._stopAllMotions(), this.state.reset(), this.currentAudio && (Be.dispose(this.currentAudio), this.currentAudio = void 0) } update(t, e) { var r; return this.isFinished() && (this.playing && (this.playing = !1, this.emit("motionFinish")), this.state.shouldOverrideExpression() && (null == (r = this.expressionManager) || r.restoreExpression()), this.state.complete(), this.state.shouldRequestIdleMotion() && this.startRandomMotion(this.groups.idle, De.IDLE)), this.updateParameters(t, e) } destroy() { var t; this.destroyed = !0, this.emit("destroy"), this.stopAllMotions(), null == (t = this.expressionManager) || t.destroy(); const e = this; e.definitions = void 0, e.motionGroups = void 0 } } const ke = { x: 0, y: 0, width: 0, height: 0 }; class Ge extends i.EventEmitter { constructor() { super(...arguments), this.focusController = new Me, this.originalWidth = 0, this.originalHeight = 0, this.width = 0, this.height = 0, this.localTransform = new n.y3, this.drawingMatrix = new n.y3, this.hitAreas = {}, this.textureFlipY = !1, this.viewport = [0, 0, 0, 0], this.destroyed = !1 } init() { this.setupLayout(), this.setupHitAreas() } setupLayout() { const t = this, e = this.getSize(); t.originalWidth = e[0], t.originalHeight = e[1]; const r = Object.assign({ width: ye, height: be }, this.getLayout()); this.localTransform.scale(r.width / ye, r.height / be), t.width = this.originalWidth * this.localTransform.a, t.height = this.originalHeight * this.localTransform.d; const i = void 0 !== r.x && r.x - r.width / 2 || void 0 !== r.centerX && r.centerX || void 0 !== r.left && r.left - r.width / 2 || void 0 !== r.right && r.right + r.width / 2 || 0, n = void 0 !== r.y && r.y - r.height / 2 || void 0 !== r.centerY && r.centerY || void 0 !== r.top && r.top - r.height / 2 || void 0 !== r.bottom && r.bottom + r.height / 2 || 0; this.localTransform.translate(this.width * i, -this.height * n) } setupHitAreas() { const t = this.getHitAreaDefs().filter((t => t.index >= 0)); for (const e of t) this.hitAreas[e.name] = e } hitTest(t, e) { return Object.keys(this.hitAreas).filter((r => this.isHit(r, t, e))) } isHit(t, e, r) { if (!this.hitAreas[t]) return !1; const i = this.hitAreas[t].index, n = this.getDrawableBounds(i, ke); return n.x <= e && e <= n.x + n.width && n.y <= r && r <= n.y + n.height } getDrawableBounds(t, e) { const r = this.getDrawableVertices(t); let i = r[0], n = r[0], o = r[1], s = r[1]; for (let a = 0; a < r.length; a += 2) { const t = r[a], e = r[a + 1]; i = Math.min(t, i), n = Math.max(t, n), o = Math.min(e, o), s = Math.max(e, s) } return null != e || (e = {}), e.x = i, e.y = o, e.width = n - i, e.height = s - o, e } updateTransform(t) { this.drawingMatrix.copyFrom(t).append(this.localTransform) } update(t, e) { this.focusController.update(t) } destroy() { this.destroyed = !0, this.emit("destroy"), this.motionManager.destroy(), this.motionManager = void 0 } } const Xe = "XHRLoader"; class je extends Error { constructor(t, e, r, i = !1) { super(t), this.url = e, this.status = r, this.aborted = i } } const He = class { static createXHR(t, e, r, i, n) { const o = new XMLHttpRequest; if (He.allXhrSet.add(o), t) { let e = He.xhrMap.get(t); e ? e.add(o) : (e = new Set([o]), He.xhrMap.set(t, e)), t.listeners("destroy").includes(He.cancelXHRs) || t.once("destroy", He.cancelXHRs) } return o.open("GET", e), o.responseType = r, o.onload = () => { 200 !== o.status && 0 !== o.status || !o.response ? o.onerror() : i(o.response) }, o.onerror = () => { Te.warn(Xe, `Failed to load resource as ${o.responseType} (Status ${o.status}): ${e}`), n(new je("Network error.", e, o.status)) }, o.onabort = () => n(new je("Aborted.", e, o.status, !0)), o.onloadend = () => { var e; He.allXhrSet.delete(o), t && (null == (e = He.xhrMap.get(t)) || e.delete(o)) }, o } static cancelXHRs() { var t; null == (t = He.xhrMap.get(this)) || t.forEach((t => { t.abort(), He.allXhrSet.delete(t) })), He.xhrMap.delete(this) } static release() { He.allXhrSet.forEach((t => t.abort())), He.allXhrSet.clear(), He.xhrMap = new WeakMap } }; let Ve = He; function ze(t, e) { let r = -1; return i(0); function i(n, o) { if (o) return Promise.reject(o); if (n <= r) return Promise.reject(new Error("next() called multiple times")); r = n; const s = t[n]; if (!s) return Promise.resolve(); try { return Promise.resolve(s(e, i.bind(null, n + 1))) } catch (a) { return Promise.reject(a) } } } Ve.xhrMap = new WeakMap, Ve.allXhrSet = new Set, Ve.loader = (t, e) => new Promise(((e, r) => { const i = He.createXHR(t.target, t.settings ? t.settings.resolveURL(t.url) : t.url, t.type, (r => { t.result = r, e() }), r); i.send() })); class Ye { static load(t) { return ze(this.middlewares, t).then((() => t.result)) } } function We(t, e = {}) { const r = { resourceOptions: { crossorigin: e.crossOrigin } }; if (o.xE.fromURL) return o.xE.fromURL(t, r).catch((t => { if (t instanceof Error) throw t; const e = new Error("Texture loading error"); throw e.event = t, e })); r.resourceOptions.autoLoad = !1; const i = o.xE.from(t, r); if (i.baseTexture.valid) return Promise.resolve(i); const n = i.baseTexture.resource; return null != n._live2d_load || (n._live2d_load = new Promise(((t, e) => { const r = t => { n.source.removeEventListener("error", r); const i = new Error("Texture loading error"); i.event = t, e(i) }; n.source.addEventListener("error", r), n.load().then((() => t(i))).catch(r) }))), n._live2d_load } Ye.middlewares = [Ve.loader]; const $e = "Live2DFactory", qe = (t, e) => u(void 0, null, (function* () { if ("string" === typeof t.source) { const e = yield Ye.load({ url: t.source, type: "json", target: t.live2dModel }); e.url = t.source, t.source = e, t.live2dModel.emit("settingsJSONLoaded", e) } return e() })), Ke = (t, e) => u(void 0, null, (function* () { if (t.source instanceof Ce) return t.settings = t.source, e(); if ("object" === typeof t.source) { const r = rr.findRuntime(t.source); if (r) { const i = r.createModelSettings(t.source); return t.settings = i, t.live2dModel.emit("settingsLoaded", i), e() } } throw new TypeError("Unknown settings format.") })), Ze = (t, e) => { if (t.settings) { const r = rr.findRuntime(t.settings); if (r) return r.ready().then(e) } return e() }, Je = (t, e) => u(void 0, null, (function* () { yield e(); const r = t.internalModel; if (r) { const e = t.settings, i = rr.findRuntime(e); if (i) { const n = []; e.pose && n.push(Ye.load({ settings: e, url: e.pose, type: "json", target: r }).then((e => { r.pose = i.createPose(r.coreModel, e), t.live2dModel.emit("poseLoaded", r.pose) })).catch((e => { t.live2dModel.emit("poseLoadError", e), Te.warn($e, "Failed to load pose.", e) }))), e.physics && n.push(Ye.load({ settings: e, url: e.physics, type: "json", target: r }).then((e => { r.physics = i.createPhysics(r.coreModel, e), t.live2dModel.emit("physicsLoaded", r.physics) })).catch((e => { t.live2dModel.emit("physicsLoadError", e), Te.warn($e, "Failed to load physics.", e) }))), n.length && (yield Promise.all(n)) } } })), Qe = (t, e) => u(void 0, null, (function* () { if (!t.settings) throw new TypeError("Missing settings."); { const r = t.live2dModel, i = t.settings.textures.map((e => { const r = t.settings.resolveURL(e); return We(r, { crossOrigin: t.options.crossOrigin }) })); if (yield e(), !t.internalModel) throw new TypeError("Missing internal model."); r.internalModel = t.internalModel, r.emit("modelLoaded", t.internalModel), r.textures = yield Promise.all(i), r.emit("textureLoaded", r.textures) } })), tr = (t, e) => u(void 0, null, (function* () { const r = t.settings; if (r instanceof Ce) { const i = rr.findRuntime(r); if (!i) throw new TypeError("Unknown model settings."); const n = yield Ye.load({ settings: r, url: r.moc, type: "arraybuffer", target: t.live2dModel }); if (!i.isValidMoc(n)) throw new Error("Invalid moc data"); const o = i.createCoreModel(n); return t.internalModel = i.createInternalModel(o, r, t.options), e() } throw new TypeError("Missing settings.") })), er = class { static registerRuntime(t) { er.runtimes.push(t), er.runtimes.sort(((t, e) => e.version - t.version)) } static findRuntime(t) { for (const e of er.runtimes) if (e.test(t)) return e } static setupLive2DModel(t, e, r) { return u(this, null, (function* () { const i = new Promise((e => t.once("textureLoaded", e))), n = new Promise((e => t.once("modelLoaded", e))), o = Promise.all([i, n]).then((() => t.emit("ready"))); yield ze(er.live2DModelMiddlewares, { live2dModel: t, source: e, options: r || {} }), yield o, t.emit("load") })) } static loadMotion(t, e, r) { var i; const n = i => t.emit("motionLoadError", e, r, i); try { const o = null == (i = t.definitions[e]) ? void 0 : i[r]; if (!o) return Promise.resolve(void 0); t.listeners("destroy").includes(er.releaseTasks) || t.once("destroy", er.releaseTasks); let s = er.motionTasksMap.get(t); s || (s = {}, er.motionTasksMap.set(t, s)); let a = s[e]; a || (a = [], s[e] = a); const u = t.getMotionFile(o); return null != a[r] || (a[r] = Ye.load({ url: u, settings: t.settings, type: t.motionDataType, target: t }).then((i => { var n; const s = null == (n = er.motionTasksMap.get(t)) ? void 0 : n[e]; s && delete s[r]; const a = t.createMotion(i, e, o); return t.emit("motionLoaded", e, r, a), a })).catch((e => { Te.warn(t.tag, `Failed to load motion: ${u}\n`, e), n(e) }))), a[r] } catch (o) { Te.warn(t.tag, `Failed to load motion at "${e}"[${r}]\n`, o), n(o) } return Promise.resolve(void 0) } static loadExpression(t, e) { const r = r => t.emit("expressionLoadError", e, r); try { const i = t.definitions[e]; if (!i) return Promise.resolve(void 0); t.listeners("destroy").includes(er.releaseTasks) || t.once("destroy", er.releaseTasks); let n = er.expressionTasksMap.get(t); n || (n = [], er.expressionTasksMap.set(t, n)); const o = t.getExpressionFile(i); return null != n[e] || (n[e] = Ye.load({ url: o, settings: t.settings, type: "json", target: t }).then((r => { const n = er.expressionTasksMap.get(t); n && delete n[e]; const o = t.createExpression(r, i); return t.emit("expressionLoaded", e, o), o })).catch((e => { Te.warn(t.tag, `Failed to load expression: ${o}\n`, e), r(e) }))), n[e] } catch (i) { Te.warn(t.tag, `Failed to load expression at [${e}]\n`, i), r(i) } return Promise.resolve(void 0) } static releaseTasks() { this instanceof Ue ? er.motionTasksMap.delete(this) : er.expressionTasksMap.delete(this) } }; let rr = er; rr.runtimes = [], rr.urlToJSON = qe, rr.jsonToSettings = Ke, rr.waitUntilReady = Ze, rr.setupOptionals = Je, rr.setupEssentials = Qe, rr.createInternalModel = tr, rr.live2DModelMiddlewares = [qe, Ke, Ze, Je, Qe, tr], rr.motionTasksMap = new WeakMap, rr.expressionTasksMap = new WeakMap, Ue.prototype["_loadMotion"] = function (t, e) { return rr.loadMotion(this, t, e) }, Re.prototype["_loadExpression"] = function (t) { return rr.loadExpression(this, t) }; class ir { constructor() { this._autoInteract = !1 } get autoInteract() { return this._autoInteract } set autoInteract(t) { t !== this._autoInteract && (t ? this.on("pointertap", nr, this) : this.off("pointertap", nr, this), this._autoInteract = t) } registerInteraction(t) { t !== this.interactionManager && (this.unregisterInteraction(), this._autoInteract && t && (this.interactionManager = t, t.on("pointermove", or, this))) } unregisterInteraction() { var t; this.interactionManager && (null == (t = this.interactionManager) || t.off("pointermove", or, this), this.interactionManager = void 0) } } function nr(t) { this.tap(t.data.global.x, t.data.global.y) } function or(t) { this.focus(t.data.global.x, t.data.global.y) } class sr extends n.wx { } const ar = new n.E9, ur = new n.y3; let hr; class lr extends s.W2 { constructor(t) { super(), this.tag = "Live2DModel(uninitialized)", this.textures = [], this.transform = new sr, this.anchor = new n.AB(this.onAnchorChange, this, 0, 0), this.glContextID = -1, this.elapsedTime = performance.now(), this.deltaTime = 0, this._autoUpdate = !1, this.once("modelLoaded", (() => this.init(t))) } static from(t, e) { const r = new this(e); return rr.setupLive2DModel(r, t, e).then((() => r)) } static fromSync(t, e) { const r = new this(e); return rr.setupLive2DModel(r, t, e).then(null == e ? void 0 : e.onLoad).catch(null == e ? void 0 : e.onError), r } static registerTicker(t) { hr = t } get autoUpdate() { return this._autoUpdate } set autoUpdate(t) { var e; hr || (hr = null == (e = window.PIXI) ? void 0 : e.Ticker), t ? this._destroyed || (hr ? (hr.shared.add(this.onTickerUpdate, this), this._autoUpdate = !0) : Te.warn(this.tag, "No Ticker registered, please call Live2DModel.registerTicker(Ticker).")) : (null == hr || hr.shared.remove(this.onTickerUpdate, this), this._autoUpdate = !1) } init(t) { this.tag = `Live2DModel(${this.internalModel.settings.name})`; const e = Object.assign({ autoUpdate: !0, autoInteract: !0 }, t); e.autoInteract && (this.interactive = !0), this.autoInteract = e.autoInteract, this.autoUpdate = e.autoUpdate } onAnchorChange() { this.pivot.set(this.anchor.x * this.internalModel.width, this.anchor.y * this.internalModel.height) } motion(t, e, r) { return void 0 === e ? this.internalModel.motionManager.startRandomMotion(t, r) : this.internalModel.motionManager.startMotion(t, e, r) } expression(t) { return this.internalModel.motionManager.expressionManager ? void 0 === t ? this.internalModel.motionManager.expressionManager.setRandomExpression() : this.internalModel.motionManager.expressionManager.setExpression(t) : Promise.resolve(!1) } focus(t, e, r = !1) { ar.x = t, ar.y = e, this.toModelPosition(ar, ar, !0); let i = ar.x / this.internalModel.originalWidth * 2 - 1, n = ar.y / this.internalModel.originalHeight * 2 - 1, o = Math.atan2(n, i); this.internalModel.focusController.focus(Math.cos(o), -Math.sin(o), r) } tap(t, e) { const r = this.hitTest(t, e); r.length && (Te.log(this.tag, "Hit", r), this.emit("hit", r)) } hitTest(t, e) { return ar.x = t, ar.y = e, this.toModelPosition(ar, ar), this.internalModel.hitTest(ar.x, ar.y) } toModelPosition(t, e = t.clone(), r) { return r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.transform.worldTransform.applyInverse(t, e), this.internalModel.localTransform.applyInverse(e, e), e } containsPoint(t) { return this.getBounds(!0).contains(t.x, t.y) } _calculateBounds() { this._bounds.addFrame(this.transform, 0, 0, this.internalModel.width, this.internalModel.height) } onTickerUpdate() { this.update(hr.shared.deltaMS) } update(t) { this.deltaTime += t, this.elapsedTime += t } _render(t) { this.registerInteraction(t.plugins.interaction), t.batch.reset(), t.geometry.reset(), t.shader.reset(), t.state.reset(); let e = !1; this.glContextID !== t.CONTEXT_UID && (this.glContextID = t.CONTEXT_UID, this.internalModel.updateWebGLContext(t.gl, this.glContextID), e = !0); for (let n = 0; n < this.textures.length; n++) { const r = this.textures[n]; r.valid && (!e && r.baseTexture._glTextures[this.glContextID] || (t.gl.pixelStorei(WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL, this.internalModel.textureFlipY), t.texture.bind(r.baseTexture, 0)), this.internalModel.bindTexture(n, r.baseTexture._glTextures[this.glContextID].texture), r.baseTexture.touched = t.textureGC.count) } const r = t.framebuffer.viewport; this.internalModel.viewport = [r.x, r.y, r.width, r.height], this.deltaTime && (this.internalModel.update(this.deltaTime, this.elapsedTime), this.deltaTime = 0); const i = ur.copyFrom(t.globalUniforms.uniforms.projectionMatrix).append(this.worldTransform); this.internalModel.updateTransform(i), this.internalModel.draw(t.gl), t.state.reset(), t.texture.reset() } destroy(t) { this.emit("destroy"), this.autoUpdate = !1, this.unregisterInteraction(), (null == t ? void 0 : t.texture) && this.textures.forEach((e => e.destroy(t.baseTexture))), this.internalModel.destroy(), super.destroy(t) } } Se(lr, [ir]); const cr = class { static resolveURL(t, e) { var r; const i = null == (r = cr.filesMap[t]) ? void 0 : r[e]; if (void 0 === i) throw new Error("Cannot find this file from uploaded files: " + e); return i } static upload(t, e) { return u(this, null, (function* () { const r = {}; for (const n of e.getDefinedFiles()) { const o = decodeURI(i.url.resolve(e.url, n)), s = t.find((t => t.webkitRelativePath === o)); s && (r[n] = URL.createObjectURL(s)) } cr.filesMap[e._objectURL] = r })) } static createSettings(t) { return u(this, null, (function* () { const e = t.find((t => t.name.endsWith("model.json") || t.name.endsWith("model3.json"))); if (!e) throw new TypeError("Settings file not found"); const r = yield cr.readText(e), i = JSON.parse(r); i.url = e.webkitRelativePath; const n = rr.findRuntime(i); if (!n) throw new Error("Unknown settings JSON"); const o = n.createModelSettings(i); return o._objectURL = URL.createObjectURL(e), o })) } static readText(t) { return u(this, null, (function* () { return new Promise(((e, r) => { const i = new FileReader; i.onload = () => e(i.result), i.onerror = r, i.readAsText(t, "utf8") })) })) } }; let dr = cr; dr.filesMap = {}, dr.factory = (t, e) => u(void 0, null, (function* () { if (Array.isArray(t.source) && t.source[0] instanceof File) { const e = t.source; let r = e.settings; if (r) { if (!r._objectURL) throw new Error('"_objectURL" must be specified in ModelSettings') } else r = yield cr.createSettings(e); r.validateFiles(e.map((t => encodeURI(t.webkitRelativePath)))), yield cr.upload(e, r), r.resolveURL = function (t) { return cr.resolveURL(this._objectURL, t) }, t.source = r, t.live2dModel.once("modelLoaded", (t => { t.once("destroy", (function () { const t = this.settings._objectURL; if (URL.revokeObjectURL(t), cr.filesMap[t]) for (const e of Object.values(cr.filesMap[t])) URL.revokeObjectURL(e); delete cr.filesMap[t] })) })) } return e() })), rr.live2DModelMiddlewares.unshift(dr.factory); const fr = class { static unzip(t, e) { return u(this, null, (function* () { const r = yield fr.getFilePaths(t), n = []; for (const t of e.getDefinedFiles()) { const o = decodeURI(i.url.resolve(e.url, t)); r.includes(o) && n.push(o) } const o = yield fr.getFiles(t, n); for (let t = 0; t < o.length; t++) { const e = n[t], r = o[t]; Object.defineProperty(r, "webkitRelativePath", { value: e }) } return o })) } static createSettings(t) { return u(this, null, (function* () { const e = yield fr.getFilePaths(t), r = e.find((t => t.endsWith("model.json") || t.endsWith("model3.json"))); if (!r) throw new Error("Settings file not found"); const i = yield fr.readText(t, r); if (!i) throw new Error("Empty settings file: " + r); const n = JSON.parse(i); n.url = r; const o = rr.findRuntime(n); if (!o) throw new Error("Unknown settings JSON"); return o.createModelSettings(n) })) } static zipReader(t, e) { return u(this, null, (function* () { throw new Error("Not implemented") })) } static getFilePaths(t) { return u(this, null, (function* () { throw new Error("Not implemented") })) } static getFiles(t, e) { return u(this, null, (function* () { throw new Error("Not implemented") })) } static readText(t, e) { return u(this, null, (function* () { throw new Error("Not implemented") })) } static releaseReader(t) { } }; let pr = fr; if (pr.ZIP_PROTOCOL = "zip://", pr.uid = 0, pr.factory = (t, e) => u(void 0, null, (function* () { const r = t.source; let i, n, o; if ("string" === typeof r && (r.endsWith(".zip") || r.startsWith(fr.ZIP_PROTOCOL)) ? (i = r.startsWith(fr.ZIP_PROTOCOL) ? r.slice(fr.ZIP_PROTOCOL.length) : r, n = yield Ye.load({ url: i, type: "blob", target: t.live2dModel })) : Array.isArray(r) && 1 === r.length && r[0] instanceof File && r[0].name.endsWith(".zip") && (n = r[0], i = URL.createObjectURL(n), o = r.settings), n) { if (!n.size) throw new Error("Empty zip file"); const e = yield fr.zipReader(n, i); o || (o = yield fr.createSettings(e)), o._objectURL = fr.ZIP_PROTOCOL + fr.uid + "/" + o.url; const r = yield fr.unzip(e, o); r.settings = o, t.source = r, i.startsWith("blob:") && t.live2dModel.once("modelLoaded", (t => { t.once("destroy", (function () { URL.revokeObjectURL(i) })) })), fr.releaseReader(e) } return e() })), rr.live2DModelMiddlewares.unshift(pr.factory), !window.Live2DCubismCore) throw new Error("Could not find Cubism 4 runtime. This plugin requires live2dcubismcore.js to be loaded."); class _r extends Re { constructor(t, e) { var r; super(t, e), this.queueManager = new pt, this.definitions = null != (r = t.expressions) ? r : [], this.init() } isFinished() { return this.queueManager.isFinished() } getExpressionIndex(t) { return this.definitions.findIndex((e => e.Name === t)) } getExpressionFile(t) { return t.File } createExpression(t, e) { return X.create(t) } _setExpression(t) { return this.queueManager.startMotion(t, !1, performance.now()) } stopAllExpressions() { this.queueManager.stopAllMotions() } updateParameters(t, e) { return this.queueManager.doUpdateMotion(t, e) } } class mr extends Ce { constructor(t) { if (super(t), !mr.isValidJSON(t)) throw new TypeError("Invalid JSON."); Object.assign(this, new ce(t)) } static isValidJSON(t) { var e; return !!(null == t ? void 0 : t.FileReferences) && "string" === typeof t.FileReferences.Moc && (null == (e = t.FileReferences.Textures) ? void 0 : e.length) > 0 && t.FileReferences.Textures.every((t => "string" === typeof t)) } replaceFiles(t) { if (super.replaceFiles(t), this.motions) for (const [e, r] of Object.entries(this.motions)) for (let i = 0; i < r.length; i++)r[i].File = t(r[i].File, `motions.${e}[${i}].File`), void 0 !== r[i].Sound && (r[i].Sound = t(r[i].Sound, `motions.${e}[${i}].Sound`)); if (this.expressions) for (let e = 0; e < this.expressions.length; e++)this.expressions[e].File = t(this.expressions[e].File, `expressions[${e}].File`) } } Se(mr, [ce]); class gr extends Ue { constructor(t, e) { var r; super(t, e), this.groups = { idle: "Idle" }, this.motionDataType = "json", this.queueManager = new pt, this.definitions = null != (r = t.motions) ? r : {}, this.eyeBlinkIds = t.getEyeBlinkParameters() || [], this.lipSyncIds = t.getLipSyncParameters() || [], this.init(e) } init(t) { super.init(t), this.settings.expressions && (this.expressionManager = new _r(this.settings, t)), this.queueManager.setEventCallback(((t, e, r) => { this.emit("motion:" + e) })) } isFinished() { return this.queueManager.isFinished() } _startMotion(t, e) { return t.setFinishedMotionHandler(e), this.queueManager.stopAllMotions(), this.queueManager.startMotion(t, !1, performance.now()) } _stopAllMotions() { this.queueManager.stopAllMotions() } createMotion(t, e, r) { const i = dt.create(t), n = new Z(t), o = (e === this.groups.idle ? xe.idleMotionFadingDuration : xe.motionFadingDuration) / 1e3; return void 0 === n.getMotionFadeInTime() && i.setFadeInTime(r.FadeInTime > 0 ? r.FadeInTime : o), void 0 === n.getMotionFadeOutTime() && i.setFadeOutTime(r.FadeOutTime > 0 ? r.FadeOutTime : o), i.setEffectIds(this.eyeBlinkIds, this.lipSyncIds), i } getMotionFile(t) { return t.File } getMotionName(t) { return t.File } getSoundFile(t) { return t.Sound } updateParameters(t, e) { return this.queueManager.doUpdateMotion(t, e) } destroy() { super.destroy(), this.queueManager.release(), this.queueManager = void 0 } } const vr = new x; class yr extends Ge { constructor(t, e, r) { super(), this.lipSync = !0, this.breath = h.create(), this.renderer = new le, this.idParamAngleX = de, this.idParamAngleY = fe, this.idParamAngleZ = pe, this.idParamEyeBallX = _e, this.idParamEyeBallY = me, this.idParamBodyAngleX = ge, this.idParamBreath = ve, this.pixelsPerUnit = 1, this.centeringTransform = new n.y3, this.coreModel = t, this.settings = e, this.motionManager = new gr(e, r), this.init() } init() { var t; super.init(), (null == (t = this.settings.getEyeBlinkParameters()) ? void 0 : t.length) > 0 && (this.eyeBlink = d.create(this.settings)), this.breath.setParameters([new l(this.idParamAngleX, 0, 15, 6.5345, .5), new l(this.idParamAngleY, 0, 8, 3.5345, .5), new l(this.idParamAngleZ, 0, 10, 5.5345, .5), new l(this.idParamBodyAngleX, 0, 4, 15.5345, .5), new l(this.idParamBreath, 0, .5, 3.2345, .5)]), this.renderer.initialize(this.coreModel), this.renderer.setIsPremultipliedAlpha(!0) } getSize() { return [this.coreModel.getModel().canvasinfo.CanvasWidth, this.coreModel.getModel().canvasinfo.CanvasHeight] } getLayout() { const t = {}; if (this.settings.layout) for (const e of Object.keys(this.settings.layout)) { const r = e.charAt(0).toLowerCase() + e.slice(1); t[r] = this.settings.layout[e] } return t } setupLayout() { super.setupLayout(), this.pixelsPerUnit = this.coreModel.getModel().canvasinfo.PixelsPerUnit, this.centeringTransform.scale(this.pixelsPerUnit, this.pixelsPerUnit).translate(this.originalWidth / 2, this.originalHeight / 2) } updateWebGLContext(t, e) { this.renderer.firstDraw = !0, this.renderer._bufferData = { vertex: null, uv: null, index: null }, this.renderer.startUp(t), this.renderer._clippingManager._currentFrameNo = e, this.renderer._clippingManager._maskTexture = void 0, ee.getInstance()._shaderSets = [] } bindTexture(t, e) { this.renderer.bindTexture(t, e) } getHitAreaDefs() { var t, e; return null != (e = null == (t = this.settings.hitAreas) ? void 0 : t.map((t => ({ id: t.Id, name: t.Name, index: this.coreModel.getDrawableIndex(t.Id) })))) ? e : [] } getDrawableIDs() { return this.coreModel.getDrawableIds() } getDrawableIndex(t) { return this.coreModel.getDrawableIndex(t) } getDrawableVertices(t) { if ("string" === typeof t && (t = this.coreModel.getDrawableIndex(t), -1 === t)) throw new TypeError("Unable to find drawable ID: " + t); const e = this.coreModel.getDrawableVertices(t).slice(); for (let r = 0; r < e.length; r += 2)e[r] = e[r] * this.pixelsPerUnit + this.originalWidth / 2, e[r + 1] = -e[r + 1] * this.pixelsPerUnit + this.originalHeight / 2; return e } updateTransform(t) { this.drawingMatrix.copyFrom(this.centeringTransform).prepend(this.localTransform).prepend(t) } update(t, e) { var r, i, n, o; super.update(t, e), t /= 1e3, e /= 1e3; const s = this.coreModel; this.emit("beforeMotionUpdate"); const a = this.motionManager.update(this.coreModel, e); this.emit("afterMotionUpdate"), s.saveParameters(), null == (r = this.motionManager.expressionManager) || r.update(s, e), a || null == (i = this.eyeBlink) || i.updateParameters(s, t), this.updateFocus(), this.updateNaturalMovements(1e3 * t, 1e3 * e), null == (n = this.physics) || n.evaluate(s, t), null == (o = this.pose) || o.updateParameters(s, t), this.emit("beforeModelUpdate"), s.update(), s.loadParameters() } updateFocus() { this.coreModel.addParameterValueById(this.idParamEyeBallX, this.focusController.x), this.coreModel.addParameterValueById(this.idParamEyeBallY, this.focusController.y), this.coreModel.addParameterValueById(this.idParamAngleX, 30 * this.focusController.x), this.coreModel.addParameterValueById(this.idParamAngleY, 30 * this.focusController.y), this.coreModel.addParameterValueById(this.idParamAngleZ, this.focusController.x * this.focusController.y * -30), this.coreModel.addParameterValueById(this.idParamBodyAngleX, 10 * this.focusController.x) } updateNaturalMovements(t, e) { var r; null == (r = this.breath) || r.updateParameters(this.coreModel, t / 1e3) } draw(t) { const e = this.drawingMatrix, r = vr.getArray(); r[0] = e.a, r[1] = e.b, r[4] = -e.c, r[5] = -e.d, r[12] = e.tx, r[13] = e.ty, this.renderer.setMvpMatrix(vr), this.renderer.setRenderState(t.getParameter(t.FRAMEBUFFER_BINDING), this.viewport), this.renderer.drawModel() } destroy() { super.destroy(), this.renderer.release(), this.coreModel.release(), this.renderer = void 0, this.coreModel = void 0 } } let br, xr = 20; function Tr() { return I.isStarted() ? Promise.resolve() : (null != br || (br = new Promise(((t, e) => { function r() { try { Er(), t() } catch (i) { if (xr--, xr < 0) { const t = new Error("Failed to start up Cubism 4 framework."); return t.cause = i, void e(t) } Te.log("Cubism4", "Startup failed, retrying 10ms later..."), setTimeout(r, 10) } } r() }))), br) } function Er(t) { t = Object.assign({ logFunction: console.log, loggingLevel: P.LogLevel_Verbose }, t), I.startUp(t), I.initialize() } function Sr() { var t; null == (t = this.__moc) || t.release() } rr.registerRuntime({ version: 4, ready: Tr, test(t) { return t instanceof mr || mr.isValidJSON(t) }, isValidMoc(t) { if (t.byteLength < 4) return !1; const e = new Int8Array(t, 0, 4); return "MOC3" === String.fromCharCode(...e) }, createModelSettings(t) { return new mr(t) }, createCoreModel(t) { const e = U.create(t); try { const t = e.createModel(); return t.__moc = e, t } catch (r) { try { e.release() } catch (i) { } throw r } }, createInternalModel(t, e, r) { const i = new yr(t, e, r), n = t; return n.__moc && (i.__moc = n.__moc, delete n.__moc, i.once("destroy", Sr)), i }, createPhysics(t, e) { return Pt.create(e) }, createPose(t, e) { return m.create(e) } }) }, 1538: function (t, e, r) { "use strict"; function i(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } r(7658), t.exports = function (t, e, r, n) { e = e || "&", r = r || "="; var o = {}; if ("string" !== typeof t || 0 === t.length) return o; var s = /\+/g; t = t.split(e); var a = 1e3; n && "number" === typeof n.maxKeys && (a = n.maxKeys); var u = t.length; a > 0 && u > a && (u = a); for (var h = 0; h < u; ++h) { var l, c, d, f, p = t[h].replace(s, "%20"), _ = p.indexOf(r); _ >= 0 ? (l = p.substr(0, _), c = p.substr(_ + 1)) : (l = p, c = ""), d = decodeURIComponent(l), f = decodeURIComponent(c), i(o, d) ? Array.isArray(o[d]) ? o[d].push(f) : o[d] = [o[d], f] : o[d] = f } return o } }, 8292: function (t) { "use strict"; var e = function (t) { switch (typeof t) { case "string": return t; case "boolean": return t ? "true" : "false"; case "number": return isFinite(t) ? t : ""; default: return "" } }; t.exports = function (t, r, i, n) { return r = r || "&", i = i || "=", null === t && (t = void 0), "object" === typeof t ? Object.keys(t).map((function (n) { var o = encodeURIComponent(e(n)) + i; return Array.isArray(t[n]) ? t[n].map((function (t) { return o + encodeURIComponent(e(t)) })).join(r) : o + encodeURIComponent(e(t[n])) })).join(r) : n ? encodeURIComponent(e(n)) + i + encodeURIComponent(e(t)) : "" } }, 8736: function (t, e, r) { "use strict"; e.decode = e.parse = r(1538), e.encode = e.stringify = r(8292) }, 9127: function (t, e, r) { var i; t = r.nmd(t), r(7658), function (n) { e && e.nodeType, t && t.nodeType; var o = "object" == typeof r.g && r.g; o.global !== o && o.window !== o && o.self; var s, a = 2147483647, u = 36, h = 1, l = 26, c = 38, d = 700, f = 72, p = 128, _ = "-", m = /^xn--/, g = /[^\x20-\x7E]/, v = /[\x2E\u3002\uFF0E\uFF61]/g, y = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, b = u - h, x = Math.floor, T = String.fromCharCode; function E(t) { throw RangeError(y[t]) } function S(t, e) { var r = t.length, i = []; while (r--) i[r] = e(t[r]); return i } function w(t, e) { var r = t.split("@"), i = ""; r.length > 1 && (i = r[0] + "@", t = r[1]), t = t.replace(v, "."); var n = t.split("."), o = S(n, e).join("."); return i + o } function A(t) { var e, r, i = [], n = 0, o = t.length; while (n < o) e = t.charCodeAt(n++), e >= 55296 && e <= 56319 && n < o ? (r = t.charCodeAt(n++), 56320 == (64512 & r) ? i.push(((1023 & e) << 10) + (1023 & r) + 65536) : (i.push(e), n--)) : i.push(e); return i } function R(t) { return S(t, (function (t) { var e = ""; return t > 65535 && (t -= 65536, e += T(t >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e += T(t), e })).join("") } function O(t) { return t - 48 < 10 ? t - 22 : t - 65 < 26 ? t - 65 : t - 97 < 26 ? t - 97 : u } function I(t, e) { return t + 22 + 75 * (t < 26) - ((0 != e) << 5) } function P(t, e, r) { var i = 0; for (t = r ? x(t / d) : t >> 1, t += x(t / e); t > b * l >> 1; i += u)t = x(t / b); return x(i + (b + 1) * t / (t + c)) } function M(t) { var e, r, i, n, o, s, c, d, m, g, v = [], y = t.length, b = 0, T = p, S = f; for (r = t.lastIndexOf(_), r < 0 && (r = 0), i = 0; i < r; ++i)t.charCodeAt(i) >= 128 && E("not-basic"), v.push(t.charCodeAt(i)); for (n = r > 0 ? r + 1 : 0; n < y;) { for (o = b, s = 1, c = u; ; c += u) { if (n >= y && E("invalid-input"), d = O(t.charCodeAt(n++)), (d >= u || d > x((a - b) / s)) && E("overflow"), b += d * s, m = c <= S ? h : c >= S + l ? l : c - S, d < m) break; g = u - m, s > x(a / g) && E("overflow"), s *= g } e = v.length + 1, S = P(b - o, e, 0 == o), x(b / e) > a - T && E("overflow"), T += x(b / e), b %= e, v.splice(b++, 0, T) } return R(v) } function C(t) { var e, r, i, n, o, s, c, d, m, g, v, y, b, S, w, R = []; for (t = A(t), y = t.length, e = p, r = 0, o = f, s = 0; s < y; ++s)v = t[s], v < 128 && R.push(T(v)); i = n = R.length, n && R.push(_); while (i < y) { for (c = a, s = 0; s < y; ++s)v = t[s], v >= e && v < c && (c = v); for (b = i + 1, c - e > x((a - r) / b) && E("overflow"), r += (c - e) * b, e = c, s = 0; s < y; ++s)if (v = t[s], v < e && ++r > a && E("overflow"), v == e) { for (d = r, m = u; ; m += u) { if (g = m <= o ? h : m >= o + l ? l : m - o, d < g) break; w = d - g, S = u - g, R.push(T(I(g + w % S, 0))), d = x(w / S) } R.push(T(I(d, 0))), o = P(r, b, i == n), r = 0, ++i } ++r, ++e } return R.join("") } function D(t) { return w(t, (function (t) { return m.test(t) ? M(t.slice(4).toLowerCase()) : t })) } function L(t) { return w(t, (function (t) { return g.test(t) ? "xn--" + C(t) : t })) } s = { version: "1.3.2", ucs2: { decode: A, encode: R }, decode: M, encode: C, toASCII: L, toUnicode: D }, i = function () { return s }.call(e, r, e, t), void 0 === i || (t.exports = i) }() }, 4030: function (t, e, r) { "use strict"; r(7658), r(541); var i = r(9127), n = r(7497); function o() { this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null } e.Qc = x, e.DB = E, e.WU = T; var s = /^([a-z0-9.+-]+:)/i, a = /:[0-9]*$/, u = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, h = ["<", ">", '"', "`", " ", "\r", "\n", "\t"], l = ["{", "}", "|", "\\", "^", "`"].concat(h), c = ["'"].concat(l), d = ["%", "/", "?", ";", "#"].concat(c), f = ["/", "?", "#"], p = 255, _ = /^[+a-z0-9A-Z_-]{0,63}$/, m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, g = { javascript: !0, "javascript:": !0 }, v = { javascript: !0, "javascript:": !0 }, y = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }, b = r(8736); function x(t, e, r) { if (t && n.isObject(t) && t instanceof o) return t; var i = new o; return i.parse(t, e, r), i } function T(t) { return n.isString(t) && (t = x(t)), t instanceof o ? t.format() : o.prototype.format.call(t) } function E(t, e) { return x(t, !1, !0).resolve(e) } function S(t, e) { return t ? x(t, !1, !0).resolveObject(e) : e } o.prototype.parse = function (t, e, r) { if (!n.isString(t)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t); var o = t.indexOf("?"), a = -1 !== o && o < t.indexOf("#") ? "?" : "#", h = t.split(a), l = /\\/g; h[0] = h[0].replace(l, "/"), t = h.join(a); var x = t; if (x = x.trim(), !r && 1 === t.split("#").length) { var T = u.exec(x); if (T) return this.path = x, this.href = x, this.pathname = T[1], T[2] ? (this.search = T[2], this.query = e ? b.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "", this.query = {}), this } var E = s.exec(x); if (E) { E = E[0]; var S = E.toLowerCase(); this.protocol = S, x = x.substr(E.length) } if (r || E || x.match(/^\/\/[^@\/]+@[^@\/]+/)) { var w = "//" === x.substr(0, 2); !w || E && v[E] || (x = x.substr(2), this.slashes = !0) } if (!v[E] && (w || E && !y[E])) { for (var A, R, O = -1, I = 0; I < f.length; I++) { var P = x.indexOf(f[I]); -1 !== P && (-1 === O || P < O) && (O = P) } R = -1 === O ? x.lastIndexOf("@") : x.lastIndexOf("@", O), -1 !== R && (A = x.slice(0, R), x = x.slice(R + 1), this.auth = decodeURIComponent(A)), O = -1; for (I = 0; I < d.length; I++) { P = x.indexOf(d[I]); -1 !== P && (-1 === O || P < O) && (O = P) } -1 === O && (O = x.length), this.host = x.slice(0, O), x = x.slice(O), this.parseHost(), this.hostname = this.hostname || ""; var M = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1]; if (!M) for (var C = this.hostname.split(/\./), D = (I = 0, C.length); I < D; I++) { var L = C[I]; if (L && !L.match(_)) { for (var F = "", N = 0, B = L.length; N < B; N++)L.charCodeAt(N) > 127 ? F += "x" : F += L[N]; if (!F.match(_)) { var U = C.slice(0, I), k = C.slice(I + 1), G = L.match(m); G && (U.push(G[1]), k.unshift(G[2])), k.length && (x = "/" + k.join(".") + x), this.hostname = U.join("."); break } } } this.hostname.length > p ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), M || (this.hostname = i.toASCII(this.hostname)); var X = this.port ? ":" + this.port : "", j = this.hostname || ""; this.host = j + X, this.href += this.host, M && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== x[0] && (x = "/" + x)) } if (!g[S]) for (I = 0, D = c.length; I < D; I++) { var H = c[I]; if (-1 !== x.indexOf(H)) { var V = encodeURIComponent(H); V === H && (V = escape(H)), x = x.split(H).join(V) } } var z = x.indexOf("#"); -1 !== z && (this.hash = x.substr(z), x = x.slice(0, z)); var Y = x.indexOf("?"); if (-1 !== Y ? (this.search = x.substr(Y), this.query = x.substr(Y + 1), e && (this.query = b.parse(this.query)), x = x.slice(0, Y)) : e && (this.search = "", this.query = {}), x && (this.pathname = x), y[S] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) { X = this.pathname || ""; var W = this.search || ""; this.path = X + W } return this.href = this.format(), this }, o.prototype.format = function () { var t = this.auth || ""; t && (t = encodeURIComponent(t), t = t.replace(/%3A/i, ":"), t += "@"); var e = this.protocol || "", r = this.pathname || "", i = this.hash || "", o = !1, s = ""; this.host ? o = t + this.host : this.hostname && (o = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o += ":" + this.port)), this.query && n.isObject(this.query) && Object.keys(this.query).length && (s = b.stringify(this.query)); var a = this.search || s && "?" + s || ""; return e && ":" !== e.substr(-1) && (e += ":"), this.slashes || (!e || y[e]) && !1 !== o ? (o = "//" + (o || ""), r && "/" !== r.charAt(0) && (r = "/" + r)) : o || (o = ""), i && "#" !== i.charAt(0) && (i = "#" + i), a && "?" !== a.charAt(0) && (a = "?" + a), r = r.replace(/[?#]/g, (function (t) { return encodeURIComponent(t) })), a = a.replace("#", "%23"), e + o + r + a + i }, o.prototype.resolve = function (t) { return this.resolveObject(x(t, !1, !0)).format() }, o.prototype.resolveObject = function (t) { if (n.isString(t)) { var e = new o; e.parse(t, !1, !0), t = e } for (var r = new o, i = Object.keys(this), s = 0; s < i.length; s++) { var a = i[s]; r[a] = this[a] } if (r.hash = t.hash, "" === t.href) return r.href = r.format(), r; if (t.slashes && !t.protocol) { for (var u = Object.keys(t), h = 0; h < u.length; h++) { var l = u[h]; "protocol" !== l && (r[l] = t[l]) } return y[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r } if (t.protocol && t.protocol !== r.protocol) { if (!y[t.protocol]) { for (var c = Object.keys(t), d = 0; d < c.length; d++) { var f = c[d]; r[f] = t[f] } return r.href = r.format(), r } if (r.protocol = t.protocol, t.host || v[t.protocol]) r.pathname = t.pathname; else { var p = (t.pathname || "").split("/"); while (p.length && !(t.host = p.shift())); t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== p[0] && p.unshift(""), p.length < 2 && p.unshift(""), r.pathname = p.join("/") } if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) { var _ = r.pathname || "", m = r.search || ""; r.path = _ + m } return r.slashes = r.slashes || t.slashes, r.href = r.format(), r } var g = r.pathname && "/" === r.pathname.charAt(0), b = t.host || t.pathname && "/" === t.pathname.charAt(0), x = b || g || r.host && t.pathname, T = x, E = r.pathname && r.pathname.split("/") || [], S = (p = t.pathname && t.pathname.split("/") || [], r.protocol && !y[r.protocol]); if (S && (r.hostname = "", r.port = null, r.host && ("" === E[0] ? E[0] = r.host : E.unshift(r.host)), r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === p[0] ? p[0] = t.host : p.unshift(t.host)), t.host = null), x = x && ("" === p[0] || "" === E[0])), b) r.host = t.host || "" === t.host ? t.host : r.host, r.hostname = t.hostname || "" === t.hostname ? t.hostname : r.hostname, r.search = t.search, r.query = t.query, E = p; else if (p.length) E || (E = []), E.pop(), E = E.concat(p), r.search = t.search, r.query = t.query; else if (!n.isNullOrUndefined(t.search)) { if (S) { r.hostname = r.host = E.shift(); var w = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@"); w && (r.auth = w.shift(), r.host = r.hostname = w.shift()) } return r.search = t.search, r.query = t.query, n.isNull(r.pathname) && n.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r } if (!E.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r; for (var A = E.slice(-1)[0], R = (r.host || t.host || E.length > 1) && ("." === A || ".." === A) || "" === A, O = 0, I = E.length; I >= 0; I--)A = E[I], "." === A ? E.splice(I, 1) : ".." === A ? (E.splice(I, 1), O++) : O && (E.splice(I, 1), O--); if (!x && !T) for (; O--; O)E.unshift(".."); !x || "" === E[0] || E[0] && "/" === E[0].charAt(0) || E.unshift(""), R && "/" !== E.join("/").substr(-1) && E.push(""); var P = "" === E[0] || E[0] && "/" === E[0].charAt(0); if (S) { r.hostname = r.host = P ? "" : E.length ? E.shift() : ""; w = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@"); w && (r.auth = w.shift(), r.host = r.hostname = w.shift()) } return x = x || r.host && E.length, x && !P && E.unshift(""), E.length ? r.pathname = E.join("/") : (r.pathname = null, r.path = null), n.isNull(r.pathname) && n.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), r }, o.prototype.parseHost = function () { var t = this.host, e = a.exec(t); e && (e = e[0], ":" !== e && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t) } }, 7497: function (t) { "use strict"; t.exports = { isString: function (t) { return "string" === typeof t }, isObject: function (t) { return "object" === typeof t && null !== t }, isNull: function (t) { return null === t }, isNullOrUndefined: function (t) { return null == t } } }, 6369: function (t, e, r) { "use strict"; r.d(e, { ZP: function () { return qi } }); r(7658), r(4633), r(541); var i = Object.freeze({}), n = Array.isArray; function o(t) { return void 0 === t || null === t } function s(t) { return void 0 !== t && null !== t } function a(t) { return !0 === t } function u(t) { return !1 === t } function h(t) { return "string" === typeof t || "number" === typeof t || "symbol" === typeof t || "boolean" === typeof t } function l(t) { return "function" === typeof t } function c(t) { return null !== t && "object" === typeof t } var d = Object.prototype.toString; function f(t) { return "[object Object]" === d.call(t) } function p(t) { return "[object RegExp]" === d.call(t) } function _(t) { var e = parseFloat(String(t)); return e >= 0 && Math.floor(e) === e && isFinite(t) } function m(t) { return s(t) && "function" === typeof t.then && "function" === typeof t.catch } function g(t) { return null == t ? "" : Array.isArray(t) || f(t) && t.toString === d ? JSON.stringify(t, null, 2) : String(t) } function v(t) { var e = parseFloat(t); return isNaN(e) ? t : e } function y(t, e) { for (var r = Object.create(null), i = t.split(","), n = 0; n < i.length; n++)r[i[n]] = !0; return e ? function (t) { return r[t.toLowerCase()] } : function (t) { return r[t] } } y("slot,component", !0); var b = y("key,ref,slot,slot-scope,is"); function x(t, e) { var r = t.length; if (r) { if (e === t[r - 1]) return void (t.length = r - 1); var i = t.indexOf(e); if (i > -1) return t.splice(i, 1) } } var T = Object.prototype.hasOwnProperty; function E(t, e) { return T.call(t, e) } function S(t) { var e = Object.create(null); return function (r) { var i = e[r]; return i || (e[r] = t(r)) } } var w = /-(\w)/g, A = S((function (t) { return t.replace(w, (function (t, e) { return e ? e.toUpperCase() : "" })) })), R = S((function (t) { return t.charAt(0).toUpperCase() + t.slice(1) })), O = /\B([A-Z])/g, I = S((function (t) { return t.replace(O, "-$1").toLowerCase() })); function P(t, e) { function r(r) { var i = arguments.length; return i ? i > 1 ? t.apply(e, arguments) : t.call(e, r) : t.call(e) } return r._length = t.length, r } function M(t, e) { return t.bind(e) } var C = Function.prototype.bind ? M : P; function D(t, e) { e = e || 0; var r = t.length - e, i = new Array(r); while (r--) i[r] = t[r + e]; return i } function L(t, e) { for (var r in e) t[r] = e[r]; return t } function F(t) { for (var e = {}, r = 0; r < t.length; r++)t[r] && L(e, t[r]); return e } function N(t, e, r) { } var B = function (t, e, r) { return !1 }, U = function (t) { return t }; function k(t, e) { if (t === e) return !0; var r = c(t), i = c(e); if (!r || !i) return !r && !i && String(t) === String(e); try { var n = Array.isArray(t), o = Array.isArray(e); if (n && o) return t.length === e.length && t.every((function (t, r) { return k(t, e[r]) })); if (t instanceof Date && e instanceof Date) return t.getTime() === e.getTime(); if (n || o) return !1; var s = Object.keys(t), a = Object.keys(e); return s.length === a.length && s.every((function (r) { return k(t[r], e[r]) })) } catch (u) { return !1 } } function G(t, e) { for (var r = 0; r < t.length; r++)if (k(t[r], e)) return r; return -1 } function X(t) { var e = !1; return function () { e || (e = !0, t.apply(this, arguments)) } } function j(t, e) { return t === e ? 0 === t && 1 / t !== 1 / e : t === t || e === e } var H = "data-server-rendered", V = ["component", "directive", "filter"], z = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch", "renderTracked", "renderTriggered"], Y = { optionMergeStrategies: Object.create(null), silent: !1, productionTip: !1, devtools: !1, performance: !1, errorHandler: null, warnHandler: null, ignoredElements: [], keyCodes: Object.create(null), isReservedTag: B, isReservedAttr: B, isUnknownElement: B, getTagNamespace: N, parsePlatformTagName: U, mustUseProp: B, async: !0, _lifecycleHooks: z }, W = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/; function $(t) { var e = (t + "").charCodeAt(0); return 36 === e || 95 === e } function q(t, e, r, i) { Object.defineProperty(t, e, { value: r, enumerable: !!i, writable: !0, configurable: !0 }) } var K = new RegExp("[^".concat(W.source, ".$_\\d]")); function Z(t) { if (!K.test(t)) { var e = t.split("."); return function (t) { for (var r = 0; r < e.length; r++) { if (!t) return; t = t[e[r]] } return t } } } var J = "__proto__" in {}, Q = "undefined" !== typeof window, tt = Q && window.navigator.userAgent.toLowerCase(), et = tt && /msie|trident/.test(tt), rt = tt && tt.indexOf("msie 9.0") > 0, it = tt && tt.indexOf("edge/") > 0; tt && tt.indexOf("android"); var nt = tt && /iphone|ipad|ipod|ios/.test(tt); tt && /chrome\/\d+/.test(tt), tt && /phantomjs/.test(tt); var ot, st = tt && tt.match(/firefox\/(\d+)/), at = {}.watch, ut = !1; if (Q) try { var ht = {}; Object.defineProperty(ht, "passive", { get: function () { ut = !0 } }), window.addEventListener("test-passive", null, ht) } catch (Zs) { } var lt = function () { return void 0 === ot && (ot = !Q && "undefined" !== typeof r.g && (r.g["process"] && "server" === r.g["process"].env.VUE_ENV)), ot }, ct = Q && window.__VUE_DEVTOOLS_GLOBAL_HOOK__; function dt(t) { return "function" === typeof t && /native code/.test(t.toString()) } var ft, pt = "undefined" !== typeof Symbol && dt(Symbol) && "undefined" !== typeof Reflect && dt(Reflect.ownKeys); ft = "undefined" !== typeof Set && dt(Set) ? Set : function () { function t() { this.set = Object.create(null) } return t.prototype.has = function (t) { return !0 === this.set[t] }, t.prototype.add = function (t) { this.set[t] = !0 }, t.prototype.clear = function () { this.set = Object.create(null) }, t }(); var _t = null; function mt(t) { void 0 === t && (t = null), t || _t && _t._scope.off(), _t = t, t && t._scope.on() } var gt = function () { function t(t, e, r, i, n, o, s, a) { this.tag = t, this.data = e, this.children = r, this.text = i, this.elm = n, this.ns = void 0, this.context = o, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e && e.key, this.componentOptions = s, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = a, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1 } return Object.defineProperty(t.prototype, "child", { get: function () { return this.componentInstance }, enumerable: !1, configurable: !0 }), t }(), vt = function (t) { void 0 === t && (t = ""); var e = new gt; return e.text = t, e.isComment = !0, e }; function yt(t) { return new gt(void 0, void 0, void 0, String(t)) } function bt(t) { var e = new gt(t.tag, t.data, t.children && t.children.slice(), t.text, t.elm, t.context, t.componentOptions, t.asyncFactory); return e.ns = t.ns, e.isStatic = t.isStatic, e.key = t.key, e.isComment = t.isComment, e.fnContext = t.fnContext, e.fnOptions = t.fnOptions, e.fnScopeId = t.fnScopeId, e.asyncMeta = t.asyncMeta, e.isCloned = !0, e } var xt = 0, Tt = [], Et = function () { for (var t = 0; t < Tt.length; t++) { var e = Tt[t]; e.subs = e.subs.filter((function (t) { return t })), e._pending = !1 } Tt.length = 0 }, St = function () { function t() { this._pending = !1, this.id = xt++, this.subs = [] } return t.prototype.addSub = function (t) { this.subs.push(t) }, t.prototype.removeSub = function (t) { this.subs[this.subs.indexOf(t)] = null, this._pending || (this._pending = !0, Tt.push(this)) }, t.prototype.depend = function (e) { t.target && t.target.addDep(this) }, t.prototype.notify = function (t) { var e = this.subs.filter((function (t) { return t })); for (var r = 0, i = e.length; r < i; r++) { var n = e[r]; 0, n.update() } }, t }(); St.target = null; var wt = []; function At(t) { wt.push(t), St.target = t } function Rt() { wt.pop(), St.target = wt[wt.length - 1] } var Ot = Array.prototype, It = Object.create(Ot), Pt = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"]; Pt.forEach((function (t) { var e = Ot[t]; q(It, t, (function () { for (var r = [], i = 0; i < arguments.length; i++)r[i] = arguments[i]; var n, o = e.apply(this, r), s = this.__ob__; switch (t) { case "push": case "unshift": n = r; break; case "splice": n = r.slice(2); break }return n && s.observeArray(n), s.dep.notify(), o })) })); var Mt = Object.getOwnPropertyNames(It), Ct = {}, Dt = !0; function Lt(t) { Dt = t } var Ft = { notify: N, depend: N, addSub: N, removeSub: N }, Nt = function () { function t(t, e, r) { if (void 0 === e && (e = !1), void 0 === r && (r = !1), this.value = t, this.shallow = e, this.mock = r, this.dep = r ? Ft : new St, this.vmCount = 0, q(t, "__ob__", this), n(t)) { if (!r) if (J) t.__proto__ = It; else for (var i = 0, o = Mt.length; i < o; i++) { var s = Mt[i]; q(t, s, It[s]) } e || this.observeArray(t) } else { var a = Object.keys(t); for (i = 0; i < a.length; i++) { s = a[i]; Ut(t, s, Ct, void 0, e, r) } } } return t.prototype.observeArray = function (t) { for (var e = 0, r = t.length; e < r; e++)Bt(t[e], !1, this.mock) }, t }(); function Bt(t, e, r) { return t && E(t, "__ob__") && t.__ob__ instanceof Nt ? t.__ob__ : !Dt || !r && lt() || !n(t) && !f(t) || !Object.isExtensible(t) || t.__v_skip || zt(t) || t instanceof gt ? void 0 : new Nt(t, e, r) } function Ut(t, e, r, i, o, s) { var a = new St, u = Object.getOwnPropertyDescriptor(t, e); if (!u || !1 !== u.configurable) { var h = u && u.get, l = u && u.set; h && !l || r !== Ct && 2 !== arguments.length || (r = t[e]); var c = !o && Bt(r, !1, s); return Object.defineProperty(t, e, { enumerable: !0, configurable: !0, get: function () { var e = h ? h.call(t) : r; return St.target && (a.depend(), c && (c.dep.depend(), n(e) && Xt(e))), zt(e) && !o ? e.value : e }, set: function (e) { var i = h ? h.call(t) : r; if (j(i, e)) { if (l) l.call(t, e); else { if (h) return; if (!o && zt(i) && !zt(e)) return void (i.value = e); r = e } c = !o && Bt(e, !1, s), a.notify() } } }), a } } function kt(t, e, r) { if (!Vt(t)) { var i = t.__ob__; return n(t) && _(e) ? (t.length = Math.max(t.length, e), t.splice(e, 1, r), i && !i.shallow && i.mock && Bt(r, !1, !0), r) : e in t && !(e in Object.prototype) ? (t[e] = r, r) : t._isVue || i && i.vmCount ? r : i ? (Ut(i.value, e, r, void 0, i.shallow, i.mock), i.dep.notify(), r) : (t[e] = r, r) } } function Gt(t, e) { if (n(t) && _(e)) t.splice(e, 1); else { var r = t.__ob__; t._isVue || r && r.vmCount || Vt(t) || E(t, e) && (delete t[e], r && r.dep.notify()) } } function Xt(t) { for (var e = void 0, r = 0, i = t.length; r < i; r++)e = t[r], e && e.__ob__ && e.__ob__.dep.depend(), n(e) && Xt(e) } function jt(t) { return Ht(t, !0), q(t, "__v_isShallow", !0), t } function Ht(t, e) { if (!Vt(t)) { Bt(t, e, lt()); 0 } } function Vt(t) { return !(!t || !t.__v_isReadonly) } function zt(t) { return !(!t || !0 !== t.__v_isRef) } function Yt(t, e, r) { Object.defineProperty(t, r, { enumerable: !0, configurable: !0, get: function () { var t = e[r]; if (zt(t)) return t.value; var i = t && t.__ob__; return i && i.dep.depend(), t }, set: function (t) { var i = e[r]; zt(i) && !zt(t) ? i.value = t : e[r] = t } }) } var Wt = "watcher"; "".concat(Wt, " callback"), "".concat(Wt, " getter"), "".concat(Wt, " cleanup"); var $t; var qt = function () { function t(t) { void 0 === t && (t = !1), this.detached = t, this.active = !0, this.effects = [], this.cleanups = [], this.parent = $t, !t && $t && (this.index = ($t.scopes || ($t.scopes = [])).push(this) - 1) } return t.prototype.run = function (t) { if (this.active) { var e = $t; try { return $t = this, t() } finally { $t = e } } else 0 }, t.prototype.on = function () { $t = this }, t.prototype.off = function () { $t = this.parent }, t.prototype.stop = function (t) { if (this.active) { var e = void 0, r = void 0; for (e = 0, r = this.effects.length; e < r; e++)this.effects[e].teardown(); for (e = 0, r = this.cleanups.length; e < r; e++)this.cleanups[e](); if (this.scopes) for (e = 0, r = this.scopes.length; e < r; e++)this.scopes[e].stop(!0); if (!this.detached && this.parent && !t) { var i = this.parent.scopes.pop(); i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index) } this.parent = void 0, this.active = !1 } }, t }(); function Kt(t, e) { void 0 === e && (e = $t), e && e.active && e.effects.push(t) } function Zt(t) { var e = t._provided, r = t.$parent && t.$parent._provided; return r === e ? t._provided = Object.create(r) : e } var Jt = S((function (t) { var e = "&" === t.charAt(0); t = e ? t.slice(1) : t; var r = "~" === t.charAt(0); t = r ? t.slice(1) : t; var i = "!" === t.charAt(0); return t = i ? t.slice(1) : t, { name: t, once: r, capture: i, passive: e } })); function Qt(t, e) { function r() { var t = r.fns; if (!n(t)) return qe(t, null, arguments, e, "v-on handler"); for (var i = t.slice(), o = 0; o < i.length; o++)qe(i[o], null, arguments, e, "v-on handler") } return r.fns = t, r } function te(t, e, r, i, n, s) { var u, h, l, c; for (u in t) h = t[u], l = e[u], c = Jt(u), o(h) || (o(l) ? (o(h.fns) && (h = t[u] = Qt(h, s)), a(c.once) && (h = t[u] = n(c.name, h, c.capture)), r(c.name, h, c.capture, c.passive, c.params)) : h !== l && (l.fns = h, t[u] = l)); for (u in e) o(t[u]) && (c = Jt(u), i(c.name, e[u], c.capture)) } function ee(t, e, r) { var i; t instanceof gt && (t = t.data.hook || (t.data.hook = {})); var n = t[e]; function u() { r.apply(this, arguments), x(i.fns, u) } o(n) ? i = Qt([u]) : s(n.fns) && a(n.merged) ? (i = n, i.fns.push(u)) : i = Qt([n, u]), i.merged = !0, t[e] = i } function re(t, e, r) { var i = e.options.props; if (!o(i)) { var n = {}, a = t.attrs, u = t.props; if (s(a) || s(u)) for (var h in i) { var l = I(h); ie(n, u, h, l, !0) || ie(n, a, h, l, !1) } return n } } function ie(t, e, r, i, n) { if (s(e)) { if (E(e, r)) return t[r] = e[r], n || delete e[r], !0; if (E(e, i)) return t[r] = e[i], n || delete e[i], !0 } return !1 } function ne(t) { for (var e = 0; e < t.length; e++)if (n(t[e])) return Array.prototype.concat.apply([], t); return t } function oe(t) { return h(t) ? [yt(t)] : n(t) ? ae(t) : void 0 } function se(t) { return s(t) && s(t.text) && u(t.isComment) } function ae(t, e) { var r, i, u, l, c = []; for (r = 0; r < t.length; r++)i = t[r], o(i) || "boolean" === typeof i || (u = c.length - 1, l = c[u], n(i) ? i.length > 0 && (i = ae(i, "".concat(e || "", "_").concat(r)), se(i[0]) && se(l) && (c[u] = yt(l.text + i[0].text), i.shift()), c.push.apply(c, i)) : h(i) ? se(l) ? c[u] = yt(l.text + i) : "" !== i && c.push(yt(i)) : se(i) && se(l) ? c[u] = yt(l.text + i.text) : (a(t._isVList) && s(i.tag) && o(i.key) && s(e) && (i.key = "__vlist".concat(e, "_").concat(r, "__")), c.push(i))); return c } function ue(t, e) { var r, i, o, a, u = null; if (n(t) || "string" === typeof t) for (u = new Array(t.length), r = 0, i = t.length; r < i; r++)u[r] = e(t[r], r); else if ("number" === typeof t) for (u = new Array(t), r = 0; r < t; r++)u[r] = e(r + 1, r); else if (c(t)) if (pt && t[Symbol.iterator]) { u = []; var h = t[Symbol.iterator](), l = h.next(); while (!l.done) u.push(e(l.value, u.length)), l = h.next() } else for (o = Object.keys(t), u = new Array(o.length), r = 0, i = o.length; r < i; r++)a = o[r], u[r] = e(t[a], a, r); return s(u) || (u = []), u._isVList = !0, u } function he(t, e, r, i) { var n, o = this.$scopedSlots[t]; o ? (r = r || {}, i && (r = L(L({}, i), r)), n = o(r) || (l(e) ? e() : e)) : n = this.$slots[t] || (l(e) ? e() : e); var s = r && r.slot; return s ? this.$createElement("template", { slot: s }, n) : n } function le(t) { return Ti(this.$options, "filters", t, !0) || U } function ce(t, e) { return n(t) ? -1 === t.indexOf(e) : t !== e } function de(t, e, r, i, n) { var o = Y.keyCodes[e] || r; return n && i && !Y.keyCodes[e] ? ce(n, i) : o ? ce(o, t) : i ? I(i) !== e : void 0 === t } function fe(t, e, r, i, o) { if (r) if (c(r)) { n(r) && (r = F(r)); var s = void 0, a = function (n) { if ("class" === n || "style" === n || b(n)) s = t; else { var a = t.attrs && t.attrs.type; s = i || Y.mustUseProp(e, a, n) ? t.domProps || (t.domProps = {}) : t.attrs || (t.attrs = {}) } var u = A(n), h = I(n); if (!(u in s) && !(h in s) && (s[n] = r[n], o)) { var l = t.on || (t.on = {}); l["update:".concat(n)] = function (t) { r[n] = t } } }; for (var u in r) a(u) } else; return t } function pe(t, e) { var r = this._staticTrees || (this._staticTrees = []), i = r[t]; return i && !e || (i = r[t] = this.$options.staticRenderFns[t].call(this._renderProxy, this._c, this), me(i, "__static__".concat(t), !1)), i } function _e(t, e, r) { return me(t, "__once__".concat(e).concat(r ? "_".concat(r) : ""), !0), t } function me(t, e, r) { if (n(t)) for (var i = 0; i < t.length; i++)t[i] && "string" !== typeof t[i] && ge(t[i], "".concat(e, "_").concat(i), r); else ge(t, e, r) } function ge(t, e, r) { t.isStatic = !0, t.key = e, t.isOnce = r } function ve(t, e) { if (e) if (f(e)) { var r = t.on = t.on ? L({}, t.on) : {}; for (var i in e) { var n = r[i], o = e[i]; r[i] = n ? [].concat(n, o) : o } } else; return t } function ye(t, e, r, i) { e = e || { $stable: !r }; for (var o = 0; o < t.length; o++) { var s = t[o]; n(s) ? ye(s, e, r) : s && (s.proxy && (s.fn.proxy = !0), e[s.key] = s.fn) } return i && (e.$key = i), e } function be(t, e) { for (var r = 0; r < e.length; r += 2) { var i = e[r]; "string" === typeof i && i && (t[e[r]] = e[r + 1]) } return t } function xe(t, e) { return "string" === typeof t ? e + t : t } function Te(t) { t._o = _e, t._n = v, t._s = g, t._l = ue, t._t = he, t._q = k, t._i = G, t._m = pe, t._f = le, t._k = de, t._b = fe, t._v = yt, t._e = vt, t._u = ye, t._g = ve, t._d = be, t._p = xe } function Ee(t, e) { if (!t || !t.length) return {}; for (var r = {}, i = 0, n = t.length; i < n; i++) { var o = t[i], s = o.data; if (s && s.attrs && s.attrs.slot && delete s.attrs.slot, o.context !== e && o.fnContext !== e || !s || null == s.slot) (r.default || (r.default = [])).push(o); else { var a = s.slot, u = r[a] || (r[a] = []); "template" === o.tag ? u.push.apply(u, o.children || []) : u.push(o) } } for (var h in r) r[h].every(Se) && delete r[h]; return r } function Se(t) { return t.isComment && !t.asyncFactory || " " === t.text } function we(t) { return t.isComment && t.asyncFactory } function Ae(t, e, r, n) { var o, s = Object.keys(r).length > 0, a = e ? !!e.$stable : !s, u = e && e.$key; if (e) { if (e._normalized) return e._normalized; if (a && n && n !== i && u === n.$key && !s && !n.$hasNormal) return n; for (var h in o = {}, e) e[h] && "$" !== h[0] && (o[h] = Re(t, r, h, e[h])) } else o = {}; for (var l in r) l in o || (o[l] = Oe(r, l)); return e && Object.isExtensible(e) && (e._normalized = o), q(o, "$stable", a), q(o, "$key", u), q(o, "$hasNormal", s), o } function Re(t, e, r, i) { var o = function () { var e = _t; mt(t); var r = arguments.length ? i.apply(null, arguments) : i({}); r = r && "object" === typeof r && !n(r) ? [r] : oe(r); var o = r && r[0]; return mt(e), r && (!o || 1 === r.length && o.isComment && !we(o)) ? void 0 : r }; return i.proxy && Object.defineProperty(e, r, { get: o, enumerable: !0, configurable: !0 }), o } function Oe(t, e) { return function () { return t[e] } } function Ie(t) { var e = t.$options, r = e.setup; if (r) { var i = t._setupContext = Pe(t); mt(t), At(); var n = qe(r, null, [t._props || jt({}), i], t, "setup"); if (Rt(), mt(), l(n)) e.render = n; else if (c(n)) if (t._setupState = n, n.__sfc) { var o = t._setupProxy = {}; for (var s in n) "__sfc" !== s && Yt(o, n, s) } else for (var s in n) $(s) || Yt(t, n, s); else 0 } } function Pe(t) { return { get attrs() { if (!t._attrsProxy) { var e = t._attrsProxy = {}; q(e, "_v_attr_proxy", !0), Me(e, t.$attrs, i, t, "$attrs") } return t._attrsProxy }, get listeners() { if (!t._listenersProxy) { var e = t._listenersProxy = {}; Me(e, t.$listeners, i, t, "$listeners") } return t._listenersProxy }, get slots() { return De(t) }, emit: C(t.$emit, t), expose: function (e) { e && Object.keys(e).forEach((function (r) { return Yt(t, e, r) })) } } } function Me(t, e, r, i, n) { var o = !1; for (var s in e) s in t ? e[s] !== r[s] && (o = !0) : (o = !0, Ce(t, s, i, n)); for (var s in t) s in e || (o = !0, delete t[s]); return o } function Ce(t, e, r, i) { Object.defineProperty(t, e, { enumerable: !0, configurable: !0, get: function () { return r[i][e] } }) } function De(t) { return t._slotsProxy || Le(t._slotsProxy = {}, t.$scopedSlots), t._slotsProxy } function Le(t, e) { for (var r in e) t[r] = e[r]; for (var r in t) r in e || delete t[r] } function Fe(t) { t._vnode = null, t._staticTrees = null; var e = t.$options, r = t.$vnode = e._parentVnode, n = r && r.context; t.$slots = Ee(e._renderChildren, n), t.$scopedSlots = r ? Ae(t.$parent, r.data.scopedSlots, t.$slots) : i, t._c = function (e, r, i, n) { return Ve(t, e, r, i, n, !1) }, t.$createElement = function (e, r, i, n) { return Ve(t, e, r, i, n, !0) }; var o = r && r.data; Ut(t, "$attrs", o && o.attrs || i, null, !0), Ut(t, "$listeners", e._parentListeners || i, null, !0) } var Ne = null; function Be(t) { Te(t.prototype), t.prototype.$nextTick = function (t) { return ar(t, this) }, t.prototype._render = function () { var t, e = this, r = e.$options, i = r.render, o = r._parentVnode; o && e._isMounted && (e.$scopedSlots = Ae(e.$parent, o.data.scopedSlots, e.$slots, e.$scopedSlots), e._slotsProxy && Le(e._slotsProxy, e.$scopedSlots)), e.$vnode = o; try { mt(e), Ne = e, t = i.call(e._renderProxy, e.$createElement) } catch (Zs) { $e(Zs, e, "render"), t = e._vnode } finally { Ne = null, mt() } return n(t) && 1 === t.length && (t = t[0]), t instanceof gt || (t = vt()), t.parent = o, t } } function Ue(t, e) { return (t.__esModule || pt && "Module" === t[Symbol.toStringTag]) && (t = t.default), c(t) ? e.extend(t) : t } function ke(t, e, r, i, n) { var o = vt(); return o.asyncFactory = t, o.asyncMeta = { data: e, context: r, children: i, tag: n }, o } function Ge(t, e) { if (a(t.error) && s(t.errorComp)) return t.errorComp; if (s(t.resolved)) return t.resolved; var r = Ne; if (r && s(t.owners) && -1 === t.owners.indexOf(r) && t.owners.push(r), a(t.loading) && s(t.loadingComp)) return t.loadingComp; if (r && !s(t.owners)) { var i = t.owners = [r], n = !0, u = null, h = null; r.$on("hook:destroyed", (function () { return x(i, r) })); var l = function (t) { for (var e = 0, r = i.length; e < r; e++)i[e].$forceUpdate(); t && (i.length = 0, null !== u && (clearTimeout(u), u = null), null !== h && (clearTimeout(h), h = null)) }, d = X((function (r) { t.resolved = Ue(r, e), n ? i.length = 0 : l(!0) })), f = X((function (e) { s(t.errorComp) && (t.error = !0, l(!0)) })), p = t(d, f); return c(p) && (m(p) ? o(t.resolved) && p.then(d, f) : m(p.component) && (p.component.then(d, f), s(p.error) && (t.errorComp = Ue(p.error, e)), s(p.loading) && (t.loadingComp = Ue(p.loading, e), 0 === p.delay ? t.loading = !0 : u = setTimeout((function () { u = null, o(t.resolved) && o(t.error) && (t.loading = !0, l(!1)) }), p.delay || 200)), s(p.timeout) && (h = setTimeout((function () { h = null, o(t.resolved) && f(null) }), p.timeout)))), n = !1, t.loading ? t.loadingComp : t.resolved } } function Xe(t) { if (n(t)) for (var e = 0; e < t.length; e++) { var r = t[e]; if (s(r) && (s(r.componentOptions) || we(r))) return r } } var je = 1, He = 2; function Ve(t, e, r, i, o, s) { return (n(r) || h(r)) && (o = i, i = r, r = void 0), a(s) && (o = He), ze(t, e, r, i, o) } function ze(t, e, r, i, o) { if (s(r) && s(r.__ob__)) return vt(); if (s(r) && s(r.is) && (e = r.is), !e) return vt(); var a, u; if (n(i) && l(i[0]) && (r = r || {}, r.scopedSlots = { default: i[0] }, i.length = 0), o === He ? i = oe(i) : o === je && (i = ne(i)), "string" === typeof e) { var h = void 0; u = t.$vnode && t.$vnode.ns || Y.getTagNamespace(e), a = Y.isReservedTag(e) ? new gt(Y.parsePlatformTagName(e), r, i, void 0, void 0, t) : r && r.pre || !s(h = Ti(t.$options, "components", e)) ? new gt(e, r, i, void 0, void 0, t) : oi(h, r, t, i, e) } else a = oi(e, r, t, i); return n(a) ? a : s(a) ? (s(u) && Ye(a, u), s(r) && We(r), a) : vt() } function Ye(t, e, r) { if (t.ns = e, "foreignObject" === t.tag && (e = void 0, r = !0), s(t.children)) for (var i = 0, n = t.children.length; i < n; i++) { var u = t.children[i]; s(u.tag) && (o(u.ns) || a(r) && "svg" !== u.tag) && Ye(u, e, r) } } function We(t) { c(t.style) && dr(t.style), c(t.class) && dr(t.class) } function $e(t, e, r) { At(); try { if (e) { var i = e; while (i = i.$parent) { var n = i.$options.errorCaptured; if (n) for (var o = 0; o < n.length; o++)try { var s = !1 === n[o].call(i, t, e, r); if (s) return } catch (Zs) { Ke(Zs, i, "errorCaptured hook") } } } Ke(t, e, r) } finally { Rt() } } function qe(t, e, r, i, n) { var o; try { o = r ? t.apply(e, r) : t.call(e), o && !o._isVue && m(o) && !o._handled && (o.catch((function (t) { return $e(t, i, n + " (Promise/async)") })), o._handled = !0) } catch (Zs) { $e(Zs, i, n) } return o } function Ke(t, e, r) { if (Y.errorHandler) try { return Y.errorHandler.call(null, t, e, r) } catch (Zs) { Zs !== t && Ze(Zs, null, "config.errorHandler") } Ze(t, e, r) } function Ze(t, e, r) { if (!Q || "undefined" === typeof console) throw t; console.error(t) } var Je, Qe = !1, tr = [], er = !1; function rr() { er = !1; var t = tr.slice(0); tr.length = 0; for (var e = 0; e < t.length; e++)t[e]() } if ("undefined" !== typeof Promise && dt(Promise)) { var ir = Promise.resolve(); Je = function () { ir.then(rr), nt && setTimeout(N) }, Qe = !0 } else if (et || "undefined" === typeof MutationObserver || !dt(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) Je = "undefined" !== typeof setImmediate && dt(setImmediate) ? function () { setImmediate(rr) } : function () { setTimeout(rr, 0) }; else { var nr = 1, or = new MutationObserver(rr), sr = document.createTextNode(String(nr)); or.observe(sr, { characterData: !0 }), Je = function () { nr = (nr + 1) % 2, sr.data = String(nr) }, Qe = !0 } function ar(t, e) { var r; if (tr.push((function () { if (t) try { t.call(e) } catch (Zs) { $e(Zs, e, "nextTick") } else r && r(e) })), er || (er = !0, Je()), !t && "undefined" !== typeof Promise) return new Promise((function (t) { r = t })) } function ur(t) { return function (e, r) { if (void 0 === r && (r = _t), r) return hr(r, t, e) } } function hr(t, e, r) { var i = t.$options; i[e] = pi(i[e], r) } ur("beforeMount"), ur("mounted"), ur("beforeUpdate"), ur("updated"), ur("beforeDestroy"), ur("destroyed"), ur("activated"), ur("deactivated"), ur("serverPrefetch"), ur("renderTracked"), ur("renderTriggered"), ur("errorCaptured"); var lr = "2.7.14"; var cr = new ft; function dr(t) { return fr(t, cr), cr.clear(), t } function fr(t, e) { var r, i, o = n(t); if (!(!o && !c(t) || t.__v_skip || Object.isFrozen(t) || t instanceof gt)) { if (t.__ob__) { var s = t.__ob__.dep.id; if (e.has(s)) return; e.add(s) } if (o) { r = t.length; while (r--) fr(t[r], e) } else if (zt(t)) fr(t.value, e); else { i = Object.keys(t), r = i.length; while (r--) fr(t[i[r]], e) } } } var pr, _r = 0, mr = function () { function t(t, e, r, i, n) { Kt(this, $t && !$t._vm ? $t : t ? t._scope : void 0), (this.vm = t) && n && (t._watcher = this), i ? (this.deep = !!i.deep, this.user = !!i.user, this.lazy = !!i.lazy, this.sync = !!i.sync, this.before = i.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = r, this.id = ++_r, this.active = !0, this.post = !1, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new ft, this.newDepIds = new ft, this.expression = "", l(e) ? this.getter = e : (this.getter = Z(e), this.getter || (this.getter = N)), this.value = this.lazy ? void 0 : this.get() } return t.prototype.get = function () { var t; At(this); var e = this.vm; try { t = this.getter.call(e, e) } catch (Zs) { if (!this.user) throw Zs; $e(Zs, e, 'getter for watcher "'.concat(this.expression, '"')) } finally { this.deep && dr(t), Rt(), this.cleanupDeps() } return t }, t.prototype.addDep = function (t) { var e = t.id; this.newDepIds.has(e) || (this.newDepIds.add(e), this.newDeps.push(t), this.depIds.has(e) || t.addSub(this)) }, t.prototype.cleanupDeps = function () { var t = this.deps.length; while (t--) { var e = this.deps[t]; this.newDepIds.has(e.id) || e.removeSub(this) } var r = this.depIds; this.depIds = this.newDepIds, this.newDepIds = r, this.newDepIds.clear(), r = this.deps, this.deps = this.newDeps, this.newDeps = r, this.newDeps.length = 0 }, t.prototype.update = function () { this.lazy ? this.dirty = !0 : this.sync ? this.run() : $r(this) }, t.prototype.run = function () { if (this.active) { var t = this.get(); if (t !== this.value || c(t) || this.deep) { var e = this.value; if (this.value = t, this.user) { var r = 'callback for watcher "'.concat(this.expression, '"'); qe(this.cb, this.vm, [t, e], this.vm, r) } else this.cb.call(this.vm, t, e) } } }, t.prototype.evaluate = function () { this.value = this.get(), this.dirty = !1 }, t.prototype.depend = function () { var t = this.deps.length; while (t--) this.deps[t].depend() }, t.prototype.teardown = function () { if (this.vm && !this.vm._isBeingDestroyed && x(this.vm._scope.effects, this), this.active) { var t = this.deps.length; while (t--) this.deps[t].removeSub(this); this.active = !1, this.onStop && this.onStop() } }, t }(); function gr(t) { t._events = Object.create(null), t._hasHookEvent = !1; var e = t.$options._parentListeners; e && xr(t, e) } function vr(t, e) { pr.$on(t, e) } function yr(t, e) { pr.$off(t, e) } function br(t, e) { var r = pr; return function i() { var n = e.apply(null, arguments); null !== n && r.$off(t, i) } } function xr(t, e, r) { pr = t, te(e, r || {}, vr, yr, br, t), pr = void 0 } function Tr(t) { var e = /^hook:/; t.prototype.$on = function (t, r) { var i = this; if (n(t)) for (var o = 0, s = t.length; o < s; o++)i.$on(t[o], r); else (i._events[t] || (i._events[t] = [])).push(r), e.test(t) && (i._hasHookEvent = !0); return i }, t.prototype.$once = function (t, e) { var r = this; function i() { r.$off(t, i), e.apply(r, arguments) } return i.fn = e, r.$on(t, i), r }, t.prototype.$off = function (t, e) { var r = this; if (!arguments.length) return r._events = Object.create(null), r; if (n(t)) { for (var i = 0, o = t.length; i < o; i++)r.$off(t[i], e); return r } var s, a = r._events[t]; if (!a) return r; if (!e) return r._events[t] = null, r; var u = a.length; while (u--) if (s = a[u], s === e || s.fn === e) { a.splice(u, 1); break } return r }, t.prototype.$emit = function (t) { var e = this, r = e._events[t]; if (r) { r = r.length > 1 ? D(r) : r; for (var i = D(arguments, 1), n = 'event handler for "'.concat(t, '"'), o = 0, s = r.length; o < s; o++)qe(r[o], e, i, e, n) } return e } } var Er = null; function Sr(t) { var e = Er; return Er = t, function () { Er = e } } function wr(t) { var e = t.$options, r = e.parent; if (r && !e.abstract) { while (r.$options.abstract && r.$parent) r = r.$parent; r.$children.push(t) } t.$parent = r, t.$root = r ? r.$root : t, t.$children = [], t.$refs = {}, t._provided = r ? r._provided : Object.create(null), t._watcher = null, t._inactive = null, t._directInactive = !1, t._isMounted = !1, t._isDestroyed = !1, t._isBeingDestroyed = !1 } function Ar(t) { t.prototype._update = function (t, e) { var r = this, i = r.$el, n = r._vnode, o = Sr(r); r._vnode = t, r.$el = n ? r.__patch__(n, t) : r.__patch__(r.$el, t, e, !1), o(), i && (i.__vue__ = null), r.$el && (r.$el.__vue__ = r); var s = r; while (s && s.$vnode && s.$parent && s.$vnode === s.$parent._vnode) s.$parent.$el = s.$el, s = s.$parent }, t.prototype.$forceUpdate = function () { var t = this; t._watcher && t._watcher.update() }, t.prototype.$destroy = function () { var t = this; if (!t._isBeingDestroyed) { Cr(t, "beforeDestroy"), t._isBeingDestroyed = !0; var e = t.$parent; !e || e._isBeingDestroyed || t.$options.abstract || x(e.$children, t), t._scope.stop(), t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), Cr(t, "destroyed"), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent = null) } } } function Rr(t, e, r) { var i; t.$el = e, t.$options.render || (t.$options.render = vt), Cr(t, "beforeMount"), i = function () { t._update(t._render(), r) }; var n = { before: function () { t._isMounted && !t._isDestroyed && Cr(t, "beforeUpdate") } }; new mr(t, i, N, n, !0), r = !1; var o = t._preWatchers; if (o) for (var s = 0; s < o.length; s++)o[s].run(); return null == t.$vnode && (t._isMounted = !0, Cr(t, "mounted")), t } function Or(t, e, r, n, o) { var s = n.data.scopedSlots, a = t.$scopedSlots, u = !!(s && !s.$stable || a !== i && !a.$stable || s && t.$scopedSlots.$key !== s.$key || !s && t.$scopedSlots.$key), h = !!(o || t.$options._renderChildren || u), l = t.$vnode; t.$options._parentVnode = n, t.$vnode = n, t._vnode && (t._vnode.parent = n), t.$options._renderChildren = o; var c = n.data.attrs || i; t._attrsProxy && Me(t._attrsProxy, c, l.data && l.data.attrs || i, t, "$attrs") && (h = !0), t.$attrs = c, r = r || i; var d = t.$options._parentListeners; if (t._listenersProxy && Me(t._listenersProxy, r, d || i, t, "$listeners"), t.$listeners = t.$options._parentListeners = r, xr(t, r, d), e && t.$options.props) { Lt(!1); for (var f = t._props, p = t.$options._propKeys || [], _ = 0; _ < p.length; _++) { var m = p[_], g = t.$options.props; f[m] = Ei(m, g, e, t) } Lt(!0), t.$options.propsData = e } h && (t.$slots = Ee(o, n.context), t.$forceUpdate()) } function Ir(t) { while (t && (t = t.$parent)) if (t._inactive) return !0; return !1 } function Pr(t, e) { if (e) { if (t._directInactive = !1, Ir(t)) return } else if (t._directInactive) return; if (t._inactive || null === t._inactive) { t._inactive = !1; for (var r = 0; r < t.$children.length; r++)Pr(t.$children[r]); Cr(t, "activated") } } function Mr(t, e) { if ((!e || (t._directInactive = !0, !Ir(t))) && !t._inactive) { t._inactive = !0; for (var r = 0; r < t.$children.length; r++)Mr(t.$children[r]); Cr(t, "deactivated") } } function Cr(t, e, r, i) { void 0 === i && (i = !0), At(); var n = _t; i && mt(t); var o = t.$options[e], s = "".concat(e, " hook"); if (o) for (var a = 0, u = o.length; a < u; a++)qe(o[a], t, r || null, t, s); t._hasHookEvent && t.$emit("hook:" + e), i && mt(n), Rt() } var Dr = [], Lr = [], Fr = {}, Nr = !1, Br = !1, Ur = 0; function kr() { Ur = Dr.length = Lr.length = 0, Fr = {}, Nr = Br = !1 } var Gr = 0, Xr = Date.now; if (Q && !et) { var jr = window.performance; jr && "function" === typeof jr.now && Xr() > document.createEvent("Event").timeStamp && (Xr = function () { return jr.now() }) } var Hr = function (t, e) { if (t.post) { if (!e.post) return 1 } else if (e.post) return -1; return t.id - e.id }; function Vr() { var t, e; for (Gr = Xr(), Br = !0, Dr.sort(Hr), Ur = 0; Ur < Dr.length; Ur++)t = Dr[Ur], t.before && t.before(), e = t.id, Fr[e] = null, t.run(); var r = Lr.slice(), i = Dr.slice(); kr(), Wr(r), zr(i), Et(), ct && Y.devtools && ct.emit("flush") } function zr(t) { var e = t.length; while (e--) { var r = t[e], i = r.vm; i && i._watcher === r && i._isMounted && !i._isDestroyed && Cr(i, "updated") } } function Yr(t) { t._inactive = !1, Lr.push(t) } function Wr(t) { for (var e = 0; e < t.length; e++)t[e]._inactive = !0, Pr(t[e], !0) } function $r(t) { var e = t.id; if (null == Fr[e] && (t !== St.target || !t.noRecurse)) { if (Fr[e] = !0, Br) { var r = Dr.length - 1; while (r > Ur && Dr[r].id > t.id) r--; Dr.splice(r + 1, 0, t) } else Dr.push(t); Nr || (Nr = !0, ar(Vr)) } } function qr(t) { var e = t.$options.provide; if (e) { var r = l(e) ? e.call(t) : e; if (!c(r)) return; for (var i = Zt(t), n = pt ? Reflect.ownKeys(r) : Object.keys(r), o = 0; o < n.length; o++) { var s = n[o]; Object.defineProperty(i, s, Object.getOwnPropertyDescriptor(r, s)) } } } function Kr(t) { var e = Zr(t.$options.inject, t); e && (Lt(!1), Object.keys(e).forEach((function (r) { Ut(t, r, e[r]) })), Lt(!0)) } function Zr(t, e) { if (t) { for (var r = Object.create(null), i = pt ? Reflect.ownKeys(t) : Object.keys(t), n = 0; n < i.length; n++) { var o = i[n]; if ("__ob__" !== o) { var s = t[o].from; if (s in e._provided) r[o] = e._provided[s]; else if ("default" in t[o]) { var a = t[o].default; r[o] = l(a) ? a.call(e) : a } else 0 } } return r } } function Jr(t, e, r, o, s) { var u, h = this, l = s.options; E(o, "_uid") ? (u = Object.create(o), u._original = o) : (u = o, o = o._original); var c = a(l._compiled), d = !c; this.data = t, this.props = e, this.children = r, this.parent = o, this.listeners = t.on || i, this.injections = Zr(l.inject, o), this.slots = function () { return h.$slots || Ae(o, t.scopedSlots, h.$slots = Ee(r, o)), h.$slots }, Object.defineProperty(this, "scopedSlots", { enumerable: !0, get: function () { return Ae(o, t.scopedSlots, this.slots()) } }), c && (this.$options = l, this.$slots = this.slots(), this.$scopedSlots = Ae(o, t.scopedSlots, this.$slots)), l._scopeId ? this._c = function (t, e, r, i) { var s = Ve(u, t, e, r, i, d); return s && !n(s) && (s.fnScopeId = l._scopeId, s.fnContext = o), s } : this._c = function (t, e, r, i) { return Ve(u, t, e, r, i, d) } } function Qr(t, e, r, o, a) { var u = t.options, h = {}, l = u.props; if (s(l)) for (var c in l) h[c] = Ei(c, l, e || i); else s(r.attrs) && ei(h, r.attrs), s(r.props) && ei(h, r.props); var d = new Jr(r, h, a, o, t), f = u.render.call(null, d._c, d); if (f instanceof gt) return ti(f, r, d.parent, u, d); if (n(f)) { for (var p = oe(f) || [], _ = new Array(p.length), m = 0; m < p.length; m++)_[m] = ti(p[m], r, d.parent, u, d); return _ } } function ti(t, e, r, i, n) { var o = bt(t); return o.fnContext = r, o.fnOptions = i, e.slot && ((o.data || (o.data = {})).slot = e.slot), o } function ei(t, e) { for (var r in e) t[A(r)] = e[r] } function ri(t) { return t.name || t.__name || t._componentTag } Te(Jr.prototype); var ii = { init: function (t, e) { if (t.componentInstance && !t.componentInstance._isDestroyed && t.data.keepAlive) { var r = t; ii.prepatch(r, r) } else { var i = t.componentInstance = si(t, Er); i.$mount(e ? t.elm : void 0, e) } }, prepatch: function (t, e) { var r = e.componentOptions, i = e.componentInstance = t.componentInstance; Or(i, r.propsData, r.listeners, e, r.children) }, insert: function (t) { var e = t.context, r = t.componentInstance; r._isMounted || (r._isMounted = !0, Cr(r, "mounted")), t.data.keepAlive && (e._isMounted ? Yr(r) : Pr(r, !0)) }, destroy: function (t) { var e = t.componentInstance; e._isDestroyed || (t.data.keepAlive ? Mr(e, !0) : e.$destroy()) } }, ni = Object.keys(ii); function oi(t, e, r, i, n) { if (!o(t)) { var u = r.$options._base; if (c(t) && (t = u.extend(t)), "function" === typeof t) { var h; if (o(t.cid) && (h = t, t = Ge(h, u), void 0 === t)) return ke(h, e, r, i, n); e = e || {}, Wi(t), s(e.model) && hi(t.options, e); var l = re(e, t, n); if (a(t.options.functional)) return Qr(t, l, e, r, i); var d = e.on; if (e.on = e.nativeOn, a(t.options.abstract)) { var f = e.slot; e = {}, f && (e.slot = f) } ai(e); var p = ri(t.options) || n, _ = new gt("vue-component-".concat(t.cid).concat(p ? "-".concat(p) : ""), e, void 0, void 0, void 0, r, { Ctor: t, propsData: l, listeners: d, tag: n, children: i }, h); return _ } } } function si(t, e) { var r = { _isComponent: !0, _parentVnode: t, parent: e }, i = t.data.inlineTemplate; return s(i) && (r.render = i.render, r.staticRenderFns = i.staticRenderFns), new t.componentOptions.Ctor(r) } function ai(t) { for (var e = t.hook || (t.hook = {}), r = 0; r < ni.length; r++) { var i = ni[r], n = e[i], o = ii[i]; n === o || n && n._merged || (e[i] = n ? ui(o, n) : o) } } function ui(t, e) { var r = function (r, i) { t(r, i), e(r, i) }; return r._merged = !0, r } function hi(t, e) { var r = t.model && t.model.prop || "value", i = t.model && t.model.event || "input"; (e.attrs || (e.attrs = {}))[r] = e.model.value; var o = e.on || (e.on = {}), a = o[i], u = e.model.callback; s(a) ? (n(a) ? -1 === a.indexOf(u) : a !== u) && (o[i] = [u].concat(a)) : o[i] = u } var li = N, ci = Y.optionMergeStrategies; function di(t, e, r) { if (void 0 === r && (r = !0), !e) return t; for (var i, n, o, s = pt ? Reflect.ownKeys(e) : Object.keys(e), a = 0; a < s.length; a++)i = s[a], "__ob__" !== i && (n = t[i], o = e[i], r && E(t, i) ? n !== o && f(n) && f(o) && di(n, o) : kt(t, i, o)); return t } function fi(t, e, r) { return r ? function () { var i = l(e) ? e.call(r, r) : e, n = l(t) ? t.call(r, r) : t; return i ? di(i, n) : n } : e ? t ? function () { return di(l(e) ? e.call(this, this) : e, l(t) ? t.call(this, this) : t) } : e : t } function pi(t, e) { var r = e ? t ? t.concat(e) : n(e) ? e : [e] : t; return r ? _i(r) : r } function _i(t) { for (var e = [], r = 0; r < t.length; r++)-1 === e.indexOf(t[r]) && e.push(t[r]); return e } function mi(t, e, r, i) { var n = Object.create(t || null); return e ? L(n, e) : n } ci.data = function (t, e, r) { return r ? fi(t, e, r) : e && "function" !== typeof e ? t : fi(t, e) }, z.forEach((function (t) { ci[t] = pi })), V.forEach((function (t) { ci[t + "s"] = mi })), ci.watch = function (t, e, r, i) { if (t === at && (t = void 0), e === at && (e = void 0), !e) return Object.create(t || null); if (!t) return e; var o = {}; for (var s in L(o, t), e) { var a = o[s], u = e[s]; a && !n(a) && (a = [a]), o[s] = a ? a.concat(u) : n(u) ? u : [u] } return o }, ci.props = ci.methods = ci.inject = ci.computed = function (t, e, r, i) { if (!t) return e; var n = Object.create(null); return L(n, t), e && L(n, e), n }, ci.provide = function (t, e) { return t ? function () { var r = Object.create(null); return di(r, l(t) ? t.call(this) : t), e && di(r, l(e) ? e.call(this) : e, !1), r } : e }; var gi = function (t, e) { return void 0 === e ? t : e }; function vi(t, e) { var r = t.props; if (r) { var i, o, s, a = {}; if (n(r)) { i = r.length; while (i--) o = r[i], "string" === typeof o && (s = A(o), a[s] = { type: null }) } else if (f(r)) for (var u in r) o = r[u], s = A(u), a[s] = f(o) ? o : { type: o }; else 0; t.props = a } } function yi(t, e) { var r = t.inject; if (r) { var i = t.inject = {}; if (n(r)) for (var o = 0; o < r.length; o++)i[r[o]] = { from: r[o] }; else if (f(r)) for (var s in r) { var a = r[s]; i[s] = f(a) ? L({ from: s }, a) : { from: a } } else 0 } } function bi(t) { var e = t.directives; if (e) for (var r in e) { var i = e[r]; l(i) && (e[r] = { bind: i, update: i }) } } function xi(t, e, r) { if (l(e) && (e = e.options), vi(e, r), yi(e, r), bi(e), !e._base && (e.extends && (t = xi(t, e.extends, r)), e.mixins)) for (var i = 0, n = e.mixins.length; i < n; i++)t = xi(t, e.mixins[i], r); var o, s = {}; for (o in t) a(o); for (o in e) E(t, o) || a(o); function a(i) { var n = ci[i] || gi; s[i] = n(t[i], e[i], r, i) } return s } function Ti(t, e, r, i) { if ("string" === typeof r) { var n = t[e]; if (E(n, r)) return n[r]; var o = A(r); if (E(n, o)) return n[o]; var s = R(o); if (E(n, s)) return n[s]; var a = n[r] || n[o] || n[s]; return a } } function Ei(t, e, r, i) { var n = e[t], o = !E(r, t), s = r[t], a = Oi(Boolean, n.type); if (a > -1) if (o && !E(n, "default")) s = !1; else if ("" === s || s === I(t)) { var u = Oi(String, n.type); (u < 0 || a < u) && (s = !0) } if (void 0 === s) { s = Si(i, n, t); var h = Dt; Lt(!0), Bt(s), Lt(h) } return s } function Si(t, e, r) { if (E(e, "default")) { var i = e.default; return t && t.$options.propsData && void 0 === t.$options.propsData[r] && void 0 !== t._props[r] ? t._props[r] : l(i) && "Function" !== Ai(e.type) ? i.call(t) : i } } var wi = /^\s*function (\w+)/; function Ai(t) { var e = t && t.toString().match(wi); return e ? e[1] : "" } function Ri(t, e) { return Ai(t) === Ai(e) } function Oi(t, e) { if (!n(e)) return Ri(e, t) ? 0 : -1; for (var r = 0, i = e.length; r < i; r++)if (Ri(e[r], t)) return r; return -1 } var Ii = { enumerable: !0, configurable: !0, get: N, set: N }; function Pi(t, e, r) { Ii.get = function () { return this[e][r] }, Ii.set = function (t) { this[e][r] = t }, Object.defineProperty(t, r, Ii) } function Mi(t) { var e = t.$options; if (e.props && Ci(t, e.props), Ie(t), e.methods && Gi(t, e.methods), e.data) Di(t); else { var r = Bt(t._data = {}); r && r.vmCount++ } e.computed && Ni(t, e.computed), e.watch && e.watch !== at && Xi(t, e.watch) } function Ci(t, e) { var r = t.$options.propsData || {}, i = t._props = jt({}), n = t.$options._propKeys = [], o = !t.$parent; o || Lt(!1); var s = function (o) { n.push(o); var s = Ei(o, e, r, t); Ut(i, o, s), o in t || Pi(t, "_props", o) }; for (var a in e) s(a); Lt(!0) } function Di(t) { var e = t.$options.data; e = t._data = l(e) ? Li(e, t) : e || {}, f(e) || (e = {}); var r = Object.keys(e), i = t.$options.props, n = (t.$options.methods, r.length); while (n--) { var o = r[n]; 0, i && E(i, o) || $(o) || Pi(t, "_data", o) } var s = Bt(e); s && s.vmCount++ } function Li(t, e) { At(); try { return t.call(e, e) } catch (Zs) { return $e(Zs, e, "data()"), {} } finally { Rt() } } var Fi = { lazy: !0 }; function Ni(t, e) { var r = t._computedWatchers = Object.create(null), i = lt(); for (var n in e) { var o = e[n], s = l(o) ? o : o.get; 0, i || (r[n] = new mr(t, s || N, N, Fi)), n in t || Bi(t, n, o) } } function Bi(t, e, r) { var i = !lt(); l(r) ? (Ii.get = i ? Ui(e) : ki(r), Ii.set = N) : (Ii.get = r.get ? i && !1 !== r.cache ? Ui(e) : ki(r.get) : N, Ii.set = r.set || N), Object.defineProperty(t, e, Ii) } function Ui(t) { return function () { var e = this._computedWatchers && this._computedWatchers[t]; if (e) return e.dirty && e.evaluate(), St.target && e.depend(), e.value } } function ki(t) { return function () { return t.call(this, this) } } function Gi(t, e) { t.$options.props; for (var r in e) t[r] = "function" !== typeof e[r] ? N : C(e[r], t) } function Xi(t, e) { for (var r in e) { var i = e[r]; if (n(i)) for (var o = 0; o < i.length; o++)ji(t, r, i[o]); else ji(t, r, i) } } function ji(t, e, r, i) { return f(r) && (i = r, r = r.handler), "string" === typeof r && (r = t[r]), t.$watch(e, r, i) } function Hi(t) { var e = { get: function () { return this._data } }, r = { get: function () { return this._props } }; Object.defineProperty(t.prototype, "$data", e), Object.defineProperty(t.prototype, "$props", r), t.prototype.$set = kt, t.prototype.$delete = Gt, t.prototype.$watch = function (t, e, r) { var i = this; if (f(e)) return ji(i, t, e, r); r = r || {}, r.user = !0; var n = new mr(i, t, e, r); if (r.immediate) { var o = 'callback for immediate watcher "'.concat(n.expression, '"'); At(), qe(e, i, [n.value], i, o), Rt() } return function () { n.teardown() } } } var Vi = 0; function zi(t) { t.prototype._init = function (t) { var e = this; e._uid = Vi++, e._isVue = !0, e.__v_skip = !0, e._scope = new qt(!0), e._scope._vm = !0, t && t._isComponent ? Yi(e, t) : e.$options = xi(Wi(e.constructor), t || {}, e), e._renderProxy = e, e._self = e, wr(e), gr(e), Fe(e), Cr(e, "beforeCreate", void 0, !1), Kr(e), Mi(e), qr(e), Cr(e, "created"), e.$options.el && e.$mount(e.$options.el) } } function Yi(t, e) { var r = t.$options = Object.create(t.constructor.options), i = e._parentVnode; r.parent = e.parent, r._parentVnode = i; var n = i.componentOptions; r.propsData = n.propsData, r._parentListeners = n.listeners, r._renderChildren = n.children, r._componentTag = n.tag, e.render && (r.render = e.render, r.staticRenderFns = e.staticRenderFns) } function Wi(t) { var e = t.options; if (t.super) { var r = Wi(t.super), i = t.superOptions; if (r !== i) { t.superOptions = r; var n = $i(t); n && L(t.extendOptions, n), e = t.options = xi(r, t.extendOptions), e.name && (e.components[e.name] = t) } } return e } function $i(t) { var e, r = t.options, i = t.sealedOptions; for (var n in r) r[n] !== i[n] && (e || (e = {}), e[n] = r[n]); return e } function qi(t) { this._init(t) } function Ki(t) { t.use = function (t) { var e = this._installedPlugins || (this._installedPlugins = []); if (e.indexOf(t) > -1) return this; var r = D(arguments, 1); return r.unshift(this), l(t.install) ? t.install.apply(t, r) : l(t) && t.apply(null, r), e.push(t), this } } function Zi(t) { t.mixin = function (t) { return this.options = xi(this.options, t), this } } function Ji(t) { t.cid = 0; var e = 1; t.extend = function (t) { t = t || {}; var r = this, i = r.cid, n = t._Ctor || (t._Ctor = {}); if (n[i]) return n[i]; var o = ri(t) || ri(r.options); var s = function (t) { this._init(t) }; return s.prototype = Object.create(r.prototype), s.prototype.constructor = s, s.cid = e++, s.options = xi(r.options, t), s["super"] = r, s.options.props && Qi(s), s.options.computed && tn(s), s.extend = r.extend, s.mixin = r.mixin, s.use = r.use, V.forEach((function (t) { s[t] = r[t] })), o && (s.options.components[o] = s), s.superOptions = r.options, s.extendOptions = t, s.sealedOptions = L({}, s.options), n[i] = s, s } } function Qi(t) { var e = t.options.props; for (var r in e) Pi(t.prototype, "_props", r) } function tn(t) { var e = t.options.computed; for (var r in e) Bi(t.prototype, r, e[r]) } function en(t) { V.forEach((function (e) { t[e] = function (t, r) { return r ? ("component" === e && f(r) && (r.name = r.name || t, r = this.options._base.extend(r)), "directive" === e && l(r) && (r = { bind: r, update: r }), this.options[e + "s"][t] = r, r) : this.options[e + "s"][t] } })) } function rn(t) { return t && (ri(t.Ctor.options) || t.tag) } function nn(t, e) { return n(t) ? t.indexOf(e) > -1 : "string" === typeof t ? t.split(",").indexOf(e) > -1 : !!p(t) && t.test(e) } function on(t, e) { var r = t.cache, i = t.keys, n = t._vnode; for (var o in r) { var s = r[o]; if (s) { var a = s.name; a && !e(a) && sn(r, o, i, n) } } } function sn(t, e, r, i) { var n = t[e]; !n || i && n.tag === i.tag || n.componentInstance.$destroy(), t[e] = null, x(r, e) } zi(qi), Hi(qi), Tr(qi), Ar(qi), Be(qi); var an = [String, RegExp, Array], un = { name: "keep-alive", abstract: !0, props: { include: an, exclude: an, max: [String, Number] }, methods: { cacheVNode: function () { var t = this, e = t.cache, r = t.keys, i = t.vnodeToCache, n = t.keyToCache; if (i) { var o = i.tag, s = i.componentInstance, a = i.componentOptions; e[n] = { name: rn(a), tag: o, componentInstance: s }, r.push(n), this.max && r.length > parseInt(this.max) && sn(e, r[0], r, this._vnode), this.vnodeToCache = null } } }, created: function () { this.cache = Object.create(null), this.keys = [] }, destroyed: function () { for (var t in this.cache) sn(this.cache, t, this.keys) }, mounted: function () { var t = this; this.cacheVNode(), this.$watch("include", (function (e) { on(t, (function (t) { return nn(e, t) })) })), this.$watch("exclude", (function (e) { on(t, (function (t) { return !nn(e, t) })) })) }, updated: function () { this.cacheVNode() }, render: function () { var t = this.$slots.default, e = Xe(t), r = e && e.componentOptions; if (r) { var i = rn(r), n = this, o = n.include, s = n.exclude; if (o && (!i || !nn(o, i)) || s && i && nn(s, i)) return e; var a = this, u = a.cache, h = a.keys, l = null == e.key ? r.Ctor.cid + (r.tag ? "::".concat(r.tag) : "") : e.key; u[l] ? (e.componentInstance = u[l].componentInstance, x(h, l), h.push(l)) : (this.vnodeToCache = e, this.keyToCache = l), e.data.keepAlive = !0 } return e || t && t[0] } }, hn = { KeepAlive: un }; function ln(t) { var e = { get: function () { return Y } }; Object.defineProperty(t, "config", e), t.util = { warn: li, extend: L, mergeOptions: xi, defineReactive: Ut }, t.set = kt, t.delete = Gt, t.nextTick = ar, t.observable = function (t) { return Bt(t), t }, t.options = Object.create(null), V.forEach((function (e) { t.options[e + "s"] = Object.create(null) })), t.options._base = t, L(t.options.components, hn), Ki(t), Zi(t), Ji(t), en(t) } ln(qi), Object.defineProperty(qi.prototype, "$isServer", { get: lt }), Object.defineProperty(qi.prototype, "$ssrContext", { get: function () { return this.$vnode && this.$vnode.ssrContext } }), Object.defineProperty(qi, "FunctionalRenderContext", { value: Jr }), qi.version = lr; var cn = y("style,class"), dn = y("input,textarea,option,select,progress"), fn = function (t, e, r) { return "value" === r && dn(t) && "button" !== e || "selected" === r && "option" === t || "checked" === r && "input" === t || "muted" === r && "video" === t }, pn = y("contenteditable,draggable,spellcheck"), _n = y("events,caret,typing,plaintext-only"), mn = function (t, e) { return xn(e) || "false" === e ? "false" : "contenteditable" === t && _n(e) ? e : "true" }, gn = y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"), vn = "http://www.w3.org/1999/xlink", yn = function (t) { return ":" === t.charAt(5) && "xlink" === t.slice(0, 5) }, bn = function (t) { return yn(t) ? t.slice(6, t.length) : "" }, xn = function (t) { return null == t || !1 === t }; function Tn(t) { var e = t.data, r = t, i = t; while (s(i.componentInstance)) i = i.componentInstance._vnode, i && i.data && (e = En(i.data, e)); while (s(r = r.parent)) r && r.data && (e = En(e, r.data)); return Sn(e.staticClass, e.class) } function En(t, e) { return { staticClass: wn(t.staticClass, e.staticClass), class: s(t.class) ? [t.class, e.class] : e.class } } function Sn(t, e) { return s(t) || s(e) ? wn(t, An(e)) : "" } function wn(t, e) { return t ? e ? t + " " + e : t : e || "" } function An(t) { return Array.isArray(t) ? Rn(t) : c(t) ? On(t) : "string" === typeof t ? t : "" } function Rn(t) { for (var e, r = "", i = 0, n = t.length; i < n; i++)s(e = An(t[i])) && "" !== e && (r && (r += " "), r += e); return r } function On(t) { var e = ""; for (var r in t) t[r] && (e && (e += " "), e += r); return e } var In = { svg: "http://www.w3.org/2000/svg", math: "http://www.w3.org/1998/Math/MathML" }, Pn = y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"), Mn = y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0), Cn = function (t) { return Pn(t) || Mn(t) }; function Dn(t) { return Mn(t) ? "svg" : "math" === t ? "math" : void 0 } var Ln = Object.create(null); function Fn(t) { if (!Q) return !0; if (Cn(t)) return !1; if (t = t.toLowerCase(), null != Ln[t]) return Ln[t]; var e = document.createElement(t); return t.indexOf("-") > -1 ? Ln[t] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : Ln[t] = /HTMLUnknownElement/.test(e.toString()) } var Nn = y("text,number,password,search,email,tel,url"); function Bn(t) { if ("string" === typeof t) { var e = document.querySelector(t); return e || document.createElement("div") } return t } function Un(t, e) { var r = document.createElement(t); return "select" !== t || e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && r.setAttribute("multiple", "multiple"), r } function kn(t, e) { return document.createElementNS(In[t], e) } function Gn(t) { return document.createTextNode(t) } function Xn(t) { return document.createComment(t) } function jn(t, e, r) { t.insertBefore(e, r) } function Hn(t, e) { t.removeChild(e) } function Vn(t, e) { t.appendChild(e) } function zn(t) { return t.parentNode } function Yn(t) { return t.nextSibling } function Wn(t) { return t.tagName } function $n(t, e) { t.textContent = e } function qn(t, e) { t.setAttribute(e, "") } var Kn = Object.freeze({ __proto__: null, createElement: Un, createElementNS: kn, createTextNode: Gn, createComment: Xn, insertBefore: jn, removeChild: Hn, appendChild: Vn, parentNode: zn, nextSibling: Yn, tagName: Wn, setTextContent: $n, setStyleScope: qn }), Zn = { create: function (t, e) { Jn(e) }, update: function (t, e) { t.data.ref !== e.data.ref && (Jn(t, !0), Jn(e)) }, destroy: function (t) { Jn(t, !0) } }; function Jn(t, e) { var r = t.data.ref; if (s(r)) { var i = t.context, o = t.componentInstance || t.elm, a = e ? null : o, u = e ? void 0 : o; if (l(r)) qe(r, i, [a], i, "template ref function"); else { var h = t.data.refInFor, c = "string" === typeof r || "number" === typeof r, d = zt(r), f = i.$refs; if (c || d) if (h) { var p = c ? f[r] : r.value; e ? n(p) && x(p, o) : n(p) ? p.includes(o) || p.push(o) : c ? (f[r] = [o], Qn(i, r, f[r])) : r.value = [o] } else if (c) { if (e && f[r] !== o) return; f[r] = u, Qn(i, r, a) } else if (d) { if (e && r.value !== o) return; r.value = a } else 0 } } } function Qn(t, e, r) { var i = t._setupState; i && E(i, e) && (zt(i[e]) ? i[e].value = r : i[e] = r) } var to = new gt("", {}, []), eo = ["create", "activate", "update", "remove", "destroy"]; function ro(t, e) { return t.key === e.key && t.asyncFactory === e.asyncFactory && (t.tag === e.tag && t.isComment === e.isComment && s(t.data) === s(e.data) && io(t, e) || a(t.isAsyncPlaceholder) && o(e.asyncFactory.error)) } function io(t, e) { if ("input" !== t.tag) return !0; var r, i = s(r = t.data) && s(r = r.attrs) && r.type, n = s(r = e.data) && s(r = r.attrs) && r.type; return i === n || Nn(i) && Nn(n) } function no(t, e, r) { var i, n, o = {}; for (i = e; i <= r; ++i)n = t[i].key, s(n) && (o[n] = i); return o } function oo(t) { var e, r, i = {}, u = t.modules, l = t.nodeOps; for (e = 0; e < eo.length; ++e)for (i[eo[e]] = [], r = 0; r < u.length; ++r)s(u[r][eo[e]]) && i[eo[e]].push(u[r][eo[e]]); function c(t) { return new gt(l.tagName(t).toLowerCase(), {}, [], void 0, t) } function d(t, e) { function r() { 0 === --r.listeners && f(t) } return r.listeners = e, r } function f(t) { var e = l.parentNode(t); s(e) && l.removeChild(e, t) } function p(t, e, r, i, n, o, u) { if (s(t.elm) && s(o) && (t = o[u] = bt(t)), t.isRootInsert = !n, !_(t, e, r, i)) { var h = t.data, c = t.children, d = t.tag; s(d) ? (t.elm = t.ns ? l.createElementNS(t.ns, d) : l.createElement(d, t), E(t), b(t, c, e), s(h) && T(t, e), v(r, t.elm, i)) : a(t.isComment) ? (t.elm = l.createComment(t.text), v(r, t.elm, i)) : (t.elm = l.createTextNode(t.text), v(r, t.elm, i)) } } function _(t, e, r, i) { var n = t.data; if (s(n)) { var o = s(t.componentInstance) && n.keepAlive; if (s(n = n.hook) && s(n = n.init) && n(t, !1), s(t.componentInstance)) return m(t, e), v(r, t.elm, i), a(o) && g(t, e, r, i), !0 } } function m(t, e) { s(t.data.pendingInsert) && (e.push.apply(e, t.data.pendingInsert), t.data.pendingInsert = null), t.elm = t.componentInstance.$el, x(t) ? (T(t, e), E(t)) : (Jn(t), e.push(t)) } function g(t, e, r, n) { var o, a = t; while (a.componentInstance) if (a = a.componentInstance._vnode, s(o = a.data) && s(o = o.transition)) { for (o = 0; o < i.activate.length; ++o)i.activate[o](to, a); e.push(a); break } v(r, t.elm, n) } function v(t, e, r) { s(t) && (s(r) ? l.parentNode(r) === t && l.insertBefore(t, e, r) : l.appendChild(t, e)) } function b(t, e, r) { if (n(e)) { 0; for (var i = 0; i < e.length; ++i)p(e[i], r, t.elm, null, !0, e, i) } else h(t.text) && l.appendChild(t.elm, l.createTextNode(String(t.text))) } function x(t) { while (t.componentInstance) t = t.componentInstance._vnode; return s(t.tag) } function T(t, r) { for (var n = 0; n < i.create.length; ++n)i.create[n](to, t); e = t.data.hook, s(e) && (s(e.create) && e.create(to, t), s(e.insert) && r.push(t)) } function E(t) { var e; if (s(e = t.fnScopeId)) l.setStyleScope(t.elm, e); else { var r = t; while (r) s(e = r.context) && s(e = e.$options._scopeId) && l.setStyleScope(t.elm, e), r = r.parent } s(e = Er) && e !== t.context && e !== t.fnContext && s(e = e.$options._scopeId) && l.setStyleScope(t.elm, e) } function S(t, e, r, i, n, o) { for (; i <= n; ++i)p(r[i], o, t, e, !1, r, i) } function w(t) { var e, r, n = t.data; if (s(n)) for (s(e = n.hook) && s(e = e.destroy) && e(t), e = 0; e < i.destroy.length; ++e)i.destroy[e](t); if (s(e = t.children)) for (r = 0; r < t.children.length; ++r)w(t.children[r]) } function A(t, e, r) { for (; e <= r; ++e) { var i = t[e]; s(i) && (s(i.tag) ? (R(i), w(i)) : f(i.elm)) } } function R(t, e) { if (s(e) || s(t.data)) { var r, n = i.remove.length + 1; for (s(e) ? e.listeners += n : e = d(t.elm, n), s(r = t.componentInstance) && s(r = r._vnode) && s(r.data) && R(r, e), r = 0; r < i.remove.length; ++r)i.remove[r](t, e); s(r = t.data.hook) && s(r = r.remove) ? r(t, e) : e() } else f(t.elm) } function O(t, e, r, i, n) { var a, u, h, c, d = 0, f = 0, _ = e.length - 1, m = e[0], g = e[_], v = r.length - 1, y = r[0], b = r[v], x = !n; while (d <= _ && f <= v) o(m) ? m = e[++d] : o(g) ? g = e[--_] : ro(m, y) ? (P(m, y, i, r, f), m = e[++d], y = r[++f]) : ro(g, b) ? (P(g, b, i, r, v), g = e[--_], b = r[--v]) : ro(m, b) ? (P(m, b, i, r, v), x && l.insertBefore(t, m.elm, l.nextSibling(g.elm)), m = e[++d], b = r[--v]) : ro(g, y) ? (P(g, y, i, r, f), x && l.insertBefore(t, g.elm, m.elm), g = e[--_], y = r[++f]) : (o(a) && (a = no(e, d, _)), u = s(y.key) ? a[y.key] : I(y, e, d, _), o(u) ? p(y, i, t, m.elm, !1, r, f) : (h = e[u], ro(h, y) ? (P(h, y, i, r, f), e[u] = void 0, x && l.insertBefore(t, h.elm, m.elm)) : p(y, i, t, m.elm, !1, r, f)), y = r[++f]); d > _ ? (c = o(r[v + 1]) ? null : r[v + 1].elm, S(t, c, r, f, v, i)) : f > v && A(e, d, _) } function I(t, e, r, i) { for (var n = r; n < i; n++) { var o = e[n]; if (s(o) && ro(t, o)) return n } } function P(t, e, r, n, u, h) { if (t !== e) { s(e.elm) && s(n) && (e = n[u] = bt(e)); var c = e.elm = t.elm; if (a(t.isAsyncPlaceholder)) s(e.asyncFactory.resolved) ? D(t.elm, e, r) : e.isAsyncPlaceholder = !0; else if (a(e.isStatic) && a(t.isStatic) && e.key === t.key && (a(e.isCloned) || a(e.isOnce))) e.componentInstance = t.componentInstance; else { var d, f = e.data; s(f) && s(d = f.hook) && s(d = d.prepatch) && d(t, e); var p = t.children, _ = e.children; if (s(f) && x(e)) { for (d = 0; d < i.update.length; ++d)i.update[d](t, e); s(d = f.hook) && s(d = d.update) && d(t, e) } o(e.text) ? s(p) && s(_) ? p !== _ && O(c, p, _, r, h) : s(_) ? (s(t.text) && l.setTextContent(c, ""), S(c, null, _, 0, _.length - 1, r)) : s(p) ? A(p, 0, p.length - 1) : s(t.text) && l.setTextContent(c, "") : t.text !== e.text && l.setTextContent(c, e.text), s(f) && s(d = f.hook) && s(d = d.postpatch) && d(t, e) } } } function M(t, e, r) { if (a(r) && s(t.parent)) t.parent.data.pendingInsert = e; else for (var i = 0; i < e.length; ++i)e[i].data.hook.insert(e[i]) } var C = y("attrs,class,staticClass,staticStyle,key"); function D(t, e, r, i) { var n, o = e.tag, u = e.data, h = e.children; if (i = i || u && u.pre, e.elm = t, a(e.isComment) && s(e.asyncFactory)) return e.isAsyncPlaceholder = !0, !0; if (s(u) && (s(n = u.hook) && s(n = n.init) && n(e, !0), s(n = e.componentInstance))) return m(e, r), !0; if (s(o)) { if (s(h)) if (t.hasChildNodes()) if (s(n = u) && s(n = n.domProps) && s(n = n.innerHTML)) { if (n !== t.innerHTML) return !1 } else { for (var l = !0, c = t.firstChild, d = 0; d < h.length; d++) { if (!c || !D(c, h[d], r, i)) { l = !1; break } c = c.nextSibling } if (!l || c) return !1 } else b(e, h, r); if (s(u)) { var f = !1; for (var p in u) if (!C(p)) { f = !0, T(e, r); break } !f && u["class"] && dr(u["class"]) } } else t.data !== e.text && (t.data = e.text); return !0 } return function (t, e, r, n) { if (!o(e)) { var u = !1, h = []; if (o(t)) u = !0, p(e, h); else { var d = s(t.nodeType); if (!d && ro(t, e)) P(t, e, h, null, null, n); else { if (d) { if (1 === t.nodeType && t.hasAttribute(H) && (t.removeAttribute(H), r = !0), a(r) && D(t, e, h)) return M(e, h, !0), t; t = c(t) } var f = t.elm, _ = l.parentNode(f); if (p(e, h, f._leaveCb ? null : _, l.nextSibling(f)), s(e.parent)) { var m = e.parent, g = x(e); while (m) { for (var v = 0; v < i.destroy.length; ++v)i.destroy[v](m); if (m.elm = e.elm, g) { for (var y = 0; y < i.create.length; ++y)i.create[y](to, m); var b = m.data.hook.insert; if (b.merged) for (var T = 1; T < b.fns.length; T++)b.fns[T]() } else Jn(m); m = m.parent } } s(_) ? A([t], 0, 0) : s(t.tag) && w(t) } } return M(e, h, u), e.elm } s(t) && w(t) } } var so = { create: ao, update: ao, destroy: function (t) { ao(t, to) } }; function ao(t, e) { (t.data.directives || e.data.directives) && uo(t, e) } function uo(t, e) { var r, i, n, o = t === to, s = e === to, a = lo(t.data.directives, t.context), u = lo(e.data.directives, e.context), h = [], l = []; for (r in u) i = a[r], n = u[r], i ? (n.oldValue = i.value, n.oldArg = i.arg, fo(n, "update", e, t), n.def && n.def.componentUpdated && l.push(n)) : (fo(n, "bind", e, t), n.def && n.def.inserted && h.push(n)); if (h.length) { var c = function () { for (var r = 0; r < h.length; r++)fo(h[r], "inserted", e, t) }; o ? ee(e, "insert", c) : c() } if (l.length && ee(e, "postpatch", (function () { for (var r = 0; r < l.length; r++)fo(l[r], "componentUpdated", e, t) })), !o) for (r in a) u[r] || fo(a[r], "unbind", t, t, s) } var ho = Object.create(null); function lo(t, e) { var r, i, n = Object.create(null); if (!t) return n; for (r = 0; r < t.length; r++) { if (i = t[r], i.modifiers || (i.modifiers = ho), n[co(i)] = i, e._setupState && e._setupState.__sfc) { var o = i.def || Ti(e, "_setupState", "v-" + i.name); i.def = "function" === typeof o ? { bind: o, update: o } : o } i.def = i.def || Ti(e.$options, "directives", i.name, !0) } return n } function co(t) { return t.rawName || "".concat(t.name, ".").concat(Object.keys(t.modifiers || {}).join(".")) } function fo(t, e, r, i, n) { var o = t.def && t.def[e]; if (o) try { o(r.elm, t, r, i, n) } catch (Zs) { $e(Zs, r.context, "directive ".concat(t.name, " ").concat(e, " hook")) } } var po = [Zn, so]; function _o(t, e) { var r = e.componentOptions; if ((!s(r) || !1 !== r.Ctor.options.inheritAttrs) && (!o(t.data.attrs) || !o(e.data.attrs))) { var i, n, u, h = e.elm, l = t.data.attrs || {}, c = e.data.attrs || {}; for (i in (s(c.__ob__) || a(c._v_attr_proxy)) && (c = e.data.attrs = L({}, c)), c) n = c[i], u = l[i], u !== n && mo(h, i, n, e.data.pre); for (i in (et || it) && c.value !== l.value && mo(h, "value", c.value), l) o(c[i]) && (yn(i) ? h.removeAttributeNS(vn, bn(i)) : pn(i) || h.removeAttribute(i)) } } function mo(t, e, r, i) { i || t.tagName.indexOf("-") > -1 ? go(t, e, r) : gn(e) ? xn(r) ? t.removeAttribute(e) : (r = "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e, t.setAttribute(e, r)) : pn(e) ? t.setAttribute(e, mn(e, r)) : yn(e) ? xn(r) ? t.removeAttributeNS(vn, bn(e)) : t.setAttributeNS(vn, e, r) : go(t, e, r) } function go(t, e, r) { if (xn(r)) t.removeAttribute(e); else { if (et && !rt && "TEXTAREA" === t.tagName && "placeholder" === e && "" !== r && !t.__ieph) { var i = function (e) { e.stopImmediatePropagation(), t.removeEventListener("input", i) }; t.addEventListener("input", i), t.__ieph = !0 } t.setAttribute(e, r) } } var vo = { create: _o, update: _o }; function yo(t, e) { var r = e.elm, i = e.data, n = t.data; if (!(o(i.staticClass) && o(i.class) && (o(n) || o(n.staticClass) && o(n.class)))) { var a = Tn(e), u = r._transitionClasses; s(u) && (a = wn(a, An(u))), a !== r._prevClass && (r.setAttribute("class", a), r._prevClass = a) } } var bo, xo = { create: yo, update: yo }, To = "__r", Eo = "__c"; function So(t) { if (s(t[To])) { var e = et ? "change" : "input"; t[e] = [].concat(t[To], t[e] || []), delete t[To] } s(t[Eo]) && (t.change = [].concat(t[Eo], t.change || []), delete t[Eo]) } function wo(t, e, r) { var i = bo; return function n() { var o = e.apply(null, arguments); null !== o && Oo(t, n, r, i) } } var Ao = Qe && !(st && Number(st[1]) <= 53); function Ro(t, e, r, i) { if (Ao) { var n = Gr, o = e; e = o._wrapper = function (t) { if (t.target === t.currentTarget || t.timeStamp >= n || t.timeStamp <= 0 || t.target.ownerDocument !== document) return o.apply(this, arguments) } } bo.addEventListener(t, e, ut ? { capture: r, passive: i } : r) } function Oo(t, e, r, i) { (i || bo).removeEventListener(t, e._wrapper || e, r) } function Io(t, e) { if (!o(t.data.on) || !o(e.data.on)) { var r = e.data.on || {}, i = t.data.on || {}; bo = e.elm || t.elm, So(r), te(r, i, Ro, Oo, wo, e.context), bo = void 0 } } var Po, Mo = { create: Io, update: Io, destroy: function (t) { return Io(t, to) } }; function Co(t, e) { if (!o(t.data.domProps) || !o(e.data.domProps)) { var r, i, n = e.elm, u = t.data.domProps || {}, h = e.data.domProps || {}; for (r in (s(h.__ob__) || a(h._v_attr_proxy)) && (h = e.data.domProps = L({}, h)), u) r in h || (n[r] = ""); for (r in h) { if (i = h[r], "textContent" === r || "innerHTML" === r) { if (e.children && (e.children.length = 0), i === u[r]) continue; 1 === n.childNodes.length && n.removeChild(n.childNodes[0]) } if ("value" === r && "PROGRESS" !== n.tagName) { n._value = i; var l = o(i) ? "" : String(i); Do(n, l) && (n.value = l) } else if ("innerHTML" === r && Mn(n.tagName) && o(n.innerHTML)) { Po = Po || document.createElement("div"), Po.innerHTML = "<svg>".concat(i, "</svg>"); var c = Po.firstChild; while (n.firstChild) n.removeChild(n.firstChild); while (c.firstChild) n.appendChild(c.firstChild) } else if (i !== u[r]) try { n[r] = i } catch (Zs) { } } } } function Do(t, e) { return !t.composing && ("OPTION" === t.tagName || Lo(t, e) || Fo(t, e)) } function Lo(t, e) { var r = !0; try { r = document.activeElement !== t } catch (Zs) { } return r && t.value !== e } function Fo(t, e) { var r = t.value, i = t._vModifiers; if (s(i)) { if (i.number) return v(r) !== v(e); if (i.trim) return r.trim() !== e.trim() } return r !== e } var No = { create: Co, update: Co }, Bo = S((function (t) { var e = {}, r = /;(?![^(]*\))/g, i = /:(.+)/; return t.split(r).forEach((function (t) { if (t) { var r = t.split(i); r.length > 1 && (e[r[0].trim()] = r[1].trim()) } })), e })); function Uo(t) { var e = ko(t.style); return t.staticStyle ? L(t.staticStyle, e) : e } function ko(t) { return Array.isArray(t) ? F(t) : "string" === typeof t ? Bo(t) : t } function Go(t, e) { var r, i = {}; if (e) { var n = t; while (n.componentInstance) n = n.componentInstance._vnode, n && n.data && (r = Uo(n.data)) && L(i, r) } (r = Uo(t.data)) && L(i, r); var o = t; while (o = o.parent) o.data && (r = Uo(o.data)) && L(i, r); return i } var Xo, jo = /^--/, Ho = /\s*!important$/, Vo = function (t, e, r) { if (jo.test(e)) t.style.setProperty(e, r); else if (Ho.test(r)) t.style.setProperty(I(e), r.replace(Ho, ""), "important"); else { var i = Yo(e); if (Array.isArray(r)) for (var n = 0, o = r.length; n < o; n++)t.style[i] = r[n]; else t.style[i] = r } }, zo = ["Webkit", "Moz", "ms"], Yo = S((function (t) { if (Xo = Xo || document.createElement("div").style, t = A(t), "filter" !== t && t in Xo) return t; for (var e = t.charAt(0).toUpperCase() + t.slice(1), r = 0; r < zo.length; r++) { var i = zo[r] + e; if (i in Xo) return i } })); function Wo(t, e) { var r = e.data, i = t.data; if (!(o(r.staticStyle) && o(r.style) && o(i.staticStyle) && o(i.style))) { var n, a, u = e.elm, h = i.staticStyle, l = i.normalizedStyle || i.style || {}, c = h || l, d = ko(e.data.style) || {}; e.data.normalizedStyle = s(d.__ob__) ? L({}, d) : d; var f = Go(e, !0); for (a in c) o(f[a]) && Vo(u, a, ""); for (a in f) n = f[a], n !== c[a] && Vo(u, a, null == n ? "" : n) } } var $o = { create: Wo, update: Wo }, qo = /\s+/; function Ko(t, e) { if (e && (e = e.trim())) if (t.classList) e.indexOf(" ") > -1 ? e.split(qo).forEach((function (e) { return t.classList.add(e) })) : t.classList.add(e); else { var r = " ".concat(t.getAttribute("class") || "", " "); r.indexOf(" " + e + " ") < 0 && t.setAttribute("class", (r + e).trim()) } } function Zo(t, e) { if (e && (e = e.trim())) if (t.classList) e.indexOf(" ") > -1 ? e.split(qo).forEach((function (e) { return t.classList.remove(e) })) : t.classList.remove(e), t.classList.length || t.removeAttribute("class"); else { var r = " ".concat(t.getAttribute("class") || "", " "), i = " " + e + " "; while (r.indexOf(i) >= 0) r = r.replace(i, " "); r = r.trim(), r ? t.setAttribute("class", r) : t.removeAttribute("class") } } function Jo(t) { if (t) { if ("object" === typeof t) { var e = {}; return !1 !== t.css && L(e, Qo(t.name || "v")), L(e, t), e } return "string" === typeof t ? Qo(t) : void 0 } } var Qo = S((function (t) { return { enterClass: "".concat(t, "-enter"), enterToClass: "".concat(t, "-enter-to"), enterActiveClass: "".concat(t, "-enter-active"), leaveClass: "".concat(t, "-leave"), leaveToClass: "".concat(t, "-leave-to"), leaveActiveClass: "".concat(t, "-leave-active") } })), ts = Q && !rt, es = "transition", rs = "animation", is = "transition", ns = "transitionend", os = "animation", ss = "animationend"; ts && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (is = "WebkitTransition", ns = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (os = "WebkitAnimation", ss = "webkitAnimationEnd")); var as = Q ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function (t) { return t() }; function us(t) { as((function () { as(t) })) } function hs(t, e) { var r = t._transitionClasses || (t._transitionClasses = []); r.indexOf(e) < 0 && (r.push(e), Ko(t, e)) } function ls(t, e) { t._transitionClasses && x(t._transitionClasses, e), Zo(t, e) } function cs(t, e, r) { var i = fs(t, e), n = i.type, o = i.timeout, s = i.propCount; if (!n) return r(); var a = n === es ? ns : ss, u = 0, h = function () { t.removeEventListener(a, l), r() }, l = function (e) { e.target === t && ++u >= s && h() }; setTimeout((function () { u < s && h() }), o + 1), t.addEventListener(a, l) } var ds = /\b(transform|all)(,|$)/; function fs(t, e) { var r, i = window.getComputedStyle(t), n = (i[is + "Delay"] || "").split(", "), o = (i[is + "Duration"] || "").split(", "), s = ps(n, o), a = (i[os + "Delay"] || "").split(", "), u = (i[os + "Duration"] || "").split(", "), h = ps(a, u), l = 0, c = 0; e === es ? s > 0 && (r = es, l = s, c = o.length) : e === rs ? h > 0 && (r = rs, l = h, c = u.length) : (l = Math.max(s, h), r = l > 0 ? s > h ? es : rs : null, c = r ? r === es ? o.length : u.length : 0); var d = r === es && ds.test(i[is + "Property"]); return { type: r, timeout: l, propCount: c, hasTransform: d } } function ps(t, e) { while (t.length < e.length) t = t.concat(t); return Math.max.apply(null, e.map((function (e, r) { return _s(e) + _s(t[r]) }))) } function _s(t) { return 1e3 * Number(t.slice(0, -1).replace(",", ".")) } function ms(t, e) { var r = t.elm; s(r._leaveCb) && (r._leaveCb.cancelled = !0, r._leaveCb()); var i = Jo(t.data.transition); if (!o(i) && !s(r._enterCb) && 1 === r.nodeType) { var n = i.css, a = i.type, u = i.enterClass, h = i.enterToClass, d = i.enterActiveClass, f = i.appearClass, p = i.appearToClass, _ = i.appearActiveClass, m = i.beforeEnter, g = i.enter, y = i.afterEnter, b = i.enterCancelled, x = i.beforeAppear, T = i.appear, E = i.afterAppear, S = i.appearCancelled, w = i.duration, A = Er, R = Er.$vnode; while (R && R.parent) A = R.context, R = R.parent; var O = !A._isMounted || !t.isRootInsert; if (!O || T || "" === T) { var I = O && f ? f : u, P = O && _ ? _ : d, M = O && p ? p : h, C = O && x || m, D = O && l(T) ? T : g, L = O && E || y, F = O && S || b, N = v(c(w) ? w.enter : w); 0; var B = !1 !== n && !rt, U = ys(D), k = r._enterCb = X((function () { B && (ls(r, M), ls(r, P)), k.cancelled ? (B && ls(r, I), F && F(r)) : L && L(r), r._enterCb = null })); t.data.show || ee(t, "insert", (function () { var e = r.parentNode, i = e && e._pending && e._pending[t.key]; i && i.tag === t.tag && i.elm._leaveCb && i.elm._leaveCb(), D && D(r, k) })), C && C(r), B && (hs(r, I), hs(r, P), us((function () { ls(r, I), k.cancelled || (hs(r, M), U || (vs(N) ? setTimeout(k, N) : cs(r, a, k))) }))), t.data.show && (e && e(), D && D(r, k)), B || U || k() } } } function gs(t, e) { var r = t.elm; s(r._enterCb) && (r._enterCb.cancelled = !0, r._enterCb()); var i = Jo(t.data.transition); if (o(i) || 1 !== r.nodeType) return e(); if (!s(r._leaveCb)) { var n = i.css, a = i.type, u = i.leaveClass, h = i.leaveToClass, l = i.leaveActiveClass, d = i.beforeLeave, f = i.leave, p = i.afterLeave, _ = i.leaveCancelled, m = i.delayLeave, g = i.duration, y = !1 !== n && !rt, b = ys(f), x = v(c(g) ? g.leave : g); 0; var T = r._leaveCb = X((function () { r.parentNode && r.parentNode._pending && (r.parentNode._pending[t.key] = null), y && (ls(r, h), ls(r, l)), T.cancelled ? (y && ls(r, u), _ && _(r)) : (e(), p && p(r)), r._leaveCb = null })); m ? m(E) : E() } function E() { T.cancelled || (!t.data.show && r.parentNode && ((r.parentNode._pending || (r.parentNode._pending = {}))[t.key] = t), d && d(r), y && (hs(r, u), hs(r, l), us((function () { ls(r, u), T.cancelled || (hs(r, h), b || (vs(x) ? setTimeout(T, x) : cs(r, a, T))) }))), f && f(r, T), y || b || T()) } } function vs(t) { return "number" === typeof t && !isNaN(t) } function ys(t) { if (o(t)) return !1; var e = t.fns; return s(e) ? ys(Array.isArray(e) ? e[0] : e) : (t._length || t.length) > 1 } function bs(t, e) { !0 !== e.data.show && ms(e) } var xs = Q ? { create: bs, activate: bs, remove: function (t, e) { !0 !== t.data.show ? gs(t, e) : e() } } : {}, Ts = [vo, xo, Mo, No, $o, xs], Es = Ts.concat(po), Ss = oo({ nodeOps: Kn, modules: Es }); rt && document.addEventListener("selectionchange", (function () { var t = document.activeElement; t && t.vmodel && Cs(t, "input") })); var ws = { inserted: function (t, e, r, i) { "select" === r.tag ? (i.elm && !i.elm._vOptions ? ee(r, "postpatch", (function () { ws.componentUpdated(t, e, r) })) : As(t, e, r.context), t._vOptions = [].map.call(t.options, Is)) : ("textarea" === r.tag || Nn(t.type)) && (t._vModifiers = e.modifiers, e.modifiers.lazy || (t.addEventListener("compositionstart", Ps), t.addEventListener("compositionend", Ms), t.addEventListener("change", Ms), rt && (t.vmodel = !0))) }, componentUpdated: function (t, e, r) { if ("select" === r.tag) { As(t, e, r.context); var i = t._vOptions, n = t._vOptions = [].map.call(t.options, Is); if (n.some((function (t, e) { return !k(t, i[e]) }))) { var o = t.multiple ? e.value.some((function (t) { return Os(t, n) })) : e.value !== e.oldValue && Os(e.value, n); o && Cs(t, "change") } } } }; function As(t, e, r) { Rs(t, e, r), (et || it) && setTimeout((function () { Rs(t, e, r) }), 0) } function Rs(t, e, r) { var i = e.value, n = t.multiple; if (!n || Array.isArray(i)) { for (var o, s, a = 0, u = t.options.length; a < u; a++)if (s = t.options[a], n) o = G(i, Is(s)) > -1, s.selected !== o && (s.selected = o); else if (k(Is(s), i)) return void (t.selectedIndex !== a && (t.selectedIndex = a)); n || (t.selectedIndex = -1) } } function Os(t, e) { return e.every((function (e) { return !k(e, t) })) } function Is(t) { return "_value" in t ? t._value : t.value } function Ps(t) { t.target.composing = !0 } function Ms(t) { t.target.composing && (t.target.composing = !1, Cs(t.target, "input")) } function Cs(t, e) { var r = document.createEvent("HTMLEvents"); r.initEvent(e, !0, !0), t.dispatchEvent(r) } function Ds(t) { return !t.componentInstance || t.data && t.data.transition ? t : Ds(t.componentInstance._vnode) } var Ls = { bind: function (t, e, r) { var i = e.value; r = Ds(r); var n = r.data && r.data.transition, o = t.__vOriginalDisplay = "none" === t.style.display ? "" : t.style.display; i && n ? (r.data.show = !0, ms(r, (function () { t.style.display = o }))) : t.style.display = i ? o : "none" }, update: function (t, e, r) { var i = e.value, n = e.oldValue; if (!i !== !n) { r = Ds(r); var o = r.data && r.data.transition; o ? (r.data.show = !0, i ? ms(r, (function () { t.style.display = t.__vOriginalDisplay })) : gs(r, (function () { t.style.display = "none" }))) : t.style.display = i ? t.__vOriginalDisplay : "none" } }, unbind: function (t, e, r, i, n) { n || (t.style.display = t.__vOriginalDisplay) } }, Fs = { model: ws, show: Ls }, Ns = { name: String, appear: Boolean, css: Boolean, mode: String, type: String, enterClass: String, leaveClass: String, enterToClass: String, leaveToClass: String, enterActiveClass: String, leaveActiveClass: String, appearClass: String, appearActiveClass: String, appearToClass: String, duration: [Number, String, Object] }; function Bs(t) { var e = t && t.componentOptions; return e && e.Ctor.options.abstract ? Bs(Xe(e.children)) : t } function Us(t) { var e = {}, r = t.$options; for (var i in r.propsData) e[i] = t[i]; var n = r._parentListeners; for (var i in n) e[A(i)] = n[i]; return e } function ks(t, e) { if (/\d-keep-alive$/.test(e.tag)) return t("keep-alive", { props: e.componentOptions.propsData }) } function Gs(t) { while (t = t.parent) if (t.data.transition) return !0 } function Xs(t, e) { return e.key === t.key && e.tag === t.tag } var js = function (t) { return t.tag || we(t) }, Hs = function (t) { return "show" === t.name }, Vs = { name: "transition", props: Ns, abstract: !0, render: function (t) { var e = this, r = this.$slots.default; if (r && (r = r.filter(js), r.length)) { 0; var i = this.mode; 0; var n = r[0]; if (Gs(this.$vnode)) return n; var o = Bs(n); if (!o) return n; if (this._leaving) return ks(t, n); var s = "__transition-".concat(this._uid, "-"); o.key = null == o.key ? o.isComment ? s + "comment" : s + o.tag : h(o.key) ? 0 === String(o.key).indexOf(s) ? o.key : s + o.key : o.key; var a = (o.data || (o.data = {})).transition = Us(this), u = this._vnode, l = Bs(u); if (o.data.directives && o.data.directives.some(Hs) && (o.data.show = !0), l && l.data && !Xs(o, l) && !we(l) && (!l.componentInstance || !l.componentInstance._vnode.isComment)) { var c = l.data.transition = L({}, a); if ("out-in" === i) return this._leaving = !0, ee(c, "afterLeave", (function () { e._leaving = !1, e.$forceUpdate() })), ks(t, n); if ("in-out" === i) { if (we(o)) return u; var d, f = function () { d() }; ee(a, "afterEnter", f), ee(a, "enterCancelled", f), ee(c, "delayLeave", (function (t) { d = t })) } } return n } } }, zs = L({ tag: String, moveClass: String }, Ns); delete zs.mode; var Ys = { props: zs, beforeMount: function () { var t = this, e = this._update; this._update = function (r, i) { var n = Sr(t); t.__patch__(t._vnode, t.kept, !1, !0), t._vnode = t.kept, n(), e.call(t, r, i) } }, render: function (t) { for (var e = this.tag || this.$vnode.data.tag || "span", r = Object.create(null), i = this.prevChildren = this.children, n = this.$slots.default || [], o = this.children = [], s = Us(this), a = 0; a < n.length; a++) { var u = n[a]; if (u.tag) if (null != u.key && 0 !== String(u.key).indexOf("__vlist")) o.push(u), r[u.key] = u, (u.data || (u.data = {})).transition = s; else; } if (i) { var h = [], l = []; for (a = 0; a < i.length; a++) { u = i[a]; u.data.transition = s, u.data.pos = u.elm.getBoundingClientRect(), r[u.key] ? h.push(u) : l.push(u) } this.kept = t(e, null, h), this.removed = l } return t(e, null, o) }, updated: function () { var t = this.prevChildren, e = this.moveClass || (this.name || "v") + "-move"; t.length && this.hasMove(t[0].elm, e) && (t.forEach(Ws), t.forEach($s), t.forEach(qs), this._reflow = document.body.offsetHeight, t.forEach((function (t) { if (t.data.moved) { var r = t.elm, i = r.style; hs(r, e), i.transform = i.WebkitTransform = i.transitionDuration = "", r.addEventListener(ns, r._moveCb = function t(i) { i && i.target !== r || i && !/transform$/.test(i.propertyName) || (r.removeEventListener(ns, t), r._moveCb = null, ls(r, e)) }) } }))) }, methods: { hasMove: function (t, e) { if (!ts) return !1; if (this._hasMove) return this._hasMove; var r = t.cloneNode(); t._transitionClasses && t._transitionClasses.forEach((function (t) { Zo(r, t) })), Ko(r, e), r.style.display = "none", this.$el.appendChild(r); var i = fs(r); return this.$el.removeChild(r), this._hasMove = i.hasTransform } } }; function Ws(t) { t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb() } function $s(t) { t.data.newPos = t.elm.getBoundingClientRect() } function qs(t) { var e = t.data.pos, r = t.data.newPos, i = e.left - r.left, n = e.top - r.top; if (i || n) { t.data.moved = !0; var o = t.elm.style; o.transform = o.WebkitTransform = "translate(".concat(i, "px,").concat(n, "px)"), o.transitionDuration = "0s" } } var Ks = { Transition: Vs, TransitionGroup: Ys }; qi.config.mustUseProp = fn, qi.config.isReservedTag = Cn, qi.config.isReservedAttr = cn, qi.config.getTagNamespace = Dn, qi.config.isUnknownElement = Fn, L(qi.options.directives, Fs), L(qi.options.components, Ks), qi.prototype.__patch__ = Q ? Ss : N, qi.prototype.$mount = function (t, e) { return t = t && Q ? Bn(t) : void 0, Rr(this, t, e) }, Q && setTimeout((function () { Y.devtools && ct && ct.emit("init", qi) }), 0) }, 8676: function (t, e, r) {
        "use strict";
        /*!
         * @pixi/constants - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * @pixi/constants is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        var i, n, o, s, a, u, h, l, c, d, f, p, _, m, g, v, y, b, x, T; r.d(e, { A7: function () { return y }, G5: function () { return x }, I2: function () { return u }, N3: function () { return n }, Nt: function () { return f }, T$: function () { return s }, UN: function () { return g }, V0: function () { return o }, V3: function () { return b }, Vi: function () { return i }, WB: function () { return p }, aH: function () { return d }, cB: function () { return v }, iw: function () { return _ }, lg: function () { return a }, mr: function () { return T }, oT: function () { return c }, sp: function () { return h }, vK: function () { return l }, yl: function () { return m } }), function (t) { t[t["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY", t[t["WEBGL"] = 1] = "WEBGL", t[t["WEBGL2"] = 2] = "WEBGL2" }(i || (i = {})), function (t) { t[t["UNKNOWN"] = 0] = "UNKNOWN", t[t["WEBGL"] = 1] = "WEBGL", t[t["CANVAS"] = 2] = "CANVAS" }(n || (n = {})), function (t) { t[t["COLOR"] = 16384] = "COLOR", t[t["DEPTH"] = 256] = "DEPTH", t[t["STENCIL"] = 1024] = "STENCIL" }(o || (o = {})), function (t) { t[t["NORMAL"] = 0] = "NORMAL", t[t["ADD"] = 1] = "ADD", t[t["MULTIPLY"] = 2] = "MULTIPLY", t[t["SCREEN"] = 3] = "SCREEN", t[t["OVERLAY"] = 4] = "OVERLAY", t[t["DARKEN"] = 5] = "DARKEN", t[t["LIGHTEN"] = 6] = "LIGHTEN", t[t["COLOR_DODGE"] = 7] = "COLOR_DODGE", t[t["COLOR_BURN"] = 8] = "COLOR_BURN", t[t["HARD_LIGHT"] = 9] = "HARD_LIGHT", t[t["SOFT_LIGHT"] = 10] = "SOFT_LIGHT", t[t["DIFFERENCE"] = 11] = "DIFFERENCE", t[t["EXCLUSION"] = 12] = "EXCLUSION", t[t["HUE"] = 13] = "HUE", t[t["SATURATION"] = 14] = "SATURATION", t[t["COLOR"] = 15] = "COLOR", t[t["LUMINOSITY"] = 16] = "LUMINOSITY", t[t["NORMAL_NPM"] = 17] = "NORMAL_NPM", t[t["ADD_NPM"] = 18] = "ADD_NPM", t[t["SCREEN_NPM"] = 19] = "SCREEN_NPM", t[t["NONE"] = 20] = "NONE", t[t["SRC_OVER"] = 0] = "SRC_OVER", t[t["SRC_IN"] = 21] = "SRC_IN", t[t["SRC_OUT"] = 22] = "SRC_OUT", t[t["SRC_ATOP"] = 23] = "SRC_ATOP", t[t["DST_OVER"] = 24] = "DST_OVER", t[t["DST_IN"] = 25] = "DST_IN", t[t["DST_OUT"] = 26] = "DST_OUT", t[t["DST_ATOP"] = 27] = "DST_ATOP", t[t["ERASE"] = 26] = "ERASE", t[t["SUBTRACT"] = 28] = "SUBTRACT", t[t["XOR"] = 29] = "XOR" }(s || (s = {})), function (t) { t[t["POINTS"] = 0] = "POINTS", t[t["LINES"] = 1] = "LINES", t[t["LINE_LOOP"] = 2] = "LINE_LOOP", t[t["LINE_STRIP"] = 3] = "LINE_STRIP", t[t["TRIANGLES"] = 4] = "TRIANGLES", t[t["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP", t[t["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN" }(a || (a = {})), function (t) { t[t["RGBA"] = 6408] = "RGBA", t[t["RGB"] = 6407] = "RGB", t[t["RG"] = 33319] = "RG", t[t["RED"] = 6403] = "RED", t[t["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER", t[t["RGB_INTEGER"] = 36248] = "RGB_INTEGER", t[t["RG_INTEGER"] = 33320] = "RG_INTEGER", t[t["RED_INTEGER"] = 36244] = "RED_INTEGER", t[t["ALPHA"] = 6406] = "ALPHA", t[t["LUMINANCE"] = 6409] = "LUMINANCE", t[t["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA", t[t["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT", t[t["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL" }(u || (u = {})), function (t) { t[t["TEXTURE_2D"] = 3553] = "TEXTURE_2D", t[t["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP", t[t["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY", t[t["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z" }(h || (h = {})), function (t) { t[t["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE", t[t["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT", t[t["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5", t[t["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT", t[t["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8", t[t["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t["BYTE"] = 5120] = "BYTE", t[t["SHORT"] = 5122] = "SHORT", t[t["INT"] = 5124] = "INT", t[t["FLOAT"] = 5126] = "FLOAT", t[t["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t["HALF_FLOAT"] = 36193] = "HALF_FLOAT" }(l || (l = {})), function (t) { t[t["FLOAT"] = 0] = "FLOAT", t[t["INT"] = 1] = "INT", t[t["UINT"] = 2] = "UINT" }(c || (c = {})), function (t) { t[t["NEAREST"] = 0] = "NEAREST", t[t["LINEAR"] = 1] = "LINEAR" }(d || (d = {})), function (t) { t[t["CLAMP"] = 33071] = "CLAMP", t[t["REPEAT"] = 10497] = "REPEAT", t[t["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT" }(f || (f = {})), function (t) { t[t["OFF"] = 0] = "OFF", t[t["POW2"] = 1] = "POW2", t[t["ON"] = 2] = "ON", t[t["ON_MANUAL"] = 3] = "ON_MANUAL" }(p || (p = {})), function (t) { t[t["NPM"] = 0] = "NPM", t[t["UNPACK"] = 1] = "UNPACK", t[t["PMA"] = 2] = "PMA", t[t["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA", t[t["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD", t[t["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA", t[t["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA" }(_ || (_ = {})), function (t) { t[t["NO"] = 0] = "NO", t[t["YES"] = 1] = "YES", t[t["AUTO"] = 2] = "AUTO", t[t["BLEND"] = 0] = "BLEND", t[t["CLEAR"] = 1] = "CLEAR", t[t["BLIT"] = 2] = "BLIT" }(m || (m = {})), function (t) { t[t["AUTO"] = 0] = "AUTO", t[t["MANUAL"] = 1] = "MANUAL" }(g || (g = {})), function (t) { t["LOW"] = "lowp", t["MEDIUM"] = "mediump", t["HIGH"] = "highp" }(v || (v = {})), function (t) { t[t["NONE"] = 0] = "NONE", t[t["SCISSOR"] = 1] = "SCISSOR", t[t["STENCIL"] = 2] = "STENCIL", t[t["SPRITE"] = 3] = "SPRITE", t[t["COLOR"] = 4] = "COLOR" }(y || (y = {})), function (t) { t[t["RED"] = 1] = "RED", t[t["GREEN"] = 2] = "GREEN", t[t["BLUE"] = 4] = "BLUE", t[t["ALPHA"] = 8] = "ALPHA" }(b || (b = {})), function (t) { t[t["NONE"] = 0] = "NONE", t[t["LOW"] = 2] = "LOW", t[t["MEDIUM"] = 4] = "MEDIUM", t[t["HIGH"] = 8] = "HIGH" }(x || (x = {})), function (t) { t[t["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER", t[t["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER", t[t["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER" }(T || (T = {}))
    }, 1493: function (t, e, r) {
        "use strict"; r.d(e, { $N: function () { return x }, $r: function () { return Xt }, AI: function () { return M }, Bv: function () { return ar }, CT: function () { return ke }, DL: function () { return ve }, Ei: function () { return xe }, HI: function () { return ct }, I8: function () { return je }, Ie: function () { return Qe }, J$: function () { return fe }, JZ: function () { return ir }, Jb: function () { return ur }, K0: function () { return ye }, Kc: function () { return bt }, Ld: function () { return he }, M4: function () { return b }, NW: function () { return le }, PA: function () { return w }, Rv: function () { return tr }, Rw: function () { return s.R }, Sj: function () { return it }, TA: function () { return S }, TF: function () { return ge }, TI: function () { return B }, TJ: function () { return sr }, TO: function () { return lt }, Th: function () { return ze }, UX: function () { return re }, VL: function () { return y }, W1: function () { return be }, WB: function () { return ut }, Y8: function () { return E }, Y9: function () { return Ke }, ZM: function () { return qt }, ZX: function () { return W }, Zk: function () { return rr }, _w: function () { return O }, _z: function () { return m }, a$: function () { return Je }, a7: function () { return Ft }, aF: function () { return D }, ah: function () { return k }, bO: function () { return rt }, bg: function () { return T }, e6: function () { return Ye }, eG: function () { return cr }, eH: function () { return R }, e_: function () { return l }, eo: function () { return er }, ex: function () { return jt }, fy: function () { return Ue }, id: function () { return ue }, jV: function () { return J }, jd: function () { return C }, kP: function () { return qe }, kV: function () { return et }, lD: function () { return $ }, lH: function () { return ot }, lW: function () { return X }, nw: function () { return s.n }, oo: function () { return Z }, p: function () { return Re }, pX: function () { return A }, pb: function () { return c }, q4: function () { return fr }, qm: function () { return g }, qw: function () { return Se }, sg: function () { return Ot }, tT: function () { return st }, uW: function () { return U }, ud: function () { return q }, wn: function () { return Jt }, wr: function () { return Ne }, xE: function () { return N }, xP: function () { return Ze }, z9: function () { return ie }, zI: function () { return Fe }, zj: function () { return ne } }); r(3767), r(8585), r(8696), r(7658), r(2801); var i = r(950), n = r(8676), o = r(5506), s = r(3640), a = r(1922), u = r(6565), h = r(565);
        /*!
         * @pixi/core - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * @pixi/core is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        i.Xd.PREFER_ENV = o.isMobile.any ? n.Vi.WEBGL : n.Vi.WEBGL2, i.Xd.STRICT_TEXTURE_CACHE = !1; var l = []; function c(t, e) { if (!t) return null; var r = ""; if ("string" === typeof t) { var i = /\.(\w{3,4})(?:$|\?|#)/i.exec(t); i && (r = i[1].toLowerCase()) } for (var n = l.length - 1; n >= 0; --n) { var o = l[n]; if (o.test && o.test(t, r)) return new o(t, e) } throw new Error("Unrecognized source type to auto-detect Resource") }
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var d = function (t, e) { return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, d(t, e) }; function f(t, e) { function r() { this.constructor = t } d(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var p = function () { return p = Object.assign || function (t) { for (var e, r = arguments, i = 1, n = arguments.length; i < n; i++)for (var o in e = r[i], e) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]); return t }, p.apply(this, arguments) }; function _(t, e) { var r = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]); if (null != t && "function" === typeof Object.getOwnPropertySymbols) { var n = 0; for (i = Object.getOwnPropertySymbols(t); n < i.length; n++)e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[n]) && (r[i[n]] = t[i[n]]) } return r } var m = function () { function t(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new a.R("setRealSize"), this.onUpdate = new a.R("update"), this.onError = new a.R("onError") } return t.prototype.bind = function (t) { this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height) }, t.prototype.unbind = function (t) { this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t) }, t.prototype.resize = function (t, e) { t === this._width && e === this._height || (this._width = t, this._height = e, this.onResize.emit(t, e)) }, Object.defineProperty(t.prototype, "valid", { get: function () { return !!this._width && !!this._height }, enumerable: !1, configurable: !0 }), t.prototype.update = function () { this.destroyed || this.onUpdate.emit() }, t.prototype.load = function () { return Promise.resolve(this) }, Object.defineProperty(t.prototype, "width", { get: function () { return this._width }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "height", { get: function () { return this._height }, enumerable: !1, configurable: !0 }), t.prototype.style = function (t, e, r) { return !1 }, t.prototype.dispose = function () { }, t.prototype.destroy = function () { this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null) }, t.test = function (t, e) { return !1 }, t }(), g = function (t) { function e(e, r) { var i = this, n = r || {}, o = n.width, s = n.height; if (!o || !s) throw new Error("BufferResource width or height invalid"); return i = t.call(this, o, s) || this, i.data = e, i } return f(e, t), e.prototype.upload = function (t, e, r) { var i = t.gl; i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === n.iw.UNPACK); var o = e.realWidth, s = e.realHeight; return r.width === o && r.height === s ? i.texSubImage2D(e.target, 0, 0, 0, o, s, e.format, r.type, this.data) : (r.width = o, r.height = s, i.texImage2D(e.target, 0, r.internalFormat, o, s, 0, e.format, r.type, this.data)), !0 }, e.prototype.dispose = function () { this.data = null }, e.test = function (t) { return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array }, e }(m), v = { scaleMode: n.aH.NEAREST, format: n.I2.RGBA, alphaMode: n.iw.NPM }, y = function (t) { function e(e, r) { void 0 === e && (e = null), void 0 === r && (r = null); var s = t.call(this) || this; r = r || {}; var a = r.alphaMode, u = r.mipmap, h = r.anisotropicLevel, l = r.scaleMode, d = r.width, f = r.height, p = r.wrapMode, _ = r.format, g = r.type, v = r.target, y = r.resolution, b = r.resourceOptions; return !e || e instanceof m || (e = c(e, b), e.internal = !0), s.resolution = y || i.Xd.RESOLUTION, s.width = Math.round((d || 0) * s.resolution) / s.resolution, s.height = Math.round((f || 0) * s.resolution) / s.resolution, s._mipmap = void 0 !== u ? u : i.Xd.MIPMAP_TEXTURES, s.anisotropicLevel = void 0 !== h ? h : i.Xd.ANISOTROPIC_LEVEL, s._wrapMode = p || i.Xd.WRAP_MODE, s._scaleMode = void 0 !== l ? l : i.Xd.SCALE_MODE, s.format = _ || n.I2.RGBA, s.type = g || n.vK.UNSIGNED_BYTE, s.target = v || n.sp.TEXTURE_2D, s.alphaMode = void 0 !== a ? a : n.iw.UNPACK, s.uid = (0, o.uid)(), s.touched = 0, s.isPowerOfTwo = !1, s._refreshPOT(), s._glTextures = {}, s.dirtyId = 0, s.dirtyStyleId = 0, s.cacheId = null, s.valid = d > 0 && f > 0, s.textureCacheIds = [], s.destroyed = !1, s.resource = null, s._batchEnabled = 0, s._batchLocation = 0, s.parentTextureArray = null, s.setResource(e), s } return f(e, t), Object.defineProperty(e.prototype, "realWidth", { get: function () { return Math.round(this.width * this.resolution) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "realHeight", { get: function () { return Math.round(this.height * this.resolution) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "mipmap", { get: function () { return this._mipmap }, set: function (t) { this._mipmap !== t && (this._mipmap = t, this.dirtyStyleId++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "scaleMode", { get: function () { return this._scaleMode }, set: function (t) { this._scaleMode !== t && (this._scaleMode = t, this.dirtyStyleId++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "wrapMode", { get: function () { return this._wrapMode }, set: function (t) { this._wrapMode !== t && (this._wrapMode = t, this.dirtyStyleId++) }, enumerable: !1, configurable: !0 }), e.prototype.setStyle = function (t, e) { var r; return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t, r = !0), void 0 !== e && e !== this.mipmap && (this.mipmap = e, r = !0), r && this.dirtyStyleId++, this }, e.prototype.setSize = function (t, e, r) { return r = r || this.resolution, this.setRealSize(t * r, e * r, r) }, e.prototype.setRealSize = function (t, e, r) { return this.resolution = r || this.resolution, this.width = Math.round(t) / this.resolution, this.height = Math.round(e) / this.resolution, this._refreshPOT(), this.update(), this }, e.prototype._refreshPOT = function () { this.isPowerOfTwo = (0, o.isPow2)(this.realWidth) && (0, o.isPow2)(this.realHeight) }, e.prototype.setResolution = function (t) { var e = this.resolution; return e === t || (this.resolution = t, this.valid && (this.width = Math.round(this.width * e) / t, this.height = Math.round(this.height * e) / t, this.emit("update", this)), this._refreshPOT()), this }, e.prototype.setResource = function (t) { if (this.resource === t) return this; if (this.resource) throw new Error("Resource can be set only once"); return t.bind(this), this.resource = t, this }, e.prototype.update = function () { this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this)) }, e.prototype.onError = function (t) { this.emit("error", this, t) }, e.prototype.destroy = function () { this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete o.BaseTextureCache[this.cacheId], delete o.TextureCache[this.cacheId], this.cacheId = null), this.dispose(), e.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0 }, e.prototype.dispose = function () { this.emit("dispose", this) }, e.prototype.castToBaseTexture = function () { return this }, e.from = function (t, r, n) { void 0 === n && (n = i.Xd.STRICT_TEXTURE_CACHE); var s = "string" === typeof t, a = null; if (s) a = t; else { if (!t._pixiId) { var u = r && r.pixiIdPrefix || "pixiid"; t._pixiId = u + "_" + (0, o.uid)() } a = t._pixiId } var h = o.BaseTextureCache[a]; if (s && n && !h) throw new Error('The cacheId "' + a + '" does not exist in BaseTextureCache.'); return h || (h = new e(t, r), h.cacheId = a, e.addToCache(h, a)), h }, e.fromBuffer = function (t, r, i, o) { t = t || new Float32Array(r * i * 4); var s = new g(t, { width: r, height: i }), a = t instanceof Float32Array ? n.vK.FLOAT : n.vK.UNSIGNED_BYTE; return new e(s, Object.assign({}, v, o || { width: r, height: i, type: a })) }, e.addToCache = function (t, e) { e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), o.BaseTextureCache[e] && console.warn("BaseTexture added to the cache with an id [" + e + "] that already had an entry"), o.BaseTextureCache[e] = t) }, e.removeFromCache = function (t) { if ("string" === typeof t) { var e = o.BaseTextureCache[t]; if (e) { var r = e.textureCacheIds.indexOf(t); return r > -1 && e.textureCacheIds.splice(r, 1), delete o.BaseTextureCache[t], e } } else if (t && t.textureCacheIds) { for (var i = 0; i < t.textureCacheIds.length; ++i)delete o.BaseTextureCache[t.textureCacheIds[i]]; return t.textureCacheIds.length = 0, t } return null }, e._globalBatch = 0, e }(o.EventEmitter), b = function (t) { function e(e, r) { var i = this, n = r || {}, o = n.width, s = n.height; i = t.call(this, o, s) || this, i.items = [], i.itemDirtyIds = []; for (var a = 0; a < e; a++) { var u = new y; i.items.push(u), i.itemDirtyIds.push(-2) } return i.length = e, i._load = null, i.baseTexture = null, i } return f(e, t), e.prototype.initFromArray = function (t, e) { for (var r = 0; r < this.length; r++)t[r] && (t[r].castToBaseTexture ? this.addBaseTextureAt(t[r].castToBaseTexture(), r) : t[r] instanceof m ? this.addResourceAt(t[r], r) : this.addResourceAt(c(t[r], e), r)) }, e.prototype.dispose = function () { for (var t = 0, e = this.length; t < e; t++)this.items[t].destroy(); this.items = null, this.itemDirtyIds = null, this._load = null }, e.prototype.addResourceAt = function (t, e) { if (!this.items[e]) throw new Error("Index " + e + " is out of bounds"); return t.valid && !this.valid && this.resize(t.width, t.height), this.items[e].setResource(t), this }, e.prototype.bind = function (e) { if (null !== this.baseTexture) throw new Error("Only one base texture per TextureArray is allowed"); t.prototype.bind.call(this, e); for (var r = 0; r < this.length; r++)this.items[r].parentTextureArray = e, this.items[r].on("update", e.update, e) }, e.prototype.unbind = function (e) { t.prototype.unbind.call(this, e); for (var r = 0; r < this.length; r++)this.items[r].parentTextureArray = null, this.items[r].off("update", e.update, e) }, e.prototype.load = function () { var t = this; if (this._load) return this._load; var e = this.items.map((function (t) { return t.resource })).filter((function (t) { return t })), r = e.map((function (t) { return t.load() })); return this._load = Promise.all(r).then((function () { var e = t.items[0], r = e.realWidth, i = e.realHeight; return t.resize(r, i), Promise.resolve(t) })), this._load }, e }(m), x = function (t) { function e(e, r) { var i, n, o = this, s = r || {}, a = s.width, u = s.height; return Array.isArray(e) ? (i = e, n = e.length) : n = e, o = t.call(this, n, { width: a, height: u }) || this, i && o.initFromArray(i, r), o } return f(e, t), e.prototype.addBaseTextureAt = function (t, e) { if (!t.resource) throw new Error("ArrayResource does not support RenderTexture"); return this.addResourceAt(t.resource, e), this }, e.prototype.bind = function (e) { t.prototype.bind.call(this, e), e.target = n.sp.TEXTURE_2D_ARRAY }, e.prototype.upload = function (t, e, r) { var i = this, n = i.length, o = i.itemDirtyIds, s = i.items, a = t.gl; r.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, r.internalFormat, this._width, this._height, n, 0, e.format, r.type, null); for (var u = 0; u < n; u++) { var h = s[u]; o[u] < h.dirtyId && (o[u] = h.dirtyId, h.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, u, h.resource.width, h.resource.height, 1, e.format, r.type, h.resource.source)) } return !0 }, e }(b), T = function (t) { function e(e) { var r = this, i = e, n = i.naturalWidth || i.videoWidth || i.width, o = i.naturalHeight || i.videoHeight || i.height; return r = t.call(this, n, o) || this, r.source = e, r.noSubImage = !1, r } return f(e, t), e.crossOrigin = function (t, e, r) { void 0 === r && 0 !== e.indexOf("data:") ? t.crossOrigin = (0, o.determineCrossOrigin)(e) : !1 !== r && (t.crossOrigin = "string" === typeof r ? r : "anonymous") }, e.prototype.upload = function (t, e, r, i) { var o = t.gl, s = e.realWidth, a = e.realHeight; if (i = i || this.source, i instanceof HTMLImageElement) { if (!i.complete || 0 === i.naturalWidth) return !1 } else if (i instanceof HTMLVideoElement && i.readyState <= 1) return !1; return o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === n.iw.UNPACK), this.noSubImage || e.target !== o.TEXTURE_2D || r.width !== s || r.height !== a ? (r.width = s, r.height = a, o.texImage2D(e.target, 0, r.internalFormat, e.format, r.type, i)) : o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, e.format, r.type, i), !0 }, e.prototype.update = function () { if (!this.destroyed) { var e = this.source, r = e.naturalWidth || e.videoWidth || e.width, i = e.naturalHeight || e.videoHeight || e.height; this.resize(r, i), t.prototype.update.call(this) } }, e.prototype.dispose = function () { this.source = null }, e }(m), E = function (t) { function e(e) { return t.call(this, e) || this } return f(e, t), e.test = function (t) { var e = globalThis.OffscreenCanvas; return !!(e && t instanceof e) || globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement }, e }(T), S = function (t) { function e(r, i) { var o = this, s = i || {}, a = s.width, u = s.height, h = s.autoLoad, l = s.linkBaseTexture; if (r && r.length !== e.SIDES) throw new Error("Invalid length. Got " + r.length + ", expected 6"); o = t.call(this, 6, { width: a, height: u }) || this; for (var c = 0; c < e.SIDES; c++)o.items[c].target = n.sp.TEXTURE_CUBE_MAP_POSITIVE_X + c; return o.linkBaseTexture = !1 !== l, r && o.initFromArray(r, i), !1 !== h && o.load(), o } return f(e, t), e.prototype.bind = function (e) { t.prototype.bind.call(this, e), e.target = n.sp.TEXTURE_CUBE_MAP }, e.prototype.addBaseTextureAt = function (t, e, r) { if (!this.items[e]) throw new Error("Index " + e + " is out of bounds"); if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0) { if (!t.resource) throw new Error("CubeResource does not support copying of renderTexture."); this.addResourceAt(t.resource, e) } else t.target = n.sp.TEXTURE_CUBE_MAP_POSITIVE_X + e, t.parentTextureArray = this.baseTexture, this.items[e] = t; return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight), this.items[e] = t, this }, e.prototype.upload = function (t, r, i) { for (var n = this.itemDirtyIds, o = 0; o < e.SIDES; o++) { var s = this.items[o]; (n[o] < s.dirtyId || i.dirtyId < r.dirtyId) && (s.valid && s.resource ? (s.resource.upload(t, s, i), n[o] = s.dirtyId) : n[o] < -1 && (t.gl.texImage2D(s.target, 0, i.internalFormat, r.realWidth, r.realHeight, 0, r.format, i.type, null), n[o] = -1)) } return !0 }, e.test = function (t) { return Array.isArray(t) && t.length === e.SIDES }, e.SIDES = 6, e }(b), w = function (t) { function e(e, r) { var n = this; if (r = r || {}, !(e instanceof HTMLImageElement)) { var o = new Image; T.crossOrigin(o, e, r.crossorigin), o.src = e, e = o } return n = t.call(this, e) || this, !e.complete && n._width && n._height && (n._width = 0, n._height = 0), n.url = e.src, n._process = null, n.preserveBitmap = !1, n.createBitmap = (void 0 !== r.createBitmap ? r.createBitmap : i.Xd.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, n.alphaMode = "number" === typeof r.alphaMode ? r.alphaMode : null, n.bitmap = null, n._load = null, !1 !== r.autoLoad && n.load(), n } return f(e, t), e.prototype.load = function (t) { var e = this; return this._load || (void 0 !== t && (this.createBitmap = t), this._load = new Promise((function (t, r) { var i = e.source; e.url = i.src; var n = function () { e.destroyed || (i.onload = null, i.onerror = null, e.resize(i.width, i.height), e._load = null, e.createBitmap ? t(e.process()) : t(e)) }; i.complete && i.src ? n() : (i.onload = n, i.onerror = function (t) { r(t), e.onError.emit(t) }) }))), this._load }, e.prototype.process = function () { var t = this, e = this.source; if (null !== this._process) return this._process; if (null !== this.bitmap || !globalThis.createImageBitmap) return Promise.resolve(this); var r = globalThis.createImageBitmap, i = !e.crossOrigin || "anonymous" === e.crossOrigin; return this._process = fetch(e.src, { mode: i ? "cors" : "no-cors" }).then((function (t) { return t.blob() })).then((function (i) { return r(i, 0, 0, e.width, e.height, { premultiplyAlpha: null === t.alphaMode || t.alphaMode === n.iw.UNPACK ? "premultiply" : "none" }) })).then((function (e) { return t.destroyed ? Promise.reject() : (t.bitmap = e, t.update(), t._process = null, Promise.resolve(t)) })), this._process }, e.prototype.upload = function (e, r, i) { if ("number" === typeof this.alphaMode && (r.alphaMode = this.alphaMode), !this.createBitmap) return t.prototype.upload.call(this, e, r, i); if (!this.bitmap && (this.process(), !this.bitmap)) return !1; if (t.prototype.upload.call(this, e, r, i, this.bitmap), !this.preserveBitmap) { var n = !0, o = r._glTextures; for (var s in o) { var a = o[s]; if (a !== i && a.dirtyId !== r.dirtyId) { n = !1; break } } n && (this.bitmap.close && this.bitmap.close(), this.bitmap = null) } return !0 }, e.prototype.dispose = function () { this.source.onload = null, this.source.onerror = null, t.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null }, e.test = function (t) { return "string" === typeof t || t instanceof HTMLImageElement }, e }(T), A = function (t) { function e(e, r) { var n = this; return r = r || {}, n = t.call(this, i.Xd.ADAPTER.createCanvas()) || this, n._width = 0, n._height = 0, n.svg = e, n.scale = r.scale || 1, n._overrideWidth = r.width, n._overrideHeight = r.height, n._resolve = null, n._crossorigin = r.crossorigin, n._load = null, !1 !== r.autoLoad && n.load(), n } return f(e, t), e.prototype.load = function () { var t = this; return this._load || (this._load = new Promise((function (r) { if (t._resolve = function () { t.resize(t.source.width, t.source.height), r(t) }, e.SVG_XML.test(t.svg.trim())) { if (!btoa) throw new Error("Your browser doesn't support base64 conversions."); t.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t.svg))) } t._loadSvg() }))), this._load }, e.prototype._loadSvg = function () { var t = this, e = new Image; T.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = function (r) { t._resolve && (e.onerror = null, t.onError.emit(r)) }, e.onload = function () { if (t._resolve) { var r = e.width, i = e.height; if (!r || !i) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them."); var n = r * t.scale, s = i * t.scale; (t._overrideWidth || t._overrideHeight) && (n = t._overrideWidth || t._overrideHeight / i * r, s = t._overrideHeight || t._overrideWidth / r * i), n = Math.round(n), s = Math.round(s); var a = t.source; a.width = n, a.height = s, a._pixiId = "canvas_" + (0, o.uid)(), a.getContext("2d").drawImage(e, 0, 0, r, i, 0, 0, n, s), t._resolve(), t._resolve = null } } }, e.getSize = function (t) { var r = e.SVG_SIZE.exec(t), i = {}; return r && (i[r[1]] = Math.round(parseFloat(r[3])), i[r[5]] = Math.round(parseFloat(r[7]))), i }, e.prototype.dispose = function () { t.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null }, e.test = function (t, r) { return "svg" === r || "string" === typeof t && t.startsWith("data:image/svg+xml") || "string" === typeof t && e.SVG_XML.test(t) }, e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, e.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e }(T), R = function (t) { function e(r, i) { var n = this; if (i = i || {}, !(r instanceof HTMLVideoElement)) { var o = document.createElement("video"); o.setAttribute("preload", "auto"), o.setAttribute("webkit-playsinline", ""), o.setAttribute("playsinline", ""), "string" === typeof r && (r = [r]); var s = r[0].src || r[0]; T.crossOrigin(o, s, i.crossorigin); for (var a = 0; a < r.length; ++a) { var u = document.createElement("source"), h = r[a], l = h.src, c = h.mime; l = l || r[a]; var d = l.split("?").shift().toLowerCase(), f = d.slice(d.lastIndexOf(".") + 1); c = c || e.MIME_TYPES[f] || "video/" + f, u.src = l, u.type = c, o.appendChild(u) } r = o } return n = t.call(this, r) || this, n.noSubImage = !0, n._autoUpdate = !0, n._isConnectedToTicker = !1, n._updateFPS = i.updateFPS || 0, n._msToNextUpdate = 0, n.autoPlay = !1 !== i.autoPlay, n._load = null, n._resolve = null, n._onCanPlay = n._onCanPlay.bind(n), n._onError = n._onError.bind(n), !1 !== i.autoLoad && n.load(), n } return f(e, t), e.prototype.update = function (e) { if (!this.destroyed) { var r = u.vB.shared.elapsedMS * this.source.playbackRate; this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (t.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0) } }, e.prototype.load = function () { var t = this; if (this._load) return this._load; var e = this.source; return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise((function (r) { t.valid ? r(t) : (t._resolve = r, e.load()) })), this._load }, e.prototype._onError = function (t) { this.source.removeEventListener("error", this._onError, !0), this.onError.emit(t) }, e.prototype._isSourcePlaying = function () { var t = this.source; return !t.paused && !t.ended && this._isSourceReady() }, e.prototype._isSourceReady = function () { var t = this.source; return t.readyState > 2 }, e.prototype._onPlayStart = function () { this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (u.vB.shared.add(this.update, this), this._isConnectedToTicker = !0) }, e.prototype._onPlayStop = function () { this._isConnectedToTicker && (u.vB.shared.remove(this.update, this), this._isConnectedToTicker = !1) }, e.prototype._onCanPlay = function () { var t = this.source; t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlay); var e = this.valid; this.resize(t.videoWidth, t.videoHeight), !e && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play() }, e.prototype.dispose = function () { this._isConnectedToTicker && (u.vB.shared.remove(this.update, this), this._isConnectedToTicker = !1); var e = this.source; e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), t.prototype.dispose.call(this) }, Object.defineProperty(e.prototype, "autoUpdate", { get: function () { return this._autoUpdate }, set: function (t) { t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (u.vB.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (u.vB.shared.add(this.update, this), this._isConnectedToTicker = !0)) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "updateFPS", { get: function () { return this._updateFPS }, set: function (t) { t !== this._updateFPS && (this._updateFPS = t) }, enumerable: !1, configurable: !0 }), e.test = function (t, r) { return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || e.TYPES.indexOf(r) > -1 }, e.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }, e }(T), O = function (t) { function e(e) { return t.call(this, e) || this } return f(e, t), e.test = function (t) { return !!globalThis.createImageBitmap && "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap }, e }(T); l.push(w, O, E, R, A, g, S, x); var I = { __proto__: null, Resource: m, BaseImageResource: T, INSTALLED: l, autoDetectResource: c, AbstractMultiResource: b, ArrayResource: x, BufferResource: g, CanvasResource: E, CubeResource: S, ImageResource: w, SVGResource: A, VideoResource: R, ImageBitmapResource: O }, P = function (t) { function e() { return null !== t && t.apply(this, arguments) || this } return f(e, t), e.prototype.upload = function (t, e, r) { var i = t.gl; i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === n.iw.UNPACK); var o = e.realWidth, s = e.realHeight; return r.width === o && r.height === s ? i.texSubImage2D(e.target, 0, 0, 0, o, s, e.format, r.type, this.data) : (r.width = o, r.height = s, i.texImage2D(e.target, 0, r.internalFormat, o, s, 0, e.format, r.type, this.data)), !0 }, e }(g), M = function () { function t(t, e) { this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new a.R("disposeFramebuffer"), this.multisample = n.G5.NONE } return Object.defineProperty(t.prototype, "colorTexture", { get: function () { return this.colorTextures[0] }, enumerable: !1, configurable: !0 }), t.prototype.addColorTexture = function (t, e) { return void 0 === t && (t = 0), this.colorTextures[t] = e || new y(null, { scaleMode: n.aH.NEAREST, resolution: 1, mipmap: n.WB.OFF, width: this.width, height: this.height }), this.dirtyId++, this.dirtyFormat++, this }, t.prototype.addDepthTexture = function (t) { return this.depthTexture = t || new y(new P(null, { width: this.width, height: this.height }), { scaleMode: n.aH.NEAREST, resolution: 1, width: this.width, height: this.height, mipmap: n.WB.OFF, format: n.I2.DEPTH_COMPONENT, type: n.vK.UNSIGNED_SHORT }), this.dirtyId++, this.dirtyFormat++, this }, t.prototype.enableDepth = function () { return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this }, t.prototype.enableStencil = function () { return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this }, t.prototype.resize = function (t, e) { if (t = Math.round(t), e = Math.round(e), t !== this.width || e !== this.height) { this.width = t, this.height = e, this.dirtyId++, this.dirtySize++; for (var r = 0; r < this.colorTextures.length; r++) { var i = this.colorTextures[r], n = i.resolution; i.setSize(t / n, e / n) } if (this.depthTexture) { n = this.depthTexture.resolution; this.depthTexture.setSize(t / n, e / n) } } }, t.prototype.dispose = function () { this.disposeRunner.emit(this, !1) }, t.prototype.destroyDepthTexture = function () { this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat) }, t }(), C = function (t) { function e(e) { void 0 === e && (e = {}); var r = this; if ("number" === typeof e) { var i = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3]; e = { width: i, height: o, scaleMode: s, resolution: a } } return e.width = e.width || 100, e.height = e.height || 100, e.multisample = void 0 !== e.multisample ? e.multisample : n.G5.NONE, r = t.call(this, null, e) || this, r.mipmap = n.WB.OFF, r.valid = !0, r.clearColor = [0, 0, 0, 0], r.framebuffer = new M(r.realWidth, r.realHeight).addColorTexture(0, r), r.framebuffer.multisample = e.multisample, r.maskStack = [], r.filterStack = [{}], r } return f(e, t), e.prototype.resize = function (t, e) { this.framebuffer.resize(t * this.resolution, e * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height) }, e.prototype.dispose = function () { this.framebuffer.dispose(), t.prototype.dispose.call(this) }, e.prototype.destroy = function () { t.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null }, e }(y), D = function () { function t() { this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8) } return t.prototype.set = function (t, e, r) { var i = e.width, n = e.height; if (r) { var o = t.width / 2 / i, s = t.height / 2 / n, a = t.x / i + o, u = t.y / n + s; r = h.Lv.add(r, h.Lv.NW), this.x0 = a + o * h.Lv.uX(r), this.y0 = u + s * h.Lv.uY(r), r = h.Lv.add(r, 2), this.x1 = a + o * h.Lv.uX(r), this.y1 = u + s * h.Lv.uY(r), r = h.Lv.add(r, 2), this.x2 = a + o * h.Lv.uX(r), this.y2 = u + s * h.Lv.uY(r), r = h.Lv.add(r, 2), this.x3 = a + o * h.Lv.uX(r), this.y3 = u + s * h.Lv.uY(r) } else this.x0 = t.x / i, this.y0 = t.y / n, this.x1 = (t.x + t.width) / i, this.y1 = t.y / n, this.x2 = (t.x + t.width) / i, this.y2 = (t.y + t.height) / n, this.x3 = t.x / i, this.y3 = (t.y + t.height) / n; this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3 }, t.prototype.toString = function () { return "[@pixi/core:TextureUvs x0=" + this.x0 + " y0=" + this.y0 + " x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3 + "]" }, t }(), L = new D; function F(t) { t.destroy = function () { }, t.on = function () { }, t.once = function () { }, t.emit = function () { } } var N = function (t) { function e(r, i, n, o, s, a) { var u = t.call(this) || this; if (u.noFrame = !1, i || (u.noFrame = !0, i = new h.Ae(0, 0, 1, 1)), r instanceof e && (r = r.baseTexture), u.baseTexture = r, u._frame = i, u.trim = o, u.valid = !1, u._uvs = L, u.uvMatrix = null, u.orig = n || i, u._rotate = Number(s || 0), !0 === s) u._rotate = 2; else if (u._rotate % 2 !== 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually"); return u.defaultAnchor = a ? new h.E9(a.x, a.y) : new h.E9(0, 0), u._updateID = 0, u.textureCacheIds = [], r.valid ? u.noFrame ? r.valid && u.onBaseTextureUpdated(r) : u.frame = i : r.once("loaded", u.onBaseTextureUpdated, u), u.noFrame && r.on("update", u.onBaseTextureUpdated, u), u } return f(e, t), e.prototype.update = function () { this.baseTexture.resource && this.baseTexture.resource.update() }, e.prototype.onBaseTextureUpdated = function (t) { if (this.noFrame) { if (!this.baseTexture.valid) return; this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs() } else this.frame = this._frame; this.emit("update", this) }, e.prototype.destroy = function (t) { if (this.baseTexture) { if (t) { var r = this.baseTexture.resource; r && r.url && o.TextureCache[r.url] && e.removeFromCache(r.url), this.baseTexture.destroy() } this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null } this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, e.removeFromCache(this), this.textureCacheIds = null }, e.prototype.clone = function () { var t = this._frame.clone(), r = this._frame === this.orig ? t : this.orig.clone(), i = new e(this.baseTexture, !this.noFrame && t, r, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor); return this.noFrame && (i._frame = t), i }, e.prototype.updateUvs = function () { this._uvs === L && (this._uvs = new D), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++ }, e.from = function (t, r, n) { void 0 === r && (r = {}), void 0 === n && (n = i.Xd.STRICT_TEXTURE_CACHE); var s = "string" === typeof t, a = null; if (s) a = t; else if (t instanceof y) { if (!t.cacheId) { var u = r && r.pixiIdPrefix || "pixiid"; t.cacheId = u + "-" + (0, o.uid)(), y.addToCache(t, t.cacheId) } a = t.cacheId } else { if (!t._pixiId) { u = r && r.pixiIdPrefix || "pixiid"; t._pixiId = u + "_" + (0, o.uid)() } a = t._pixiId } var h = o.TextureCache[a]; if (s && n && !h) throw new Error('The cacheId "' + a + '" does not exist in TextureCache.'); return h || t instanceof y ? !h && t instanceof y && (h = new e(t), e.addToCache(h, a)) : (r.resolution || (r.resolution = (0, o.getResolutionOfUrl)(t)), h = new e(new y(t, r)), h.baseTexture.cacheId = a, y.addToCache(h.baseTexture, a), e.addToCache(h, a)), h }, e.fromURL = function (t, r) { var i = Object.assign({ autoLoad: !1 }, null === r || void 0 === r ? void 0 : r.resourceOptions), n = e.from(t, Object.assign({ resourceOptions: i }, r), !1), o = n.baseTexture.resource; return n.baseTexture.valid ? Promise.resolve(n) : o.load().then((function () { return Promise.resolve(n) })) }, e.fromBuffer = function (t, r, i, n) { return new e(y.fromBuffer(t, r, i, n)) }, e.fromLoader = function (t, r, n, s) { var a = new y(t, Object.assign({ scaleMode: i.Xd.SCALE_MODE, resolution: (0, o.getResolutionOfUrl)(r) }, s)), u = a.resource; u instanceof w && (u.url = r); var h = new e(a); return n || (n = r), y.addToCache(h.baseTexture, n), e.addToCache(h, n), n !== r && (y.addToCache(h.baseTexture, r), e.addToCache(h, r)), h.baseTexture.valid ? Promise.resolve(h) : new Promise((function (t) { h.baseTexture.once("loaded", (function () { return t(h) })) })) }, e.addToCache = function (t, e) { e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), o.TextureCache[e] && console.warn("Texture added to the cache with an id [" + e + "] that already had an entry"), o.TextureCache[e] = t) }, e.removeFromCache = function (t) { if ("string" === typeof t) { var e = o.TextureCache[t]; if (e) { var r = e.textureCacheIds.indexOf(t); return r > -1 && e.textureCacheIds.splice(r, 1), delete o.TextureCache[t], e } } else if (t && t.textureCacheIds) { for (var i = 0; i < t.textureCacheIds.length; ++i)o.TextureCache[t.textureCacheIds[i]] === t && delete o.TextureCache[t.textureCacheIds[i]]; return t.textureCacheIds.length = 0, t } return null }, Object.defineProperty(e.prototype, "resolution", { get: function () { return this.baseTexture.resolution }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "frame", { get: function () { return this._frame }, set: function (t) { this._frame = t, this.noFrame = !1; var e = t.x, r = t.y, i = t.width, n = t.height, o = e + i > this.baseTexture.width, s = r + n > this.baseTexture.height; if (o || s) { var a = o && s ? "and" : "or", u = "X: " + e + " + " + i + " = " + (e + i) + " > " + this.baseTexture.width, h = "Y: " + r + " + " + n + " = " + (r + n) + " > " + this.baseTexture.height; throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + u + " " + a + " " + h) } this.valid = i && n && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t), this.valid && this.updateUvs() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "rotate", { get: function () { return this._rotate }, set: function (t) { this._rotate = t, this.valid && this.updateUvs() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "width", { get: function () { return this.orig.width }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this.orig.height }, enumerable: !1, configurable: !0 }), e.prototype.castToBaseTexture = function () { return this.baseTexture }, Object.defineProperty(e, "EMPTY", { get: function () { return e._EMPTY || (e._EMPTY = new e(new y), F(e._EMPTY), F(e._EMPTY.baseTexture)), e._EMPTY }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "WHITE", { get: function () { if (!e._WHITE) { var t = i.Xd.ADAPTER.createCanvas(16, 16), r = t.getContext("2d"); t.width = 16, t.height = 16, r.fillStyle = "white", r.fillRect(0, 0, 16, 16), e._WHITE = new e(y.from(t)), F(e._WHITE), F(e._WHITE.baseTexture) } return e._WHITE }, enumerable: !1, configurable: !0 }), e }(o.EventEmitter), B = function (t) { function e(e, r) { var i = t.call(this, e, r) || this; return i.valid = !0, i.filterFrame = null, i.filterPoolKey = null, i.updateUvs(), i } return f(e, t), Object.defineProperty(e.prototype, "framebuffer", { get: function () { return this.baseTexture.framebuffer }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "multisample", { get: function () { return this.framebuffer.multisample }, set: function (t) { this.framebuffer.multisample = t }, enumerable: !1, configurable: !0 }), e.prototype.resize = function (t, e, r) { void 0 === r && (r = !0); var i = this.baseTexture.resolution, n = Math.round(t * i) / i, o = Math.round(e * i) / i; this.valid = n > 0 && o > 0, this._frame.width = this.orig.width = n, this._frame.height = this.orig.height = o, r && this.baseTexture.resize(n, o), this.updateUvs() }, e.prototype.setResolution = function (t) { var e = this.baseTexture; e.resolution !== t && (e.setResolution(t), this.resize(e.width, e.height, !1)) }, e.create = function (t) { for (var r = arguments, i = [], n = 1; n < arguments.length; n++)i[n - 1] = r[n]; return "number" === typeof t && ((0, o.deprecation)("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), t = { width: t, height: i[0], scaleMode: i[1], resolution: i[2] }), new e(new C(t)) }, e }(N), U = function () { function t(t) { this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0 } return t.prototype.createTexture = function (t, e, r) { void 0 === r && (r = n.G5.NONE); var i = new C(Object.assign({ width: t, height: e, resolution: 1, multisample: r }, this.textureOptions)); return new B(i) }, t.prototype.getOptimalTexture = function (t, e, r, i) { var s; void 0 === r && (r = 1), void 0 === i && (i = n.G5.NONE), t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), this.enableFullScreen && t === this._pixelsWidth && e === this._pixelsHeight ? s = i > 1 ? -i : -1 : (t = (0, o.nextPow2)(t), e = (0, o.nextPow2)(e), s = ((65535 & t) << 16 | 65535 & e) >>> 0, i > 1 && (s += 4294967296 * i)), this.texturePool[s] || (this.texturePool[s] = []); var a = this.texturePool[s].pop(); return a || (a = this.createTexture(t, e, i)), a.filterPoolKey = s, a.setResolution(r), a }, t.prototype.getFilterTexture = function (t, e, r) { var i = this.getOptimalTexture(t.width, t.height, e || t.resolution, r || n.G5.NONE); return i.filterFrame = t.filterFrame, i }, t.prototype.returnTexture = function (t) { var e = t.filterPoolKey; t.filterFrame = null, this.texturePool[e].push(t) }, t.prototype.returnFilterTexture = function (t) { this.returnTexture(t) }, t.prototype.clear = function (t) { if (t = !1 !== t, t) for (var e in this.texturePool) { var r = this.texturePool[e]; if (r) for (var i = 0; i < r.length; i++)r[i].destroy(!0) } this.texturePool = {} }, t.prototype.setScreenSize = function (t) { if (t.width !== this._pixelsWidth || t.height !== this._pixelsHeight) { for (var e in this.enableFullScreen = t.width > 0 && t.height > 0, this.texturePool) if (Number(e) < 0) { var r = this.texturePool[e]; if (r) for (var i = 0; i < r.length; i++)r[i].destroy(!0); this.texturePool[e] = [] } this._pixelsWidth = t.width, this._pixelsHeight = t.height } }, t.SCREEN_KEY = -1, t }(), k = function () { function t(t, e, r, i, o, s, a) { void 0 === e && (e = 0), void 0 === r && (r = !1), void 0 === i && (i = n.vK.FLOAT), this.buffer = t, this.size = e, this.normalized = r, this.type = i, this.stride = o, this.start = s, this.instance = a } return t.prototype.destroy = function () { this.buffer = null }, t.from = function (e, r, i, n, o) { return new t(e, r, i, n, o) }, t }(), G = 0, X = function () { function t(t, e, r) { void 0 === e && (e = !0), void 0 === r && (r = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = G++, this.disposeRunner = new a.R("disposeBuffer") } return t.prototype.update = function (t) { t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++ }, t.prototype.dispose = function () { this.disposeRunner.emit(this, !1) }, t.prototype.destroy = function () { this.dispose(), this.data = null }, Object.defineProperty(t.prototype, "index", { get: function () { return this.type === n.mr.ELEMENT_ARRAY_BUFFER }, set: function (t) { this.type = t ? n.mr.ELEMENT_ARRAY_BUFFER : n.mr.ARRAY_BUFFER }, enumerable: !1, configurable: !0 }), t.from = function (e) { return e instanceof Array && (e = new Float32Array(e)), new t(e) }, t }(), j = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array }; function H(t, e) { for (var r = 0, i = 0, n = {}, s = 0; s < t.length; s++)i += e[s], r += t[s].length; var a = new ArrayBuffer(4 * r), u = null, h = 0; for (s = 0; s < t.length; s++) { var l = e[s], c = t[s], d = (0, o.getBufferType)(c); n[d] || (n[d] = new j[d](a)), u = n[d]; for (var f = 0; f < c.length; f++) { var p = (f / l | 0) * i + h, _ = f % l; u[p + _] = c[f] } h += l } return new Float32Array(a) } var V = { 5126: 4, 5123: 2, 5121: 1 }, z = 0, Y = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array, Uint16Array: Uint16Array }, W = function () { function t(t, e) { void 0 === t && (t = []), void 0 === e && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = z++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new a.R("disposeGeometry"), this.refCount = 0 } return t.prototype.addAttribute = function (t, e, r, i, n, o, s, a) { if (void 0 === r && (r = 0), void 0 === i && (i = !1), void 0 === a && (a = !1), !e) throw new Error("You must pass a buffer when creating an attribute"); e instanceof X || (e instanceof Array && (e = new Float32Array(e)), e = new X(e)); var u = t.split("|"); if (u.length > 1) { for (var h = 0; h < u.length; h++)this.addAttribute(u[h], e, r, i, n); return this } var l = this.buffers.indexOf(e); return -1 === l && (this.buffers.push(e), l = this.buffers.length - 1), this.attributes[t] = new k(l, r, i, n, o, s, a), this.instanced = this.instanced || a, this }, t.prototype.getAttribute = function (t) { return this.attributes[t] }, t.prototype.getBuffer = function (t) { return this.buffers[this.getAttribute(t).buffer] }, t.prototype.addIndex = function (t) { return t instanceof X || (t instanceof Array && (t = new Uint16Array(t)), t = new X(t)), t.type = n.mr.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, -1 === this.buffers.indexOf(t) && this.buffers.push(t), this }, t.prototype.getIndex = function () { return this.indexBuffer }, t.prototype.interleave = function () { if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) return this; var t, e = [], r = [], i = new X; for (t in this.attributes) { var n = this.attributes[t], o = this.buffers[n.buffer]; e.push(o.data), r.push(n.size * V[n.type] / 4), n.buffer = 0 } for (i.data = H(e, r), t = 0; t < this.buffers.length; t++)this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy(); return this.buffers = [i], this.indexBuffer && this.buffers.push(this.indexBuffer), this }, t.prototype.getSize = function () { for (var t in this.attributes) { var e = this.attributes[t], r = this.buffers[e.buffer]; return r.data.length / (e.stride / 4 || e.size) } return 0 }, t.prototype.dispose = function () { this.disposeRunner.emit(this, !1) }, t.prototype.destroy = function () { this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null }, t.prototype.clone = function () { for (var e = new t, r = 0; r < this.buffers.length; r++)e.buffers[r] = new X(this.buffers[r].data.slice(0)); for (var r in this.attributes) { var i = this.attributes[r]; e.attributes[r] = new k(i.buffer, i.size, i.normalized, i.type, i.stride, i.start, i.instance) } return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.type = n.mr.ELEMENT_ARRAY_BUFFER), e }, t.merge = function (e) { for (var r, i = new t, s = [], a = [], u = [], h = 0; h < e.length; h++) { r = e[h]; for (var l = 0; l < r.buffers.length; l++)a[l] = a[l] || 0, a[l] += r.buffers[l].data.length, u[l] = 0 } for (h = 0; h < r.buffers.length; h++)s[h] = new (Y[(0, o.getBufferType)(r.buffers[h].data)])(a[h]), i.buffers[h] = new X(s[h]); for (h = 0; h < e.length; h++) { r = e[h]; for (l = 0; l < r.buffers.length; l++)s[l].set(r.buffers[l].data, u[l]), u[l] += r.buffers[l].data.length } if (i.attributes = r.attributes, r.indexBuffer) { i.indexBuffer = i.buffers[r.buffers.indexOf(r.indexBuffer)], i.indexBuffer.type = n.mr.ELEMENT_ARRAY_BUFFER; var c = 0, d = 0, f = 0, p = 0; for (h = 0; h < r.buffers.length; h++)if (r.buffers[h] !== r.indexBuffer) { p = h; break } for (var h in r.attributes) { var _ = r.attributes[h]; (0 | _.buffer) === p && (d += _.size * V[_.type] / 4) } for (h = 0; h < e.length; h++) { var m = e[h].indexBuffer.data; for (l = 0; l < m.length; l++)i.indexBuffer.data[l + f] += c; c += e[h].buffers[p].data.length / d, f += m.length } } return i }, t }(), $ = function (t) { function e() { var e = t.call(this) || this; return e.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e } return f(e, t), e }(W), q = function (t) { function e() { var e = t.call(this) || this; return e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e.vertexBuffer = new X(e.vertices), e.uvBuffer = new X(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e } return f(e, t), e.prototype.map = function (t, e) { var r = 0, i = 0; return this.uvs[0] = r, this.uvs[1] = i, this.uvs[2] = r + e.width / t.width, this.uvs[3] = i, this.uvs[4] = r + e.width / t.width, this.uvs[5] = i + e.height / t.height, this.uvs[6] = r, this.uvs[7] = i + e.height / t.height, r = e.x, i = e.y, this.vertices[0] = r, this.vertices[1] = i, this.vertices[2] = r + e.width, this.vertices[3] = i, this.vertices[4] = r + e.width, this.vertices[5] = i + e.height, this.vertices[6] = r, this.vertices[7] = i + e.height, this.invalidate(), this }, e.prototype.invalidate = function () { return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this }, e }(W), K = 0, Z = function () { function t(t, e, r) { this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = K++, this.static = !!e, this.ubo = !!r, t instanceof X ? (this.buffer = t, this.buffer.type = n.mr.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new X(new Float32Array(1)), this.buffer.type = n.mr.UNIFORM_BUFFER, this.autoManage = !0)) } return t.prototype.update = function () { this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update() }, t.prototype.add = function (e, r, i) { if (this.ubo) throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them"); this.uniforms[e] = new t(r, i) }, t.from = function (e, r, i) { return new t(e, r, i) }, t.uboFrom = function (e, r) { return new t(e, null === r || void 0 === r || r, !0) }, t }(), J = function () { function t() { this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = n.G5.NONE, this.sourceFrame = new h.Ae, this.destinationFrame = new h.Ae, this.bindingSourceFrame = new h.Ae, this.bindingDestinationFrame = new h.Ae, this.filters = [], this.transform = null } return t.prototype.clear = function () { this.target = null, this.filters = null, this.renderTexture = null }, t }(), Q = [new h.E9, new h.E9, new h.E9, new h.E9], tt = new h.y3, et = function () { function t(t) { this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new U, this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new $, this.quadUv = new q, this.tempRect = new h.Ae, this.activeState = {}, this.globalUniforms = new Z({ outputFrame: new h.Ae, inputSize: new Float32Array(4), inputPixel: new Float32Array(4), inputClamp: new Float32Array(4), resolution: 1, filterArea: new Float32Array(4), filterClamp: new Float32Array(4) }, !0), this.forceClear = !1, this.useMaxPadding = !1 } return t.prototype.push = function (t, e) { for (var r, i, n = this.renderer, o = this.defaultFilterStack, s = this.statePool.pop() || new J, a = this.renderer.renderTexture, u = e[0].resolution, h = e[0].multisample, l = e[0].padding, c = e[0].autoFit, d = null === (r = e[0].legacy) || void 0 === r || r, f = 1; f < e.length; f++) { var p = e[f]; u = Math.min(u, p.resolution), h = Math.min(h, p.multisample), l = this.useMaxPadding ? Math.max(l, p.padding) : l + p.padding, c = c && p.autoFit, d = d || null === (i = p.legacy) || void 0 === i || i } 1 === o.length && (this.defaultFilterStack[0].renderTexture = a.current), o.push(s), s.resolution = u, s.multisample = h, s.legacy = d, s.target = t, s.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), s.sourceFrame.pad(l); var _ = this.tempRect.copyFrom(a.sourceFrame); n.projection.transform && this.transformAABB(tt.copyFrom(n.projection.transform).invert(), _), c ? (s.sourceFrame.fit(_), (s.sourceFrame.width <= 0 || s.sourceFrame.height <= 0) && (s.sourceFrame.width = 0, s.sourceFrame.height = 0)) : s.sourceFrame.intersects(_) || (s.sourceFrame.width = 0, s.sourceFrame.height = 0), this.roundFrame(s.sourceFrame, a.current ? a.current.resolution : n.resolution, a.sourceFrame, a.destinationFrame, n.projection.transform), s.renderTexture = this.getOptimalFilterTexture(s.sourceFrame.width, s.sourceFrame.height, u, h), s.filters = e, s.destinationFrame.width = s.renderTexture.width, s.destinationFrame.height = s.renderTexture.height; var m = this.tempRect; m.x = 0, m.y = 0, m.width = s.sourceFrame.width, m.height = s.sourceFrame.height, s.renderTexture.filterFrame = s.sourceFrame, s.bindingSourceFrame.copyFrom(a.sourceFrame), s.bindingDestinationFrame.copyFrom(a.destinationFrame), s.transform = n.projection.transform, n.projection.transform = null, a.bind(s.renderTexture, s.sourceFrame, m), n.framebuffer.clear(0, 0, 0, 0) }, t.prototype.pop = function () { var t = this.defaultFilterStack, e = t.pop(), r = e.filters; this.activeState = e; var i = this.globalUniforms.uniforms; i.outputFrame = e.sourceFrame, i.resolution = e.resolution; var o = i.inputSize, s = i.inputPixel, a = i.inputClamp; if (o[0] = e.destinationFrame.width, o[1] = e.destinationFrame.height, o[2] = 1 / o[0], o[3] = 1 / o[1], s[0] = Math.round(o[0] * e.resolution), s[1] = Math.round(o[1] * e.resolution), s[2] = 1 / s[0], s[3] = 1 / s[1], a[0] = .5 * s[2], a[1] = .5 * s[3], a[2] = e.sourceFrame.width * o[2] - .5 * s[2], a[3] = e.sourceFrame.height * o[3] - .5 * s[3], e.legacy) { var u = i.filterArea; u[0] = e.destinationFrame.width, u[1] = e.destinationFrame.height, u[2] = e.sourceFrame.x, u[3] = e.sourceFrame.y, i.filterClamp = i.inputClamp } this.globalUniforms.update(); var h = t[t.length - 1]; if (this.renderer.framebuffer.blit(), 1 === r.length) r[0].apply(this, e.renderTexture, h.renderTexture, n.yl.BLEND, e), this.returnFilterTexture(e.renderTexture); else { var l = e.renderTexture, c = this.getOptimalFilterTexture(l.width, l.height, e.resolution); c.filterFrame = l.filterFrame; var d = 0; for (d = 0; d < r.length - 1; ++d) { 1 === d && e.multisample > 1 && (c = this.getOptimalFilterTexture(l.width, l.height, e.resolution), c.filterFrame = l.filterFrame), r[d].apply(this, l, c, n.yl.CLEAR, e); var f = l; l = c, c = f } r[d].apply(this, l, h.renderTexture, n.yl.BLEND, e), d > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(l), this.returnFilterTexture(c) } e.clear(), this.statePool.push(e) }, t.prototype.bindAndClear = function (t, e) { void 0 === e && (e = n.yl.CLEAR); var r = this.renderer, i = r.renderTexture, o = r.state; if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) { var s = this.tempRect; s.x = 0, s.y = 0, s.width = t.filterFrame.width, s.height = t.filterFrame.height, i.bind(t, t.filterFrame, s) } else t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? i.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame); var a = 1 & o.stateId || this.forceClear; (e === n.yl.CLEAR || e === n.yl.BLIT && a) && this.renderer.framebuffer.clear(0, 0, 0, 0) }, t.prototype.applyFilter = function (t, e, r, i) { var o = this.renderer; o.state.set(t.state), this.bindAndClear(r, i), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, o.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), o.geometry.bind(this.quadUv), o.geometry.draw(n.lg.TRIANGLES)) : (o.geometry.bind(this.quad), o.geometry.draw(n.lg.TRIANGLE_STRIP)) }, t.prototype.calculateSpriteMatrix = function (t, e) { var r = this.activeState, i = r.sourceFrame, n = r.destinationFrame, o = e._texture.orig, s = t.set(n.width, 0, 0, n.height, i.x, i.y), a = e.worldTransform.copyTo(h.y3.TEMP_MATRIX); return a.invert(), s.prepend(a), s.scale(1 / o.width, 1 / o.height), s.translate(e.anchor.x, e.anchor.y), s }, t.prototype.destroy = function () { this.renderer = null, this.texturePool.clear(!1) }, t.prototype.getOptimalFilterTexture = function (t, e, r, i) { return void 0 === r && (r = 1), void 0 === i && (i = n.G5.NONE), this.texturePool.getOptimalTexture(t, e, r, i) }, t.prototype.getFilterTexture = function (t, e, r) { if ("number" === typeof t) { var i = t; t = e, e = i } t = t || this.activeState.renderTexture; var o = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, r || n.G5.NONE); return o.filterFrame = t.filterFrame, o }, t.prototype.returnFilterTexture = function (t) { this.texturePool.returnTexture(t) }, t.prototype.emptyPool = function () { this.texturePool.clear(!0) }, t.prototype.resize = function () { this.texturePool.setScreenSize(this.renderer.view) }, t.prototype.transformAABB = function (t, e) { var r = Q[0], i = Q[1], n = Q[2], o = Q[3]; r.set(e.left, e.top), i.set(e.left, e.bottom), n.set(e.right, e.top), o.set(e.right, e.bottom), t.apply(r, r), t.apply(i, i), t.apply(n, n), t.apply(o, o); var s = Math.min(r.x, i.x, n.x, o.x), a = Math.min(r.y, i.y, n.y, o.y), u = Math.max(r.x, i.x, n.x, o.x), h = Math.max(r.y, i.y, n.y, o.y); e.x = s, e.y = a, e.width = u - s, e.height = h - a }, t.prototype.roundFrame = function (t, e, r, i, n) { if (!(t.width <= 0 || t.height <= 0 || r.width <= 0 || r.height <= 0)) { if (n) { var o = n.a, s = n.b, a = n.c, u = n.d; if ((Math.abs(s) > 1e-4 || Math.abs(a) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(u) > 1e-4)) return } n = n ? tt.copyFrom(n) : tt.identity(), n.translate(-r.x, -r.y).scale(i.width / r.width, i.height / r.height).translate(i.x, i.y), this.transformAABB(n, t), t.ceil(e), this.transformAABB(n.invert(), t) } }, t }(), rt = function () { function t(t) { this.renderer = t } return t.prototype.flush = function () { }, t.prototype.destroy = function () { this.renderer = null }, t.prototype.start = function () { }, t.prototype.stop = function () { this.flush() }, t.prototype.render = function (t) { }, t }(), it = function () { function t(t) { this.renderer = t, this.emptyRenderer = new rt(t), this.currentRenderer = this.emptyRenderer } return t.prototype.setObjectRenderer = function (t) { this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start()) }, t.prototype.flush = function () { this.setObjectRenderer(this.emptyRenderer) }, t.prototype.reset = function () { this.setObjectRenderer(this.emptyRenderer) }, t.prototype.copyBoundTextures = function (t, e) { for (var r = this.renderer.texture.boundTextures, i = e - 1; i >= 0; --i)t[i] = r[i] || null, t[i] && (t[i]._batchLocation = i) }, t.prototype.boundArray = function (t, e, r, i) { for (var n = t.elements, o = t.ids, s = t.count, a = 0, u = 0; u < s; u++) { var h = n[u], l = h._batchLocation; if (l >= 0 && l < i && e[l] === h) o[u] = l; else while (a < i) { var c = e[a]; if (!c || c._batchEnabled !== r || c._batchLocation !== a) { o[u] = a, h._batchLocation = a, e[a] = h; break } a++ } } }, t.prototype.destroy = function () { this.renderer = null }, t }(), nt = 0, ot = function () { function t(t) { this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = { uint32Indices: !1 }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1) } return Object.defineProperty(t.prototype, "isLost", { get: function () { return !this.gl || this.gl.isContextLost() }, enumerable: !1, configurable: !0 }), t.prototype.contextChange = function (t) { this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = nt++ }, t.prototype.initFromContext = function (t) { this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = nt++, this.renderer.runners.contextChange.emit(t) }, t.prototype.initFromOptions = function (t) { var e = this.createContext(this.renderer.view, t); this.initFromContext(e) }, t.prototype.createContext = function (t, e) { var r; if (i.Xd.PREFER_ENV >= n.Vi.WEBGL2 && (r = t.getContext("webgl2", e)), r) this.webGLVersion = 2; else if (this.webGLVersion = 1, r = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), !r) throw new Error("This browser does not support WebGL. Try using the canvas renderer"); return this.gl = r, this.getExtensions(), this.gl }, t.prototype.getExtensions = function () { var t = this.gl, e = { loseContext: t.getExtension("WEBGL_lose_context"), anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t.getExtension("WEBGL_compressed_texture_etc"), etc1: t.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t.getExtension("WEBGL_compressed_texture_atc"), astc: t.getExtension("WEBGL_compressed_texture_astc") }; 1 === this.webGLVersion ? Object.assign(this.extensions, e, { drawBuffers: t.getExtension("WEBGL_draw_buffers"), depthTexture: t.getExtension("WEBGL_depth_texture"), vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t.getExtension("OES_element_index_uint"), floatTexture: t.getExtension("OES_texture_float"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), textureHalfFloat: t.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear") }) : 2 === this.webGLVersion && Object.assign(this.extensions, e, { colorBufferFloat: t.getExtension("EXT_color_buffer_float") }) }, t.prototype.handleContextLost = function (t) { var e = this; t.preventDefault(), setTimeout((function () { e.gl.isContextLost() && e.extensions.loseContext && e.extensions.loseContext.restoreContext() }), 0) }, t.prototype.handleContextRestored = function () { this.renderer.runners.contextChange.emit(this.gl) }, t.prototype.destroy = function () { var t = this.renderer.view; this.renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext() }, t.prototype.postrender = function () { this.renderer.renderingToScreen && this.gl.flush() }, t.prototype.validateContext = function (t) { var e = t.getContextAttributes(), r = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext; r && (this.webGLVersion = 2), e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly"); var i = r || !!t.getExtension("OES_element_index_uint"); this.supports.uint32Indices = i, i || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly") }, t }(), st = function () { function t(t) { this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = n.G5.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0 } return t }(), at = new h.Ae, ut = function () { function t(t) { this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new M(10, 10), this.msaaSamples = null } return t.prototype.contextChange = function () { this.disposeAll(!0); var t = this.gl = this.renderer.gl; if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new h.Ae, this.hasMRT = !0, this.writeDepthTexture = !0, 1 === this.renderer.context.webGLVersion) { var e = this.renderer.context.extensions.drawBuffers, r = this.renderer.context.extensions.depthTexture; i.Xd.PREFER_ENV === n.Vi.WEBGL_LEGACY && (e = null, r = null), e ? t.drawBuffers = function (t) { return e.drawBuffersWEBGL(t) } : (this.hasMRT = !1, t.drawBuffers = function () { }), r || (this.writeDepthTexture = !1) } else this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES) }, t.prototype.bind = function (t, e, r) { void 0 === r && (r = 0); var i = this.gl; if (t) { var n = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t); this.current !== t && (this.current = t, i.bindFramebuffer(i.FRAMEBUFFER, n.framebuffer)), n.mipLevel !== r && (t.dirtyId++, t.dirtyFormat++, n.mipLevel = r), n.dirtyId !== t.dirtyId && (n.dirtyId = t.dirtyId, n.dirtyFormat !== t.dirtyFormat ? (n.dirtyFormat = t.dirtyFormat, n.dirtySize = t.dirtySize, this.updateFramebuffer(t, r)) : n.dirtySize !== t.dirtySize && (n.dirtySize = t.dirtySize, this.resizeFramebuffer(t))); for (var o = 0; o < t.colorTextures.length; o++) { var s = t.colorTextures[o]; this.renderer.texture.unbind(s.parentTextureArray || s) } if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) { var a = e.width >> r, u = e.height >> r, h = a / e.width; this.setViewport(e.x * h, e.y * h, a, u) } else { a = t.width >> r, u = t.height >> r; this.setViewport(0, 0, a, u) } } else this.current && (this.current = null, i.bindFramebuffer(i.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height) }, t.prototype.setViewport = function (t, e, r, i) { var n = this.viewport; t = Math.round(t), e = Math.round(e), r = Math.round(r), i = Math.round(i), n.width === r && n.height === i && n.x === t && n.y === e || (n.x = t, n.y = e, n.width = r, n.height = i, this.gl.viewport(t, e, r, i)) }, Object.defineProperty(t.prototype, "size", { get: function () { return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height } }, enumerable: !1, configurable: !0 }), t.prototype.clear = function (t, e, r, i, o) { void 0 === o && (o = n.V0.COLOR | n.V0.DEPTH); var s = this.gl; s.clearColor(t, e, r, i), s.clear(o) }, t.prototype.initFramebuffer = function (t) { var e = this.gl, r = new st(e.createFramebuffer()); return r.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(t), t.disposeRunner.add(this), r }, t.prototype.resizeFramebuffer = function (t) { var e = this.gl, r = t.glFramebuffers[this.CONTEXT_UID]; r.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.RGBA8, t.width, t.height)), r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), r.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height)); var i = t.colorTextures, n = i.length; e.drawBuffers || (n = Math.min(n, 1)); for (var o = 0; o < n; o++) { var s = i[o], a = s.parentTextureArray || s; this.renderer.texture.bind(a, 0) } t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0) }, t.prototype.updateFramebuffer = function (t, e) { var r = this.gl, i = t.glFramebuffers[this.CONTEXT_UID], n = t.colorTextures, o = n.length; r.drawBuffers || (o = Math.min(o, 1)), i.multisample > 1 && this.canMultisampleFramebuffer(t) ? (i.msaaBuffer = i.msaaBuffer || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, i.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, r.RGBA8, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, i.msaaBuffer)) : i.msaaBuffer && (r.deleteRenderbuffer(i.msaaBuffer), i.msaaBuffer = null, i.blitFramebuffer && (i.blitFramebuffer.dispose(), i.blitFramebuffer = null)); for (var s = [], a = 0; a < o; a++) { var u = n[a], h = u.parentTextureArray || u; this.renderer.texture.bind(h, 0), 0 === a && i.msaaBuffer || (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + a, u.target, h._glTextures[this.CONTEXT_UID].texture, e), s.push(r.COLOR_ATTACHMENT0 + a)) } if (s.length > 1 && r.drawBuffers(s), t.depthTexture) { var l = this.writeDepthTexture; if (l) { var c = t.depthTexture; this.renderer.texture.bind(c, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, c._glTextures[this.CONTEXT_UID].texture, e) } } !t.stencil && !t.depth || t.depthTexture && this.writeDepthTexture ? i.stencil && (r.deleteRenderbuffer(i.stencil), i.stencil = null) : (i.stencil = i.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, i.stencil), i.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, i.stencil)) }, t.prototype.canMultisampleFramebuffer = function (t) { return 1 !== this.renderer.context.webGLVersion && t.colorTextures.length <= 1 && !t.depthTexture }, t.prototype.detectSamples = function (t) { var e = this.msaaSamples, r = n.G5.NONE; if (t <= 1 || null === e) return r; for (var i = 0; i < e.length; i++)if (e[i] <= t) { r = e[i]; break } return 1 === r && (r = n.G5.NONE), r }, t.prototype.blit = function (t, e, r) { var i = this, n = i.current, o = i.renderer, s = i.gl, a = i.CONTEXT_UID; if (2 === o.context.webGLVersion && n) { var u = n.glFramebuffers[a]; if (u) { if (!t) { if (!u.msaaBuffer) return; var h = n.colorTextures[0]; if (!h) return; u.blitFramebuffer || (u.blitFramebuffer = new M(n.width, n.height), u.blitFramebuffer.addColorTexture(0, h)), t = u.blitFramebuffer, t.colorTextures[0] !== h && (t.colorTextures[0] = h, t.dirtyId++, t.dirtyFormat++), t.width === n.width && t.height === n.height || (t.width = n.width, t.height = n.height, t.dirtyId++, t.dirtySize++) } e || (e = at, e.width = n.width, e.height = n.height), r || (r = e); var l = e.width === r.width && e.height === r.height; this.bind(t), s.bindFramebuffer(s.READ_FRAMEBUFFER, u.framebuffer), s.blitFramebuffer(e.left, e.top, e.right, e.bottom, r.left, r.top, r.right, r.bottom, s.COLOR_BUFFER_BIT, l ? s.NEAREST : s.LINEAR) } } }, t.prototype.disposeFramebuffer = function (t, e) { var r = t.glFramebuffers[this.CONTEXT_UID], i = this.gl; if (r) { delete t.glFramebuffers[this.CONTEXT_UID]; var n = this.managedFramebuffers.indexOf(t); n >= 0 && this.managedFramebuffers.splice(n, 1), t.disposeRunner.remove(this), e || (i.deleteFramebuffer(r.framebuffer), r.msaaBuffer && i.deleteRenderbuffer(r.msaaBuffer), r.stencil && i.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && r.blitFramebuffer.dispose() } }, t.prototype.disposeAll = function (t) { var e = this.managedFramebuffers; this.managedFramebuffers = []; for (var r = 0; r < e.length; r++)this.disposeFramebuffer(e[r], t) }, t.prototype.forceStencil = function () { var t = this.current; if (t) { var e = t.glFramebuffers[this.CONTEXT_UID]; if (e && !e.stencil) { t.stencil = !0; var r = t.width, i = t.height, n = this.gl, o = n.createRenderbuffer(); n.bindRenderbuffer(n.RENDERBUFFER, o), e.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, e.multisample, n.DEPTH24_STENCIL8, r, i) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, r, i), e.stencil = o, n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, o) } } }, t.prototype.reset = function () { this.current = this.unknownFramebuffer, this.viewport = new h.Ae }, t.prototype.destroy = function () { this.renderer = null }, t }(), ht = { 5126: 4, 5123: 2, 5121: 1 }, lt = function () { function t(t) { this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {} } return t.prototype.contextChange = function () { this.disposeAll(!0); var t = this.gl = this.renderer.gl, e = this.renderer.context; if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, 2 !== e.webGLVersion) { var r = this.renderer.context.extensions.vertexArrayObject; i.Xd.PREFER_ENV === n.Vi.WEBGL_LEGACY && (r = null), r ? (t.createVertexArray = function () { return r.createVertexArrayOES() }, t.bindVertexArray = function (t) { return r.bindVertexArrayOES(t) }, t.deleteVertexArray = function (t) { return r.deleteVertexArrayOES(t) }) : (this.hasVao = !1, t.createVertexArray = function () { return null }, t.bindVertexArray = function () { return null }, t.deleteVertexArray = function () { return null }) } if (2 !== e.webGLVersion) { var o = t.getExtension("ANGLE_instanced_arrays"); o ? (t.vertexAttribDivisor = function (t, e) { return o.vertexAttribDivisorANGLE(t, e) }, t.drawElementsInstanced = function (t, e, r, i, n) { return o.drawElementsInstancedANGLE(t, e, r, i, n) }, t.drawArraysInstanced = function (t, e, r, i) { return o.drawArraysInstancedANGLE(t, e, r, i) }) : this.hasInstance = !1 } this.canUseUInt32ElementIndex = 2 === e.webGLVersion || !!e.extensions.uint32ElementIndex }, t.prototype.bind = function (t, e) { e = e || this.renderer.shader.shader; var r = this.gl, i = t.glVertexArrayObjects[this.CONTEXT_UID], n = !1; i || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = i = {}, n = !0); var o = i[e.program.id] || this.initGeometryVao(t, e, n); this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? r.bindVertexArray(o) : this.activateVao(t, e.program)), this.updateBuffers() }, t.prototype.reset = function () { this.unbind() }, t.prototype.updateBuffers = function () { for (var t = this._activeGeometry, e = this.renderer.buffer, r = 0; r < t.buffers.length; r++) { var i = t.buffers[r]; e.update(i) } }, t.prototype.checkCompatibility = function (t, e) { var r = t.attributes, i = e.attributeData; for (var n in i) if (!r[n]) throw new Error('shader and geometry incompatible, geometry missing the "' + n + '" attribute') }, t.prototype.getSignature = function (t, e) { var r = t.attributes, i = e.attributeData, n = ["g", t.id]; for (var o in r) i[o] && n.push(o, i[o].location); return n.join("-") }, t.prototype.initGeometryVao = function (t, e, r) { void 0 === r && (r = !0); var i = this.gl, n = this.CONTEXT_UID, o = this.renderer.buffer, s = e.program; s.glPrograms[n] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, s); var a = this.getSignature(t, s), u = t.glVertexArrayObjects[this.CONTEXT_UID], h = u[a]; if (h) return u[s.id] = h, h; var l = t.buffers, c = t.attributes, d = {}, f = {}; for (var p in l) d[p] = 0, f[p] = 0; for (var p in c) !c[p].size && s.attributeData[p] ? c[p].size = s.attributeData[p].size : c[p].size || console.warn("PIXI Geometry attribute '" + p + "' size cannot be determined (likely the bound shader does not have the attribute)"), d[c[p].buffer] += c[p].size * ht[c[p].type]; for (var p in c) { var _ = c[p], m = _.size; void 0 === _.stride && (d[_.buffer] === m * ht[_.type] ? _.stride = 0 : _.stride = d[_.buffer]), void 0 === _.start && (_.start = f[_.buffer], f[_.buffer] += m * ht[_.type]) } h = i.createVertexArray(), i.bindVertexArray(h); for (var g = 0; g < l.length; g++) { var v = l[g]; o.bind(v), r && v._glBuffers[n].refCount++ } return this.activateVao(t, s), this._activeVao = h, u[s.id] = h, u[a] = h, h }, t.prototype.disposeGeometry = function (t, e) { var r; if (this.managedGeometries[t.id]) { delete this.managedGeometries[t.id]; var i = t.glVertexArrayObjects[this.CONTEXT_UID], n = this.gl, o = t.buffers, s = null === (r = this.renderer) || void 0 === r ? void 0 : r.buffer; if (t.disposeRunner.remove(this), i) { if (s) for (var a = 0; a < o.length; a++) { var u = o[a]._glBuffers[this.CONTEXT_UID]; u && (u.refCount--, 0 !== u.refCount || e || s.dispose(o[a], e)) } if (!e) for (var h in i) if ("g" === h[0]) { var l = i[h]; this._activeVao === l && this.unbind(), n.deleteVertexArray(l) } delete t.glVertexArrayObjects[this.CONTEXT_UID] } } }, t.prototype.disposeAll = function (t) { for (var e = Object.keys(this.managedGeometries), r = 0; r < e.length; r++)this.disposeGeometry(this.managedGeometries[e[r]], t) }, t.prototype.activateVao = function (t, e) { var r = this.gl, i = this.CONTEXT_UID, n = this.renderer.buffer, o = t.buffers, s = t.attributes; t.indexBuffer && n.bind(t.indexBuffer); var a = null; for (var u in s) { var h = s[u], l = o[h.buffer], c = l._glBuffers[i]; if (e.attributeData[u]) { a !== c && (n.bind(l), a = c); var d = e.attributeData[u].location; if (r.enableVertexAttribArray(d), r.vertexAttribPointer(d, h.size, h.type || r.FLOAT, h.normalized, h.stride, h.start), h.instance) { if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device"); r.vertexAttribDivisor(d, 1) } } } }, t.prototype.draw = function (t, e, r, i) { var n = this.gl, o = this._activeGeometry; if (o.indexBuffer) { var s = o.indexBuffer.data.BYTES_PER_ELEMENT, a = 2 === s ? n.UNSIGNED_SHORT : n.UNSIGNED_INT; 2 === s || 4 === s && this.canUseUInt32ElementIndex ? o.instanced ? n.drawElementsInstanced(t, e || o.indexBuffer.data.length, a, (r || 0) * s, i || 1) : n.drawElements(t, e || o.indexBuffer.data.length, a, (r || 0) * s) : console.warn("unsupported index buffer type: uint32") } else o.instanced ? n.drawArraysInstanced(t, r, e || o.getSize(), i || 1) : n.drawArrays(t, r, e || o.getSize()); return this }, t.prototype.unbind = function () { this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null }, t.prototype.destroy = function () { this.renderer = null }, t }(), ct = function () { function t(t) { void 0 === t && (t = null), this.type = n.A7.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = i.Xd.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null } return Object.defineProperty(t.prototype, "filter", { get: function () { return this._filters ? this._filters[0] : null }, set: function (t) { t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null }, enumerable: !1, configurable: !0 }), t.prototype.reset = function () { this.pooled && (this.maskObject = null, this.type = n.A7.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null }, t.prototype.copyCountersOrReset = function (t) { t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null) }, t }(); function dt(t, e, r) { var i = t.createShader(e); return t.shaderSource(i, r), t.compileShader(i), i } function ft(t, e) { var r = t.getShaderSource(e).split("\n").map((function (t, e) { return e + ": " + t })), i = t.getShaderInfoLog(e), n = i.split("\n"), o = {}, s = n.map((function (t) { return parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1")) })).filter((function (t) { return !(!t || o[t]) && (o[t] = !0, !0) })), a = [""]; s.forEach((function (t) { r[t - 1] = "%c" + r[t - 1] + "%c", a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px") })); var u = r.join("\n"); a[0] = u, console.error(i), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a), console.groupEnd() } function pt(t, e, r, i) { t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(r, t.COMPILE_STATUS) || ft(t, r), t.getShaderParameter(i, t.COMPILE_STATUS) || ft(t, i), console.error("PixiJS Error: Could not initialize shader."), "" !== t.getProgramInfoLog(e) && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(e))) } function _t(t) { for (var e = new Array(t), r = 0; r < e.length; r++)e[r] = !1; return e } function mt(t, e) { switch (t) { case "float": return 0; case "vec2": return new Float32Array(2 * e); case "vec3": return new Float32Array(3 * e); case "vec4": return new Float32Array(4 * e); case "int": case "uint": case "sampler2D": case "sampler2DArray": return 0; case "ivec2": return new Int32Array(2 * e); case "ivec3": return new Int32Array(3 * e); case "ivec4": return new Int32Array(4 * e); case "uvec2": return new Uint32Array(2 * e); case "uvec3": return new Uint32Array(3 * e); case "uvec4": return new Uint32Array(4 * e); case "bool": return !1; case "bvec2": return _t(2 * e); case "bvec3": return _t(3 * e); case "bvec4": return _t(4 * e); case "mat2": return new Float32Array([1, 0, 0, 1]); case "mat3": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } var gt, vt = {}, yt = vt; function bt() { if (yt === vt || yt && yt.isContextLost()) { var t = i.Xd.ADAPTER.createCanvas(), e = void 0; i.Xd.PREFER_ENV >= n.Vi.WEBGL2 && (e = t.getContext("webgl2", {})), e || (e = t.getContext("webgl", {}) || t.getContext("experimental-webgl", {}), e ? e.getExtension("WEBGL_draw_buffers") : e = null), yt = e } return yt } function xt() { if (!gt) { gt = n.cB.MEDIUM; var t = bt(); if (t && t.getShaderPrecisionFormat) { var e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT); gt = e.precision ? n.cB.HIGH : n.cB.MEDIUM } } return gt } function Tt(t, e, r) { if ("precision" !== t.substring(0, 9)) { var i = e; return e === n.cB.HIGH && r !== n.cB.HIGH && (i = n.cB.MEDIUM), "precision " + i + " float;\n" + t } return r !== n.cB.HIGH && "precision highp" === t.substring(0, 15) ? t.replace("precision highp", "precision mediump") : t } var Et = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, uint: 1, uvec2: 2, uvec3: 3, uvec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 }; function St(t) { return Et[t] } var wt = null, At = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" }; function Rt(t, e) { if (!wt) { var r = Object.keys(At); wt = {}; for (var i = 0; i < r.length; ++i) { var n = r[i]; wt[t[n]] = At[n] } } return wt[e] } var Ot = [{ test: function (t) { return "float" === t.type && 1 === t.size && !t.isArray }, code: function (t) { return '\n            if(uv["' + t + '"] !== ud["' + t + '"].value)\n            {\n                ud["' + t + '"].value = uv["' + t + '"]\n                gl.uniform1f(ud["' + t + '"].location, uv["' + t + '"])\n            }\n            ' } }, { test: function (t, e) { return ("sampler2D" === t.type || "samplerCube" === t.type || "sampler2DArray" === t.type) && 1 === t.size && !t.isArray && (null == e || void 0 !== e.castToBaseTexture) }, code: function (t) { return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t + '"], t);\n\n            if(ud["' + t + '"].value !== t)\n            {\n                ud["' + t + '"].value = t;\n                gl.uniform1i(ud["' + t + '"].location, t);\n; // eslint-disable-line max-len\n            }' } }, { test: function (t, e) { return "mat3" === t.type && 1 === t.size && !t.isArray && void 0 !== e.a }, code: function (t) { return '\n            gl.uniformMatrix3fv(ud["' + t + '"].location, false, uv["' + t + '"].toArray(true));\n            ' }, codeUbo: function (t) { return "\n                var " + t + "_matrix = uv." + t + ".toArray(true);\n\n                data[offset] = " + t + "_matrix[0];\n                data[offset+1] = " + t + "_matrix[1];\n                data[offset+2] = " + t + "_matrix[2];\n        \n                data[offset + 4] = " + t + "_matrix[3];\n                data[offset + 5] = " + t + "_matrix[4];\n                data[offset + 6] = " + t + "_matrix[5];\n        \n                data[offset + 8] = " + t + "_matrix[6];\n                data[offset + 9] = " + t + "_matrix[7];\n                data[offset + 10] = " + t + "_matrix[8];\n            " } }, { test: function (t, e) { return "vec2" === t.type && 1 === t.size && !t.isArray && void 0 !== e.x }, code: function (t) { return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t + '"].location, v.x, v.y);\n                }' }, codeUbo: function (t) { return "\n                v = uv." + t + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            " } }, { test: function (t) { return "vec2" === t.type && 1 === t.size && !t.isArray }, code: function (t) { return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t + '"].location, v[0], v[1]);\n                }\n            ' } }, { test: function (t, e) { return "vec4" === t.type && 1 === t.size && !t.isArray && void 0 !== e.width }, code: function (t) { return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t + '"].location, v.x, v.y, v.width, v.height)\n                }' }, codeUbo: function (t) { return "\n                    v = uv." + t + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                " } }, { test: function (t) { return "vec4" === t.type && 1 === t.size && !t.isArray }, code: function (t) { return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t + '"].location, v[0], v[1], v[2], v[3])\n                }' } }], It = { float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }", vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }", vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }", vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }", int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }", ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }", uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }", uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }", uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }", bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }", bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", mat2: "gl.uniformMatrix2fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", sampler2D: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }", samplerCube: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }", sampler2DArray: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }" }, Pt = { float: "gl.uniform1fv(location, v)", vec2: "gl.uniform2fv(location, v)", vec3: "gl.uniform3fv(location, v)", vec4: "gl.uniform4fv(location, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat2: "gl.uniformMatrix2fv(location, false, v)", int: "gl.uniform1iv(location, v)", ivec2: "gl.uniform2iv(location, v)", ivec3: "gl.uniform3iv(location, v)", ivec4: "gl.uniform4iv(location, v)", uint: "gl.uniform1uiv(location, v)", uvec2: "gl.uniform2uiv(location, v)", uvec3: "gl.uniform3uiv(location, v)", uvec4: "gl.uniform4uiv(location, v)", bool: "gl.uniform1iv(location, v)", bvec2: "gl.uniform2iv(location, v)", bvec3: "gl.uniform3iv(location, v)", bvec4: "gl.uniform4iv(location, v)", sampler2D: "gl.uniform1iv(location, v)", samplerCube: "gl.uniform1iv(location, v)", sampler2DArray: "gl.uniform1iv(location, v)" }; function Mt(t, e) { var r, i = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "]; for (var n in t.uniforms) { var o = e[n]; if (o) { for (var s = t.uniforms[n], a = !1, u = 0; u < Ot.length; u++)if (Ot[u].test(o, s)) { i.push(Ot[u].code(n, s)), a = !0; break } if (!a) { var h = 1 !== o.size || o.isArray ? Pt : It, l = h[o.type].replace("location", 'ud["' + n + '"].location'); i.push('\n            cu = ud["' + n + '"];\n            cv = cu.value;\n            v = uv["' + n + '"];\n            ' + l + ";") } } else (null === (r = t.uniforms[n]) || void 0 === r ? void 0 : r.group) && (t.uniforms[n].ubo ? i.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + n + ", '" + n + "');\n                    ") : i.push("\n                        renderer.shader.syncUniformGroup(uv." + n + ", syncData);\n                    ")) } return new Function("ud", "uv", "renderer", "syncData", i.join("\n")) } var Ct, Dt = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n"); function Lt(t) { for (var e = "", r = 0; r < t; ++r)r > 0 && (e += "\nelse "), r < t - 1 && (e += "if(test == " + r + ".0){}"); return e } function Ft(t, e) { if (0 === t) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`"); var r = e.createShader(e.FRAGMENT_SHADER); while (1) { var i = Dt.replace(/%forloop%/gi, Lt(t)); if (e.shaderSource(r, i), e.compileShader(r), e.getShaderParameter(r, e.COMPILE_STATUS)) break; t = t / 2 | 0 } return t } function Nt() { if ("boolean" === typeof Ct) return Ct; try { var t = new Function("param1", "param2", "param3", "return param1[param2] === param3;"); Ct = !0 === t({ a: "b" }, "a", "b") } catch (e) { Ct = !1 } return Ct } var Bt = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}", Ut = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n", kt = 0, Gt = {}, Xt = function () { function t(e, r, o) { void 0 === o && (o = "pixi-shader"), this.id = kt++, this.vertexSrc = e || t.defaultVertexSrc, this.fragmentSrc = r || t.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), "#version" !== this.vertexSrc.substring(0, 8) && (o = o.replace(/\s+/g, "-"), Gt[o] ? (Gt[o]++, o += "-" + Gt[o]) : Gt[o] = 1, this.vertexSrc = "#define SHADER_NAME " + o + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + o + "\n" + this.fragmentSrc, this.vertexSrc = Tt(this.vertexSrc, i.Xd.PRECISION_VERTEX, n.cB.HIGH), this.fragmentSrc = Tt(this.fragmentSrc, i.Xd.PRECISION_FRAGMENT, xt())), this.glPrograms = {}, this.syncUniforms = null } return Object.defineProperty(t, "defaultVertexSrc", { get: function () { return Ut }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultFragmentSrc", { get: function () { return Bt }, enumerable: !1, configurable: !0 }), t.from = function (e, r, i) { var n = e + r, s = o.ProgramCache[n]; return s || (o.ProgramCache[n] = s = new t(e, r, i)), s }, t }(), jt = function () { function t(t, e) { this.uniformBindCount = 0, this.program = t, this.uniformGroup = e ? e instanceof Z ? e : new Z(e) : new Z({}), this.disposeRunner = new a.R("disposeShader") } return t.prototype.checkUniformExists = function (t, e) { if (e.uniforms[t]) return !0; for (var r in e.uniforms) { var i = e.uniforms[r]; if (i.group && this.checkUniformExists(t, i)) return !0 } return !1 }, t.prototype.destroy = function () { this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy() }, Object.defineProperty(t.prototype, "uniforms", { get: function () { return this.uniformGroup.uniforms }, enumerable: !1, configurable: !0 }), t.from = function (e, r, i) { var n = Xt.from(e, r); return new t(n, i) }, t }(), Ht = 0, Vt = 1, zt = 2, Yt = 3, Wt = 4, $t = 5, qt = function () { function t() { this.data = 0, this.blendMode = n.T$.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0 } return Object.defineProperty(t.prototype, "blend", { get: function () { return !!(this.data & 1 << Ht) }, set: function (t) { !!(this.data & 1 << Ht) !== t && (this.data ^= 1 << Ht) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "offsets", { get: function () { return !!(this.data & 1 << Vt) }, set: function (t) { !!(this.data & 1 << Vt) !== t && (this.data ^= 1 << Vt) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "culling", { get: function () { return !!(this.data & 1 << zt) }, set: function (t) { !!(this.data & 1 << zt) !== t && (this.data ^= 1 << zt) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "depthTest", { get: function () { return !!(this.data & 1 << Yt) }, set: function (t) { !!(this.data & 1 << Yt) !== t && (this.data ^= 1 << Yt) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "depthMask", { get: function () { return !!(this.data & 1 << $t) }, set: function (t) { !!(this.data & 1 << $t) !== t && (this.data ^= 1 << $t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "clockwiseFrontFace", { get: function () { return !!(this.data & 1 << Wt) }, set: function (t) { !!(this.data & 1 << Wt) !== t && (this.data ^= 1 << Wt) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "blendMode", { get: function () { return this._blendMode }, set: function (t) { this.blend = t !== n.T$.NONE, this._blendMode = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "polygonOffset", { get: function () { return this._polygonOffset }, set: function (t) { this.offsets = !!t, this._polygonOffset = t }, enumerable: !1, configurable: !0 }), t.prototype.toString = function () { return "[@pixi/core:State blendMode=" + this.blendMode + " clockwiseFrontFace=" + this.clockwiseFrontFace + " culling=" + this.culling + " depthMask=" + this.depthMask + " polygonOffset=" + this.polygonOffset + "]" }, t.for2d = function () { var e = new t; return e.depthTest = !1, e.blend = !0, e }, t }(), Kt = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n", Zt = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", Jt = function (t) { function e(r, n, o) { var s = this, a = Xt.from(r || e.defaultVertexSrc, n || e.defaultFragmentSrc); return s = t.call(this, a, o) || this, s.padding = 0, s.resolution = i.Xd.FILTER_RESOLUTION, s.multisample = i.Xd.FILTER_MULTISAMPLE, s.enabled = !0, s.autoFit = !0, s.state = new qt, s } return f(e, t), e.prototype.apply = function (t, e, r, i, n) { t.applyFilter(this, e, r, i) }, Object.defineProperty(e.prototype, "blendMode", { get: function () { return this.state.blendMode }, set: function (t) { this.state.blendMode = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "resolution", { get: function () { return this._resolution }, set: function (t) { this._resolution = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "defaultVertexSrc", { get: function () { return Zt }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "defaultFragmentSrc", { get: function () { return Kt }, enumerable: !1, configurable: !0 }), e }(jt), Qt = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", te = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", ee = new h.y3, re = function () { function t(t, e) { this._texture = t, this.mapCoord = new h.y3, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = "undefined" === typeof e ? .5 : e, this.isSimple = !1 } return Object.defineProperty(t.prototype, "texture", { get: function () { return this._texture }, set: function (t) { this._texture = t, this._textureID = -1 }, enumerable: !1, configurable: !0 }), t.prototype.multiplyUvs = function (t, e) { void 0 === e && (e = t); for (var r = this.mapCoord, i = 0; i < t.length; i += 2) { var n = t[i], o = t[i + 1]; e[i] = n * r.a + o * r.c + r.tx, e[i + 1] = n * r.b + o * r.d + r.ty } return e }, t.prototype.update = function (t) { var e = this._texture; if (!e || !e.valid) return !1; if (!t && this._textureID === e._updateID) return !1; this._textureID = e._updateID, this._updateID++; var r = e._uvs; this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0); var i = e.orig, n = e.trim; n && (ee.set(i.width / n.width, 0, 0, i.height / n.height, -n.x / n.width, -n.y / n.height), this.mapCoord.append(ee)); var o = e.baseTexture, s = this.uClampFrame, a = this.clampMargin / o.resolution, u = this.clampOffset; return s[0] = (e._frame.x + a + u) / o.width, s[1] = (e._frame.y + a + u) / o.height, s[2] = (e._frame.x + e._frame.width - a + u) / o.width, s[3] = (e._frame.y + e._frame.height - a + u) / o.height, this.uClampOffset[0] = u / o.realWidth, this.uClampOffset[1] = u / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && 0 === e.rotate, !0 }, t }(), ie = function (t) { function e(e, r, i) { var n = this, o = null; return "string" !== typeof e && void 0 === r && void 0 === i && (o = e, e = void 0, r = void 0, i = void 0), n = t.call(this, e || Qt, r || te, i) || this, n.maskSprite = o, n.maskMatrix = new h.y3, n } return f(e, t), Object.defineProperty(e.prototype, "maskSprite", { get: function () { return this._maskSprite }, set: function (t) { this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = !1) }, enumerable: !1, configurable: !0 }), e.prototype.apply = function (t, e, r, i) { var n = this._maskSprite, o = n._texture; o.valid && (o.uvMatrix || (o.uvMatrix = new re(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, n).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = n.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, e, r, i)) }, e }(Jt), ne = function () { function t(t) { this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0 } return t.prototype.setMaskStack = function (t) { this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t) }, t.prototype.push = function (t, e) { var r = e; if (!r.isMaskData) { var i = this.maskDataPool.pop() || new ct; i.pooled = !0, i.maskObject = e, r = i } var o = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null; if (r.copyCountersOrReset(o), r._colorMask = o ? o._colorMask : 15, r.autoDetect && this.detect(r), r._target = t, r.type !== n.A7.SPRITE && this.maskStack.push(r), r.enabled) switch (r.type) { case n.A7.SCISSOR: this.renderer.scissor.push(r); break; case n.A7.STENCIL: this.renderer.stencil.push(r); break; case n.A7.SPRITE: r.copyCountersOrReset(null), this.pushSpriteMask(r); break; case n.A7.COLOR: this.pushColorMask(r); break }r.type === n.A7.SPRITE && this.maskStack.push(r) }, t.prototype.pop = function (t) { var e = this.maskStack.pop(); if (e && e._target === t) { if (e.enabled) switch (e.type) { case n.A7.SCISSOR: this.renderer.scissor.pop(e); break; case n.A7.STENCIL: this.renderer.stencil.pop(e.maskObject); break; case n.A7.SPRITE: this.popSpriteMask(e); break; case n.A7.COLOR: this.popColorMask(e); break }if (e.reset(), e.pooled && this.maskDataPool.push(e), 0 !== this.maskStack.length) { var r = this.maskStack[this.maskStack.length - 1]; r.type === n.A7.SPRITE && r._filters && (r._filters[0].maskSprite = r.maskObject) } } }, t.prototype.detect = function (t) { var e = t.maskObject; e ? e.isSprite ? t.type = n.A7.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = n.A7.SCISSOR : t.type = n.A7.STENCIL : t.type = n.A7.COLOR }, t.prototype.pushSpriteMask = function (t) { var e, r, i = t.maskObject, n = t._target, o = t._filters; o || (o = this.alphaMaskPool[this.alphaMaskIndex], o || (o = this.alphaMaskPool[this.alphaMaskIndex] = [new ie])); var s, a, u = this.renderer, h = u.renderTexture; if (h.current) { var l = h.current; s = t.resolution || l.resolution, a = null !== (e = t.multisample) && void 0 !== e ? e : l.multisample } else s = t.resolution || u.resolution, a = null !== (r = t.multisample) && void 0 !== r ? r : u.multisample; o[0].resolution = s, o[0].multisample = a, o[0].maskSprite = i; var c = n.filterArea; n.filterArea = i.getBounds(!0), u.filter.push(n, o), n.filterArea = c, t._filters || this.alphaMaskIndex++ }, t.prototype.popSpriteMask = function (t) { this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null) }, t.prototype.pushColorMask = function (t) { var e = t._colorMask, r = t._colorMask = e & t.colorMask; r !== e && this.renderer.gl.colorMask(0 !== (1 & r), 0 !== (2 & r), 0 !== (4 & r), 0 !== (8 & r)) }, t.prototype.popColorMask = function (t) { var e = t._colorMask, r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15; r !== e && this.renderer.gl.colorMask(0 !== (1 & r), 0 !== (2 & r), 0 !== (4 & r), 0 !== (8 & r)) }, t.prototype.destroy = function () { this.renderer = null }, t }(), oe = function () { function t(t) { this.renderer = t, this.maskStack = [], this.glConst = 0 } return t.prototype.getStackLength = function () { return this.maskStack.length }, t.prototype.setMaskStack = function (t) { var e = this.renderer.gl, r = this.getStackLength(); this.maskStack = t; var i = this.getStackLength(); i !== r && (0 === i ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent())) }, t.prototype._useCurrent = function () { }, t.prototype.destroy = function () { this.renderer = null, this.maskStack = null }, t }(), se = new h.y3, ae = [], ue = function (t) { function e(e) { var r = t.call(this, e) || this; return r.glConst = i.Xd.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, r } return f(e, t), e.prototype.getStackLength = function () { var t = this.maskStack[this.maskStack.length - 1]; return t ? t._scissorCounter : 0 }, e.prototype.calcScissorRect = function (t) { var e; if (!t._scissorRectLocal) { var r = t._scissorRect, i = t.maskObject, n = this.renderer, o = n.renderTexture, s = i.getBounds(!0, null !== (e = ae.pop()) && void 0 !== e ? e : new h.Ae); this.roundFrameToPixels(s, o.current ? o.current.resolution : n.resolution, o.sourceFrame, o.destinationFrame, n.projection.transform), r && s.fit(r), t._scissorRectLocal = s } }, e.isMatrixRotated = function (t) { if (!t) return !1; var e = t.a, r = t.b, i = t.c, n = t.d; return (Math.abs(r) > 1e-4 || Math.abs(i) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(n) > 1e-4) }, e.prototype.testScissor = function (t) { var r = t.maskObject; if (!r.isFastRect || !r.isFastRect()) return !1; if (e.isMatrixRotated(r.worldTransform)) return !1; if (e.isMatrixRotated(this.renderer.projection.transform)) return !1; this.calcScissorRect(t); var i = t._scissorRectLocal; return i.width > 0 && i.height > 0 }, e.prototype.roundFrameToPixels = function (t, r, i, n, o) { e.isMatrixRotated(o) || (o = o ? se.copyFrom(o) : se.identity(), o.translate(-i.x, -i.y).scale(n.width / i.width, n.height / i.height).translate(n.x, n.y), this.renderer.filter.transformAABB(o, t), t.fit(n), t.x = Math.round(t.x * r), t.y = Math.round(t.y * r), t.width = Math.round(t.width * r), t.height = Math.round(t.height * r)) }, e.prototype.push = function (t) { t._scissorRectLocal || this.calcScissorRect(t); var e = this.renderer.gl; t._scissorRect || e.enable(e.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = t._scissorRectLocal, this._useCurrent() }, e.prototype.pop = function (t) { var e = this.renderer.gl; t && ae.push(t._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : e.disable(e.SCISSOR_TEST) }, e.prototype._useCurrent = function () { var t, e = this.maskStack[this.maskStack.length - 1]._scissorRect; t = this.renderer.renderTexture.current ? e.y : this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, t, e.width, e.height) }, e }(oe), he = function (t) { function e(e) { var r = t.call(this, e) || this; return r.glConst = i.Xd.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, r } return f(e, t), e.prototype.getStackLength = function () { var t = this.maskStack[this.maskStack.length - 1]; return t ? t._stencilCounter : 0 }, e.prototype.push = function (t) { var e = t.maskObject, r = this.renderer.gl, i = t._stencilCounter; 0 === i && (this.renderer.framebuffer.forceStencil(), r.clearStencil(0), r.clear(r.STENCIL_BUFFER_BIT), r.enable(r.STENCIL_TEST)), t._stencilCounter++; var n = t._colorMask; 0 !== n && (t._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilFunc(r.EQUAL, i, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.INCR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, 0 !== n && (t._colorMask = n, r.colorMask(0 !== (1 & n), 0 !== (2 & n), 0 !== (4 & n), 0 !== (8 & n))), this._useCurrent() }, e.prototype.pop = function (t) { var e = this.renderer.gl; if (0 === this.getStackLength()) e.disable(e.STENCIL_TEST); else { var r = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null, i = r ? r._colorMask : 15; 0 !== i && (r._colorMask = 0, e.colorMask(!1, !1, !1, !1)), e.stencilOp(e.KEEP, e.KEEP, e.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, 0 !== i && (r._colorMask = i, e.colorMask(0 !== (1 & i), 0 !== (2 & i), 0 !== (4 & i), 0 !== (8 & i))), this._useCurrent() } }, e.prototype._useCurrent = function () { var t = this.renderer.gl; t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP) }, e }(oe), le = function () { function t(t) { this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new h.y3, this.transform = null } return t.prototype.update = function (t, e, r, i) { this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, i), this.transform && this.projectionMatrix.append(this.transform); var n = this.renderer; n.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, n.globalUniforms.update(), n.shader.shader && n.shader.syncUniformGroup(n.shader.shader.uniforms.globals) }, t.prototype.calculateProjection = function (t, e, r, i) { var n = this.projectionMatrix, o = i ? -1 : 1; n.identity(), n.a = 1 / e.width * 2, n.d = o * (1 / e.height * 2), n.tx = -1 - e.x * n.a, n.ty = -o - e.y * n.d }, t.prototype.setTransform = function (t) { }, t.prototype.destroy = function () { this.renderer = null }, t }(), ce = new h.Ae, de = new h.Ae, fe = function () { function t(t) { this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new h.Ae, this.destinationFrame = new h.Ae, this.viewportFrame = new h.Ae } return t.prototype.bind = function (t, e, r) { void 0 === t && (t = null); var i, n, o, s = this.renderer; this.current = t, t ? (i = t.baseTexture, o = i.resolution, e || (ce.width = t.frame.width, ce.height = t.frame.height, e = ce), r || (de.x = t.frame.x, de.y = t.frame.y, de.width = e.width, de.height = e.height, r = de), n = i.framebuffer) : (o = s.resolution, e || (ce.width = s.screen.width, ce.height = s.screen.height, e = ce), r || (r = ce, r.width = e.width, r.height = e.height)); var a = this.viewportFrame; a.x = r.x * o, a.y = r.y * o, a.width = r.width * o, a.height = r.height * o, t || (a.y = s.view.height - (a.y + a.height)), a.ceil(), this.renderer.framebuffer.bind(n, a), this.renderer.projection.update(r, e, o, !n), t ? this.renderer.mask.setMaskStack(i.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(r) }, t.prototype.clear = function (t, e) { t = this.current ? t || this.current.baseTexture.clearColor : t || this.clearColor; var r = this.destinationFrame, i = this.current ? this.current.baseTexture : this.renderer.screen, n = r.width !== i.width || r.height !== i.height; if (n) { var o = this.viewportFrame, s = o.x, a = o.y, u = o.width, h = o.height; s = Math.round(s), a = Math.round(a), u = Math.round(u), h = Math.round(h), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(s, a, u, h) } this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), n && this.renderer.scissor.pop() }, t.prototype.resize = function () { this.bind(null) }, t.prototype.reset = function () { this.bind(null) }, t.prototype.destroy = function () { this.renderer = null }, t }(); function pe(t, e, r, i, n) { r.buffer.update(n) } var _e = { float: "\n        data[offset] = v;\n    ", vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ", vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ", vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ", mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ", mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ", mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    " }, me = { float: 4, vec2: 8, vec3: 12, vec4: 16, int: 4, ivec2: 8, ivec3: 12, ivec4: 16, uint: 4, uvec2: 8, uvec3: 12, uvec4: 16, bool: 4, bvec2: 8, bvec3: 12, bvec4: 16, mat2: 32, mat3: 48, mat4: 64 }; function ge(t) { for (var e = t.map((function (t) { return { data: t, offset: 0, dataLen: 0, dirty: 0 } })), r = 0, i = 0, n = 0, o = 0; o < e.length; o++) { var s = e[o]; if (r = me[s.data.type], s.data.size > 1 && (r = Math.max(r, 16) * s.data.size), s.dataLen = r, i % r !== 0 && i < 16) { var a = i % r % 16; i += a, n += a } i + r > 16 ? (n = 16 * Math.ceil(n / 16), s.offset = n, n += r, i = r) : (s.offset = n, i += r, n += r) } return n = 16 * Math.ceil(n / 16), { uboElements: e, size: n } } function ve(t, e) { var r = []; for (var i in t) e[i] && r.push(e[i]); return r.sort((function (t, e) { return t.index - e.index })), r } function ye(t, e) { if (!t.autoManage) return { size: 0, syncFunc: pe }; for (var r = ve(t.uniforms, e), i = ge(r), n = i.uboElements, o = i.size, s = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "], a = 0; a < n.length; a++) { for (var u = n[a], h = t.uniforms[u.data.name], l = u.data.name, c = !1, d = 0; d < Ot.length; d++) { var f = Ot[d]; if (f.codeUbo && f.test(u.data, h)) { s.push("offset = " + u.offset / 4 + ";", Ot[d].codeUbo(u.data.name, h)), c = !0; break } } if (!c) if (u.data.size > 1) { var p = St(u.data.type), _ = Math.max(me[u.data.type] / 16, 1), m = p / _, g = (4 - m % 4) % 4; s.push("\n                cv = ud." + l + ".value;\n                v = uv." + l + ";\n                offset = " + u.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + u.data.size * _ + "; i++)\n                {\n                    for(var j = 0; j < " + m + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + g + ";\n                }\n\n                ") } else { var v = _e[u.data.type]; s.push("\n                cv = ud." + l + ".value;\n                v = uv." + l + ";\n                offset = " + u.offset / 4 + ";\n                " + v + ";\n                ") } } return s.push("\n       renderer.buffer.update(buffer);\n    "), { size: o, syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", s.join("\n")) } } var be = function () { function t() { } return t }(), xe = function () { function t(t, e) { this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {} } return t.prototype.destroy = function () { this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null }, t }(); function Te(t, e) { for (var r = {}, i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), n = 0; n < i; n++) { var o = e.getActiveAttrib(t, n); if (0 !== o.name.indexOf("gl_")) { var s = Rt(e, o.type), a = { type: s, name: o.name, size: St(s), location: e.getAttribLocation(t, o.name) }; r[o.name] = a } } return r } function Ee(t, e) { for (var r = {}, i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), n = 0; n < i; n++) { var o = e.getActiveUniform(t, n), s = o.name.replace(/\[.*?\]$/, ""), a = !!o.name.match(/\[.*?\]$/), u = Rt(e, o.type); r[s] = { name: s, index: n, type: u, size: o.size, isArray: a, value: mt(u, o.size) } } return r } function Se(t, e) { var r = dt(t, t.VERTEX_SHADER, e.vertexSrc), i = dt(t, t.FRAGMENT_SHADER, e.fragmentSrc), n = t.createProgram(); if (t.attachShader(n, r), t.attachShader(n, i), t.linkProgram(n), t.getProgramParameter(n, t.LINK_STATUS) || pt(t, n, r, i), e.attributeData = Te(n, t), e.uniformData = Ee(n, t), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) { var o = Object.keys(e.attributeData); o.sort((function (t, e) { return t > e ? 1 : -1 })); for (var s = 0; s < o.length; s++)e.attributeData[o[s]].location = s, t.bindAttribLocation(n, s, o[s]); t.linkProgram(n) } t.deleteShader(r), t.deleteShader(i); var a = {}; for (var s in e.uniformData) { var u = e.uniformData[s]; a[s] = { location: t.getUniformLocation(n, s), value: mt(u.type, u.size) } } var h = new xe(n, a); return h } var we = 0, Ae = { textureCount: 0, uboCount: 0 }, Re = function () { function t(t) { this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = we++ } return t.prototype.systemCheck = function () { if (!Nt()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.") }, t.prototype.contextChange = function (t) { this.gl = t, this.reset() }, t.prototype.bind = function (t, e) { t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms; var r = t.program, i = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t); return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(i.program)), e || (Ae.textureCount = 0, Ae.uboCount = 0, this.syncUniformGroup(t.uniformGroup, Ae)), i }, t.prototype.setUniforms = function (t) { var e = this.shader.program, r = e.glPrograms[this.renderer.CONTEXT_UID]; e.syncUniforms(r.uniformData, t, this.renderer) }, t.prototype.syncUniformGroup = function (t, e) { var r = this.getGlProgram(); t.static && t.dirtyId === r.uniformDirtyGroups[t.id] || (r.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e)) }, t.prototype.syncUniforms = function (t, e, r) { var i = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t); i(e.uniformData, t.uniforms, this.renderer, r) }, t.prototype.createSyncGroups = function (t) { var e = this.getSignature(t, this.shader.program.uniformData, "u"); return this.cache[e] || (this.cache[e] = Mt(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id] }, t.prototype.syncUniformBufferGroup = function (t, e) { var r = this.getGlProgram(); if (!t.static || 0 !== t.dirtyId || !r.uniformGroups[t.id]) { t.dirtyId = 0; var i = r.uniformGroups[t.id] || this.createSyncBufferGroup(t, r, e); t.buffer.update(), i(r.uniformData, t.uniforms, this.renderer, Ae, t.buffer) } this.renderer.buffer.bindBufferBase(t.buffer, r.uniformBufferBindings[e]) }, t.prototype.createSyncBufferGroup = function (t, e, r) { var i = this.renderer.gl; this.renderer.buffer.bind(t.buffer); var n = this.gl.getUniformBlockIndex(e.program, r); e.uniformBufferBindings[r] = this.shader.uniformBindCount, i.uniformBlockBinding(e.program, n, this.shader.uniformBindCount), this.shader.uniformBindCount++; var o = this.getSignature(t, this.shader.program.uniformData, "ubo"), s = this._uboCache[o]; if (s || (s = this._uboCache[o] = ye(t, this.shader.program.uniformData)), t.autoManage) { var a = new Float32Array(s.size / 4); t.buffer.update(a) } return e.uniformGroups[t.id] = s.syncFunc, e.uniformGroups[t.id] }, t.prototype.getSignature = function (t, e, r) { var i = t.uniforms, n = [r + "-"]; for (var o in i) n.push(o), e[o] && n.push(e[o].type); return n.join("-") }, t.prototype.getGlProgram = function () { return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null }, t.prototype.generateProgram = function (t) { var e = this.gl, r = t.program, i = Se(e, r); return r.glPrograms[this.renderer.CONTEXT_UID] = i, i }, t.prototype.reset = function () { this.program = null, this.shader = null }, t.prototype.disposeShader = function (t) { this.shader === t && (this.shader = null) }, t.prototype.destroy = function () { this.renderer = null, this.destroyed = !0 }, t }(); function Oe(t, e) { return void 0 === e && (e = []), e[n.T$.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.ADD] = [t.ONE, t.ONE], e[n.T$.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.NONE] = [0, 0], e[n.T$.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], e[n.T$.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[n.T$.SRC_IN] = [t.DST_ALPHA, t.ZERO], e[n.T$.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO], e[n.T$.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[n.T$.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE], e[n.T$.DST_IN] = [t.ZERO, t.SRC_ALPHA], e[n.T$.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], e[n.T$.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA], e[n.T$.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[n.T$.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD], e } var Ie = 0, Pe = 1, Me = 2, Ce = 3, De = 4, Le = 5, Fe = function () { function t() { this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = n.T$.NONE, this._blendEq = !1, this.map = [], this.map[Ie] = this.setBlend, this.map[Pe] = this.setOffset, this.map[Me] = this.setCullFace, this.map[Ce] = this.setDepthTest, this.map[De] = this.setFrontFace, this.map[Le] = this.setDepthMask, this.checks = [], this.defaultState = new qt, this.defaultState.blend = !0 } return t.prototype.contextChange = function (t) { this.gl = t, this.blendModes = Oe(t), this.set(this.defaultState), this.reset() }, t.prototype.set = function (t) { if (t = t || this.defaultState, this.stateId !== t.data) { var e = this.stateId ^ t.data, r = 0; while (e) 1 & e && this.map[r].call(this, !!(t.data & 1 << r)), e >>= 1, r++; this.stateId = t.data } for (r = 0; r < this.checks.length; r++)this.checks[r](this, t) }, t.prototype.forceState = function (t) { t = t || this.defaultState; for (var e = 0; e < this.map.length; e++)this.map[e].call(this, !!(t.data & 1 << e)); for (e = 0; e < this.checks.length; e++)this.checks[e](this, t); this.stateId = t.data }, t.prototype.setBlend = function (e) { this.updateCheck(t.checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND) }, t.prototype.setOffset = function (e) { this.updateCheck(t.checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL) }, t.prototype.setDepthTest = function (t) { this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST) }, t.prototype.setDepthMask = function (t) { this.gl.depthMask(t) }, t.prototype.setCullFace = function (t) { this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE) }, t.prototype.setFrontFace = function (t) { this.gl.frontFace(this.gl[t ? "CW" : "CCW"]) }, t.prototype.setBlendMode = function (t) { if (t !== this.blendMode) { this.blendMode = t; var e = this.blendModes[t], r = this.gl; 2 === e.length ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), 6 === e.length ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD)) } }, t.prototype.setPolygonOffset = function (t, e) { this.gl.polygonOffset(t, e) }, t.prototype.reset = function () { this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0) }, t.prototype.updateCheck = function (t, e) { var r = this.checks.indexOf(t); e && -1 === r ? this.checks.push(t) : e || -1 === r || this.checks.splice(r, 1) }, t.checkBlendMode = function (t, e) { t.setBlendMode(e.blendMode) }, t.checkPolygonOffset = function (t, e) { t.setPolygonOffset(1, e.polygonOffset) }, t.prototype.destroy = function () { this.gl = null }, t }(), Ne = function () { function t(t) { this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = i.Xd.GC_MAX_IDLE, this.checkCountMax = i.Xd.GC_MAX_CHECK_COUNT, this.mode = i.Xd.GC_MODE } return t.prototype.postrender = function () { this.renderer.renderingToScreen && (this.count++, this.mode !== n.UN.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run()))) }, t.prototype.run = function () { for (var t = this.renderer.texture, e = t.managedTextures, r = !1, i = 0; i < e.length; i++) { var n = e[i]; !n.framebuffer && this.count - n.touched > this.maxIdle && (t.destroyTexture(n, !0), e[i] = null, r = !0) } if (r) { var o = 0; for (i = 0; i < e.length; i++)null !== e[i] && (e[o++] = e[i]); e.length = o } }, t.prototype.unload = function (t) { var e = this.renderer.texture, r = t._texture; r && !r.framebuffer && e.destroyTexture(r); for (var i = t.children.length - 1; i >= 0; i--)this.unload(t.children[i]) }, t.prototype.destroy = function () { this.renderer = null }, t }(); function Be(t) { var e, r, i, o, s, a, u, h, l, c, d, f, p, _, m, g, v, y, b, x, T, E, S; return "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext ? (e = {}, e[n.vK.UNSIGNED_BYTE] = (r = {}, r[n.I2.RGBA] = t.RGBA8, r[n.I2.RGB] = t.RGB8, r[n.I2.RG] = t.RG8, r[n.I2.RED] = t.R8, r[n.I2.RGBA_INTEGER] = t.RGBA8UI, r[n.I2.RGB_INTEGER] = t.RGB8UI, r[n.I2.RG_INTEGER] = t.RG8UI, r[n.I2.RED_INTEGER] = t.R8UI, r[n.I2.ALPHA] = t.ALPHA, r[n.I2.LUMINANCE] = t.LUMINANCE, r[n.I2.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA, r), e[n.vK.BYTE] = (i = {}, i[n.I2.RGBA] = t.RGBA8_SNORM, i[n.I2.RGB] = t.RGB8_SNORM, i[n.I2.RG] = t.RG8_SNORM, i[n.I2.RED] = t.R8_SNORM, i[n.I2.RGBA_INTEGER] = t.RGBA8I, i[n.I2.RGB_INTEGER] = t.RGB8I, i[n.I2.RG_INTEGER] = t.RG8I, i[n.I2.RED_INTEGER] = t.R8I, i), e[n.vK.UNSIGNED_SHORT] = (o = {}, o[n.I2.RGBA_INTEGER] = t.RGBA16UI, o[n.I2.RGB_INTEGER] = t.RGB16UI, o[n.I2.RG_INTEGER] = t.RG16UI, o[n.I2.RED_INTEGER] = t.R16UI, o[n.I2.DEPTH_COMPONENT] = t.DEPTH_COMPONENT16, o), e[n.vK.SHORT] = (s = {}, s[n.I2.RGBA_INTEGER] = t.RGBA16I, s[n.I2.RGB_INTEGER] = t.RGB16I, s[n.I2.RG_INTEGER] = t.RG16I, s[n.I2.RED_INTEGER] = t.R16I, s), e[n.vK.UNSIGNED_INT] = (a = {}, a[n.I2.RGBA_INTEGER] = t.RGBA32UI, a[n.I2.RGB_INTEGER] = t.RGB32UI, a[n.I2.RG_INTEGER] = t.RG32UI, a[n.I2.RED_INTEGER] = t.R32UI, a[n.I2.DEPTH_COMPONENT] = t.DEPTH_COMPONENT24, a), e[n.vK.INT] = (u = {}, u[n.I2.RGBA_INTEGER] = t.RGBA32I, u[n.I2.RGB_INTEGER] = t.RGB32I, u[n.I2.RG_INTEGER] = t.RG32I, u[n.I2.RED_INTEGER] = t.R32I, u), e[n.vK.FLOAT] = (h = {}, h[n.I2.RGBA] = t.RGBA32F, h[n.I2.RGB] = t.RGB32F, h[n.I2.RG] = t.RG32F, h[n.I2.RED] = t.R32F, h[n.I2.DEPTH_COMPONENT] = t.DEPTH_COMPONENT32F, h), e[n.vK.HALF_FLOAT] = (l = {}, l[n.I2.RGBA] = t.RGBA16F, l[n.I2.RGB] = t.RGB16F, l[n.I2.RG] = t.RG16F, l[n.I2.RED] = t.R16F, l), e[n.vK.UNSIGNED_SHORT_5_6_5] = (c = {}, c[n.I2.RGB] = t.RGB565, c), e[n.vK.UNSIGNED_SHORT_4_4_4_4] = (d = {}, d[n.I2.RGBA] = t.RGBA4, d), e[n.vK.UNSIGNED_SHORT_5_5_5_1] = (f = {}, f[n.I2.RGBA] = t.RGB5_A1, f), e[n.vK.UNSIGNED_INT_2_10_10_10_REV] = (p = {}, p[n.I2.RGBA] = t.RGB10_A2, p[n.I2.RGBA_INTEGER] = t.RGB10_A2UI, p), e[n.vK.UNSIGNED_INT_10F_11F_11F_REV] = (_ = {}, _[n.I2.RGB] = t.R11F_G11F_B10F, _), e[n.vK.UNSIGNED_INT_5_9_9_9_REV] = (m = {}, m[n.I2.RGB] = t.RGB9_E5, m), e[n.vK.UNSIGNED_INT_24_8] = (g = {}, g[n.I2.DEPTH_STENCIL] = t.DEPTH24_STENCIL8, g), e[n.vK.FLOAT_32_UNSIGNED_INT_24_8_REV] = (v = {}, v[n.I2.DEPTH_STENCIL] = t.DEPTH32F_STENCIL8, v), S = e) : (y = {}, y[n.vK.UNSIGNED_BYTE] = (b = {}, b[n.I2.RGBA] = t.RGBA, b[n.I2.RGB] = t.RGB, b[n.I2.ALPHA] = t.ALPHA, b[n.I2.LUMINANCE] = t.LUMINANCE, b[n.I2.LUMINANCE_ALPHA] = t.LUMINANCE_ALPHA, b), y[n.vK.UNSIGNED_SHORT_5_6_5] = (x = {}, x[n.I2.RGB] = t.RGB, x), y[n.vK.UNSIGNED_SHORT_4_4_4_4] = (T = {}, T[n.I2.RGBA] = t.RGBA, T), y[n.vK.UNSIGNED_SHORT_5_5_5_1] = (E = {}, E[n.I2.RGBA] = t.RGBA, E), S = y), S } var Ue = function () { function t(t) { this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = n.vK.UNSIGNED_BYTE, this.internalFormat = n.I2.RGBA, this.samplerType = 0 } return t }(), ke = function () { function t(t) { this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new y, this.hasIntegerTextures = !1 } return t.prototype.contextChange = function () { var t = this.gl = this.renderer.gl; this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = Be(t); var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS); this.boundTextures.length = e; for (var r = 0; r < e; r++)this.boundTextures[r] = null; this.emptyTextures = {}; var i = new Ue(t.createTexture()); t.bindTexture(t.TEXTURE_2D, i.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = i, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new Ue(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture); for (r = 0; r < 6; r++)t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null); t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR); for (r = 0; r < this.boundTextures.length; r++)this.bind(null, r) }, t.prototype.bind = function (t, e) { void 0 === e && (e = 0); var r = this.gl; if (t = null === t || void 0 === t ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) { t.touched = this.renderer.textureGC.count; var i = t._glTextures[this.CONTEXT_UID] || this.initTexture(t); this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, i.texture)), i.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)) : i.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t } else this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null }, t.prototype.reset = function () { this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1; for (var t = 0; t < this.boundTextures.length; t++)this.boundTextures[t] = this.unknownTexture }, t.prototype.unbind = function (t) { var e = this, r = e.gl, i = e.boundTextures; if (this._unknownBoundTextures) { this._unknownBoundTextures = !1; for (var n = 0; n < i.length; n++)i[n] === this.unknownTexture && this.bind(null, n) } for (n = 0; n < i.length; n++)i[n] === t && (this.currentLocation !== n && (r.activeTexture(r.TEXTURE0 + n), this.currentLocation = n), r.bindTexture(t.target, this.emptyTextures[t.target].texture), i[n] = null) }, t.prototype.ensureSamplerType = function (t) { var e = this, r = e.boundTextures, i = e.hasIntegerTextures, o = e.CONTEXT_UID; if (i) for (var s = t - 1; s >= 0; --s) { var a = r[s]; if (a) { var u = a._glTextures[o]; u.samplerType !== n.oT.FLOAT && this.renderer.texture.unbind(a) } } }, t.prototype.initTexture = function (t) { var e = new Ue(this.gl.createTexture()); return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e }, t.prototype.initTextureType = function (t, e) { var r, i; e.internalFormat = null !== (i = null === (r = this.internalFormats[t.type]) || void 0 === r ? void 0 : r[t.format]) && void 0 !== i ? i : t.format, 2 === this.webGLVersion && t.type === n.vK.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type }, t.prototype.updateTexture = function (t) { var e = t._glTextures[this.CONTEXT_UID]; if (e) { var r = this.renderer; if (this.initTextureType(t, e), t.resource && t.resource.upload(r, t, e)) e.samplerType !== n.oT.FLOAT && (this.hasIntegerTextures = !0); else { var i = t.realWidth, o = t.realHeight, s = r.gl; (e.width !== i || e.height !== o || e.dirtyId < 0) && (e.width = i, e.height = o, s.texImage2D(t.target, 0, e.internalFormat, i, o, 0, t.format, e.type, null)) } t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId } }, t.prototype.destroyTexture = function (t, e) { var r = this.gl; if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) { var i = this.managedTextures.indexOf(t); -1 !== i && (0, o.removeItems)(this.managedTextures, i, 1) } }, t.prototype.updateTextureStyle = function (t) { var e = t._glTextures[this.CONTEXT_UID]; e && (t.mipmap !== n.WB.POW2 && 2 === this.webGLVersion || t.isPowerOfTwo ? e.mipmap = t.mipmap >= 1 : e.mipmap = !1, 2 === this.webGLVersion || t.isPowerOfTwo ? e.wrapMode = t.wrapMode : e.wrapMode = n.Nt.CLAMP, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId) }, t.prototype.setStyle = function (t, e) { var r = this.gl; if (e.mipmap && t.mipmap !== n.WB.ON_MANUAL && r.generateMipmap(t.target), r.texParameteri(t.target, r.TEXTURE_WRAP_S, e.wrapMode), r.texParameteri(t.target, r.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) { r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === n.aH.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST); var i = this.renderer.context.extensions.anisotropicFiltering; if (i && t.anisotropicLevel > 0 && t.scaleMode === n.aH.LINEAR) { var o = Math.min(t.anisotropicLevel, r.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)); r.texParameterf(t.target, i.TEXTURE_MAX_ANISOTROPY_EXT, o) } } else r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === n.aH.LINEAR ? r.LINEAR : r.NEAREST); r.texParameteri(t.target, r.TEXTURE_MAG_FILTER, t.scaleMode === n.aH.LINEAR ? r.LINEAR : r.NEAREST) }, t.prototype.destroy = function () { this.renderer = null }, t }(), Ge = { __proto__: null, FilterSystem: et, BatchSystem: it, ContextSystem: ot, FramebufferSystem: ut, GeometrySystem: lt, MaskSystem: ne, ScissorSystem: ue, StencilSystem: he, ProjectionSystem: le, RenderTextureSystem: fe, ShaderSystem: Re, StateSystem: Fe, TextureGCSystem: Ne, TextureSystem: ke }, Xe = new h.y3, je = function (t) { function e(e, r) { void 0 === e && (e = n.N3.UNKNOWN); var s = t.call(this) || this; return r = Object.assign({}, i.Xd.RENDER_OPTIONS, r), s.options = r, s.type = e, s.screen = new h.Ae(0, 0, r.width, r.height), s.view = r.view || i.Xd.ADAPTER.createCanvas(), s.resolution = r.resolution || i.Xd.RESOLUTION, s.useContextAlpha = r.useContextAlpha, s.autoDensity = !!r.autoDensity, s.preserveDrawingBuffer = r.preserveDrawingBuffer, s.clearBeforeRender = r.clearBeforeRender, s._backgroundColor = 0, s._backgroundColorRgba = [0, 0, 0, 1], s._backgroundColorString = "#000000", s.backgroundColor = r.backgroundColor || s._backgroundColor, s.backgroundAlpha = r.backgroundAlpha, void 0 !== r.transparent && ((0, o.deprecation)("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), s.useContextAlpha = r.transparent, s.backgroundAlpha = r.transparent ? 0 : 1), s._lastObjectRendered = null, s.plugins = {}, s } return f(e, t), e.prototype.initPlugins = function (t) { for (var e in t) this.plugins[e] = new t[e](this) }, Object.defineProperty(e.prototype, "width", { get: function () { return this.view.width }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this.view.height }, enumerable: !1, configurable: !0 }), e.prototype.resize = function (t, e) { this.view.width = Math.round(t * this.resolution), this.view.height = Math.round(e * this.resolution); var r = this.view.width / this.resolution, i = this.view.height / this.resolution; this.screen.width = r, this.screen.height = i, this.autoDensity && (this.view.style.width = r + "px", this.view.style.height = i + "px"), this.emit("resize", r, i) }, e.prototype.generateTexture = function (t, e, r, i) { void 0 === e && (e = {}), "number" === typeof e && ((0, o.deprecation)("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), e = { scaleMode: e, resolution: r, region: i }); var n = e.region, s = _(e, ["region"]); i = n || t.getLocalBounds(null, !0), 0 === i.width && (i.width = 1), 0 === i.height && (i.height = 1); var a = B.create(p({ width: i.width, height: i.height }, s)); return Xe.tx = -i.x, Xe.ty = -i.y, this.render(t, { renderTexture: a, clear: !1, transform: Xe, skipUpdateTransform: !!t.parent }), a }, e.prototype.destroy = function (t) { for (var e in this.plugins) this.plugins[e].destroy(), this.plugins[e] = null; t && this.view.parentNode && this.view.parentNode.removeChild(this.view); var r = this; r.plugins = null, r.type = n.N3.UNKNOWN, r.view = null, r.screen = null, r._tempDisplayObjectParent = null, r.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null }, Object.defineProperty(e.prototype, "backgroundColor", { get: function () { return this._backgroundColor }, set: function (t) { this._backgroundColor = t, this._backgroundColorString = (0, o.hex2string)(t), (0, o.hex2rgb)(t, this._backgroundColorRgba) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "backgroundAlpha", { get: function () { return this._backgroundColorRgba[3] }, set: function (t) { this._backgroundColorRgba[3] = t }, enumerable: !1, configurable: !0 }), e }(o.EventEmitter), He = function () { function t(t) { this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0 } return t }(), Ve = function () { function t(t) { this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {} } return t.prototype.destroy = function () { this.renderer = null }, t.prototype.contextChange = function () { this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID }, t.prototype.bind = function (t) { var e = this, r = e.gl, i = e.CONTEXT_UID, n = t._glBuffers[i] || this.createGLBuffer(t); r.bindBuffer(t.type, n.buffer) }, t.prototype.bindBufferBase = function (t, e) { var r = this, i = r.gl, n = r.CONTEXT_UID; if (this.boundBufferBases[e] !== t) { var o = t._glBuffers[n] || this.createGLBuffer(t); this.boundBufferBases[e] = t, i.bindBufferBase(i.UNIFORM_BUFFER, e, o.buffer) } }, t.prototype.bindBufferRange = function (t, e, r) { var i = this, n = i.gl, o = i.CONTEXT_UID; r = r || 0; var s = t._glBuffers[o] || this.createGLBuffer(t); n.bindBufferRange(n.UNIFORM_BUFFER, e || 0, s.buffer, 256 * r, 256) }, t.prototype.update = function (t) { var e = this, r = e.gl, i = e.CONTEXT_UID, n = t._glBuffers[i]; if (t._updateID !== n.updateID) if (n.updateID = t._updateID, r.bindBuffer(t.type, n.buffer), n.byteLength >= t.data.byteLength) r.bufferSubData(t.type, 0, t.data); else { var o = t.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW; n.byteLength = t.data.byteLength, r.bufferData(t.type, t.data, o) } }, t.prototype.dispose = function (t, e) { if (this.managedBuffers[t.id]) { delete this.managedBuffers[t.id]; var r = t._glBuffers[this.CONTEXT_UID], i = this.gl; t.disposeRunner.remove(this), r && (e || i.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID]) } }, t.prototype.disposeAll = function (t) { for (var e = Object.keys(this.managedBuffers), r = 0; r < e.length; r++)this.dispose(this.managedBuffers[e[r]], t) }, t.prototype.createGLBuffer = function (t) { var e = this, r = e.CONTEXT_UID, i = e.gl; return t._glBuffers[r] = new He(i.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[r] }, t }(), ze = function (t) { function e(r) { var i = t.call(this, n.N3.WEBGL, r) || this; return r = i.options, i.gl = null, i.CONTEXT_UID = 0, i.runners = { destroy: new a.R("destroy"), contextChange: new a.R("contextChange"), reset: new a.R("reset"), update: new a.R("update"), postrender: new a.R("postrender"), prerender: new a.R("prerender"), resize: new a.R("resize") }, i.runners.contextChange.add(i), i.globalUniforms = new Z({ projectionMatrix: new h.y3 }, !0), i.addSystem(ne, "mask").addSystem(ot, "context").addSystem(Fe, "state").addSystem(Re, "shader").addSystem(ke, "texture").addSystem(Ve, "buffer").addSystem(lt, "geometry").addSystem(ut, "framebuffer").addSystem(ue, "scissor").addSystem(he, "stencil").addSystem(le, "projection").addSystem(Ne, "textureGC").addSystem(et, "filter").addSystem(fe, "renderTexture").addSystem(it, "batch"), i.initPlugins(e.__plugins), i.multisample = void 0, r.context ? i.context.initFromContext(r.context) : i.context.initFromOptions({ alpha: !!i.useContextAlpha, antialias: r.antialias, premultipliedAlpha: i.useContextAlpha && "notMultiplied" !== i.useContextAlpha, stencil: !0, preserveDrawingBuffer: r.preserveDrawingBuffer, powerPreference: i.options.powerPreference }), i.renderingToScreen = !0, (0, o.sayHello)(2 === i.context.webGLVersion ? "WebGL 2" : "WebGL 1"), i.resize(i.options.width, i.options.height), i } return f(e, t), e.create = function (t) { if ((0, o.isWebGLSupported)()) return new e(t); throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.') }, e.prototype.contextChange = function () { var t, e = this.gl; if (1 === this.context.webGLVersion) { var r = e.getParameter(e.FRAMEBUFFER_BINDING); e.bindFramebuffer(e.FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, r) } else { r = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING); e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, r) } t >= n.G5.HIGH ? this.multisample = n.G5.HIGH : t >= n.G5.MEDIUM ? this.multisample = n.G5.MEDIUM : t >= n.G5.LOW ? this.multisample = n.G5.LOW : this.multisample = n.G5.NONE }, e.prototype.addSystem = function (t, e) { var r = new t(this); if (this[e]) throw new Error('Whoops! The name "' + e + '" is already in use'); for (var i in this[e] = r, this.runners) this.runners[i].add(r); return this }, e.prototype.render = function (t, e) { var r, i, n, s; if (e && (e instanceof B ? ((0, o.deprecation)("6.0.0", "Renderer#render arguments changed, use options instead."), r = e, i = arguments[2], n = arguments[3], s = arguments[4]) : (r = e.renderTexture, i = e.clear, n = e.transform, s = e.skipUpdateTransform)), this.renderingToScreen = !r, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = n, !this.context.isLost) { if (r || (this._lastObjectRendered = t), !s) { var a = t.enableTempParent(); t.updateTransform(), t.disableTempParent(a) } this.renderTexture.bind(r), this.batch.currentRenderer.start(), (void 0 !== i ? i : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), r && r.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender") } }, e.prototype.generateTexture = function (e, r, i, n) { void 0 === r && (r = {}); var o = t.prototype.generateTexture.call(this, e, r, i, n); return this.framebuffer.blit(), o }, e.prototype.resize = function (e, r) { t.prototype.resize.call(this, e, r), this.runners.resize.emit(this.screen.height, this.screen.width) }, e.prototype.reset = function () { return this.runners.reset.emit(), this }, e.prototype.clear = function () { this.renderTexture.bind(), this.renderTexture.clear() }, e.prototype.destroy = function (e) { for (var r in this.runners.destroy.emit(), this.runners) this.runners[r].destroy(); t.prototype.destroy.call(this, e), this.gl = null }, Object.defineProperty(e.prototype, "extract", { get: function () { return (0, o.deprecation)("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract }, enumerable: !1, configurable: !0 }), e.registerPlugin = function (t, e) { (0, o.deprecation)("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), s.R.add({ name: t, type: s.n.RendererPlugin, ref: e }) }, e.__plugins = {}, e }(je); function Ye(t) { return ze.create(t) } s.R.handleByMap(s.n.RendererPlugin, ze.__plugins); var We = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", $e = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", qe = We, Ke = $e, Ze = function () { function t(t) { (0, o.deprecation)("6.1.0", "System class is deprecated, implemement ISystem interface instead."), this.renderer = t } return t.prototype.destroy = function () { this.renderer = null }, t }(), Je = function () { function t() { this.texArray = null, this.blend = 0, this.type = n.lg.TRIANGLES, this.start = 0, this.size = 0, this.data = null } return t }(), Qe = function () { function t() { this.elements = [], this.ids = [], this.count = 0 } return t.prototype.clear = function () { for (var t = 0; t < this.count; t++)this.elements[t] = null; this.count = 0 }, t }(), tr = function () { function t(t) { "number" === typeof t ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData) } return Object.defineProperty(t.prototype, "int8View", { get: function () { return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "uint8View", { get: function () { return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "int16View", { get: function () { return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "uint16View", { get: function () { return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "int32View", { get: function () { return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View }, enumerable: !1, configurable: !0 }), t.prototype.view = function (t) { return this[t + "View"] }, t.prototype.destroy = function () { this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null }, t.sizeOf = function (t) { switch (t) { case "int8": case "uint8": return 1; case "int16": case "uint16": return 2; case "int32": case "uint32": case "float32": return 4; default: throw new Error(t + " isn't a valid view type") } }, t }(), er = function (t) { function e(e) { var r = t.call(this, e) || this; return r.shaderGenerator = null, r.geometryClass = null, r.vertexSize = null, r.state = qt.for2d(), r.size = 4 * i.Xd.SPRITE_BATCH_SIZE, r._vertexCount = 0, r._indexCount = 0, r._bufferedElements = [], r._bufferedTextures = [], r._bufferSize = 0, r._shader = null, r._packedGeometries = [], r._packedGeometryPoolSize = 2, r._flushId = 0, r._aBuffers = {}, r._iBuffers = {}, r.MAX_TEXTURES = 1, r.renderer.on("prerender", r.onPrerender, r), e.runners.contextChange.add(r), r._dcIndex = 0, r._aIndex = 0, r._iIndex = 0, r._attributeBuffer = null, r._indexBuffer = null, r._tempBoundTextures = [], r } return f(e, t), e.prototype.contextChange = function () { var t = this.renderer.gl; i.Xd.PREFER_ENV === n.Vi.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), i.Xd.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = Ft(this.MAX_TEXTURES, t)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES); for (var e = 0; e < this._packedGeometryPoolSize; e++)this._packedGeometries[e] = new this.geometryClass; this.initFlushBuffers() }, e.prototype.initFlushBuffers = function () { var t = e._drawCallPool, r = e._textureArrayPool, i = this.size / 4, n = Math.floor(i / this.MAX_TEXTURES) + 1; while (t.length < i) t.push(new Je); while (r.length < n) r.push(new Qe); for (var o = 0; o < this.MAX_TEXTURES; o++)this._tempBoundTextures[o] = null }, e.prototype.onPrerender = function () { this._flushId = 0 }, e.prototype.render = function (t) { t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t) }, e.prototype.buildTexturesAndDrawCalls = function () { var t = this, r = t._bufferedTextures, i = t.MAX_TEXTURES, n = e._textureArrayPool, o = this.renderer.batch, s = this._tempBoundTextures, a = this.renderer.textureGC.count, u = ++y._globalBatch, h = 0, l = n[0], c = 0; o.copyBoundTextures(s, i); for (var d = 0; d < this._bufferSize; ++d) { var f = r[d]; r[d] = null, f._batchEnabled !== u && (l.count >= i && (o.boundArray(l, s, u, i), this.buildDrawCalls(l, c, d), c = d, l = n[++h], ++u), f._batchEnabled = u, f.touched = a, l.elements[l.count++] = f) } l.count > 0 && (o.boundArray(l, s, u, i), this.buildDrawCalls(l, c, this._bufferSize), ++h, ++u); for (d = 0; d < s.length; d++)s[d] = null; y._globalBatch = u }, e.prototype.buildDrawCalls = function (t, r, i) { var n = this, s = n._bufferedElements, a = n._attributeBuffer, u = n._indexBuffer, h = n.vertexSize, l = e._drawCallPool, c = this._dcIndex, d = this._aIndex, f = this._iIndex, p = l[c]; p.start = this._iIndex, p.texArray = t; for (var _ = r; _ < i; ++_) { var m = s[_], g = m._texture.baseTexture, v = o.premultiplyBlendMode[g.alphaMode ? 1 : 0][m.blendMode]; s[_] = null, r < _ && p.blend !== v && (p.size = f - p.start, r = _, p = l[++c], p.texArray = t, p.start = f), this.packInterleavedGeometry(m, a, u, d, f), d += m.vertexData.length / 2 * h, f += m.indices.length, p.blend = v } r < i && (p.size = f - p.start, ++c), this._dcIndex = c, this._aIndex = d, this._iIndex = f }, e.prototype.bindAndClearTexArray = function (t) { for (var e = this.renderer.texture, r = 0; r < t.count; r++)e.bind(t.elements[r], t.ids[r]), t.elements[r] = null; t.count = 0 }, e.prototype.updateGeometry = function () { var t = this, e = t._packedGeometries, r = t._attributeBuffer, n = t._indexBuffer; i.Xd.CAN_UPLOAD_SAME_BUFFER ? (e[this._flushId]._buffer.update(r.rawBinaryData), e[this._flushId]._indexBuffer.update(n), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, e[this._flushId] = new this.geometryClass), e[this._flushId]._buffer.update(r.rawBinaryData), e[this._flushId]._indexBuffer.update(n), this.renderer.geometry.bind(e[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++) }, e.prototype.drawBatches = function () { for (var t = this._dcIndex, r = this.renderer, i = r.gl, n = r.state, o = e._drawCallPool, s = null, a = 0; a < t; a++) { var u = o[a], h = u.texArray, l = u.type, c = u.size, d = u.start, f = u.blend; s !== h && (s = h, this.bindAndClearTexArray(h)), this.state.blendMode = f, n.set(this.state), i.drawElements(l, c, i.UNSIGNED_SHORT, 2 * d) } }, e.prototype.flush = function () { 0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0) }, e.prototype.start = function () { this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), i.Xd.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]) }, e.prototype.stop = function () { this.flush() }, e.prototype.destroy = function () { for (var e = 0; e < this._packedGeometryPoolSize; e++)this._packedGeometries[e] && this._packedGeometries[e].destroy(); this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t.prototype.destroy.call(this) }, e.prototype.getAttributeBuffer = function (t) { var e = (0, o.nextPow2)(Math.ceil(t / 8)), r = (0, o.log2)(e), i = 8 * e; this._aBuffers.length <= r && (this._iBuffers.length = r + 1); var n = this._aBuffers[i]; return n || (this._aBuffers[i] = n = new tr(i * this.vertexSize * 4)), n }, e.prototype.getIndexBuffer = function (t) { var e = (0, o.nextPow2)(Math.ceil(t / 12)), r = (0, o.log2)(e), i = 12 * e; this._iBuffers.length <= r && (this._iBuffers.length = r + 1); var n = this._iBuffers[r]; return n || (this._iBuffers[r] = n = new Uint16Array(i)), n }, e.prototype.packInterleavedGeometry = function (t, e, r, i, n) { for (var s = e.uint32View, a = e.float32View, u = i / this.vertexSize, h = t.uvs, l = t.indices, c = t.vertexData, d = t._texture.baseTexture._batchLocation, f = Math.min(t.worldAlpha, 1), p = f < 1 && t._texture.baseTexture.alphaMode ? (0, o.premultiplyTint)(t._tintRGB, f) : t._tintRGB + (255 * f << 24), _ = 0; _ < c.length; _ += 2)a[i++] = c[_], a[i++] = c[_ + 1], a[i++] = h[_], a[i++] = h[_ + 1], s[i++] = p, a[i++] = d; for (_ = 0; _ < l.length; _++)r[n++] = u + l[_] }, e._drawCallPool = [], e._textureArrayPool = [], e }(rt), rr = function () { function t(t, e) { if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0) throw new Error('Fragment template must contain "%count%".'); if (e.indexOf("%forloop%") < 0) throw new Error('Fragment template must contain "%forloop%".') } return t.prototype.generateShader = function (t) { if (!this.programCache[t]) { for (var e = new Int32Array(t), r = 0; r < t; r++)e[r] = r; this.defaultGroupCache[t] = Z.from({ uSamplers: e }, !0); var i = this.fragTemplate; i = i.replace(/%count%/gi, "" + t), i = i.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Xt(this.vertexSrc, i) } var n = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new h.y3, default: this.defaultGroupCache[t] }; return new jt(this.programCache[t], n) }, t.prototype.generateSampleSrc = function (t) { var e = ""; e += "\n", e += "\n"; for (var r = 0; r < t; r++)r > 0 && (e += "\nelse "), r < t - 1 && (e += "if(vTextureId < " + r + ".5)"), e += "\n{", e += "\n\tcolor = texture2D(uSamplers[" + r + "], vTextureCoord);", e += "\n}"; return e += "\n", e += "\n", e }, t }(), ir = function (t) { function e(e) { void 0 === e && (e = !1); var r = t.call(this) || this; return r._buffer = new X(null, e, !1), r._indexBuffer = new X(null, e, !0), r.addAttribute("aVertexPosition", r._buffer, 2, !1, n.vK.FLOAT).addAttribute("aTextureCoord", r._buffer, 2, !1, n.vK.FLOAT).addAttribute("aColor", r._buffer, 4, !0, n.vK.UNSIGNED_BYTE).addAttribute("aTextureId", r._buffer, 1, !0, n.vK.FLOAT).addIndex(r._indexBuffer), r } return f(e, t), e }(W), nr = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n", or = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n", sr = function () { function t() { } return t.create = function (t) { var e = Object.assign({ vertex: nr, fragment: or, geometryClass: ir, vertexSize: 6 }, t), r = e.vertex, i = e.fragment, n = e.vertexSize, o = e.geometryClass; return function (t) { function e(e) { var s = t.call(this, e) || this; return s.shaderGenerator = new rr(r, i), s.geometryClass = o, s.vertexSize = n, s } return f(e, t), e }(er) }, Object.defineProperty(t, "defaultVertexSrc", { get: function () { return nr }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultFragmentTemplate", { get: function () { return or }, enumerable: !1, configurable: !0 }), t }(), ar = sr.create(); Object.assign(ar, { extension: { name: "batch", type: s.n.RendererPlugin } }); var ur = {}, hr = function (t) { Object.defineProperty(ur, t, { get: function () { return (0, o.deprecation)("6.0.0", "PIXI.systems." + t + " has moved to PIXI." + t), I[t] } }) }; for (var lr in I) hr(lr); var cr = {}, dr = function (t) { Object.defineProperty(cr, t, { get: function () { return (0, o.deprecation)("6.0.0", "PIXI.resources." + t + " has moved to PIXI." + t), Ge[t] } }) }; for (var lr in Ge) dr(lr); var fr = "6.5.9"
    }, 9782: function (t, e, r) {
        "use strict"; r.d(e, { Ql: function () { return c }, W2: function () { return f }, YZ: function () { return a }, s$: function () { return l } }); r(7658); var i = r(950), n = r(565), o = r(5506), s = r(8676);
        /*!
         * @pixi/display - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * @pixi/display is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        i.Xd.SORTABLE_CHILDREN = !1; var a = function () { function t() { this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1 } return t.prototype.isEmpty = function () { return this.minX > this.maxX || this.minY > this.maxY }, t.prototype.clear = function () { this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0 }, t.prototype.getRectangle = function (t) { return this.minX > this.maxX || this.minY > this.maxY ? n.Ae.EMPTY : (t = t || new n.Ae(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t) }, t.prototype.addPoint = function (t) { this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y) }, t.prototype.addPointMatrix = function (t, e) { var r = t.a, i = t.b, n = t.c, o = t.d, s = t.tx, a = t.ty, u = r * e.x + n * e.y + s, h = i * e.x + o * e.y + a; this.minX = Math.min(this.minX, u), this.maxX = Math.max(this.maxX, u), this.minY = Math.min(this.minY, h), this.maxY = Math.max(this.maxY, h) }, t.prototype.addQuad = function (t) { var e = this.minX, r = this.minY, i = this.maxX, n = this.maxY, o = t[0], s = t[1]; e = o < e ? o : e, r = s < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, o = t[2], s = t[3], e = o < e ? o : e, r = s < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, o = t[4], s = t[5], e = o < e ? o : e, r = s < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, o = t[6], s = t[7], e = o < e ? o : e, r = s < r ? s : r, i = o > i ? o : i, n = s > n ? s : n, this.minX = e, this.minY = r, this.maxX = i, this.maxY = n }, t.prototype.addFrame = function (t, e, r, i, n) { this.addFrameMatrix(t.worldTransform, e, r, i, n) }, t.prototype.addFrameMatrix = function (t, e, r, i, n) { var o = t.a, s = t.b, a = t.c, u = t.d, h = t.tx, l = t.ty, c = this.minX, d = this.minY, f = this.maxX, p = this.maxY, _ = o * e + a * r + h, m = s * e + u * r + l; c = _ < c ? _ : c, d = m < d ? m : d, f = _ > f ? _ : f, p = m > p ? m : p, _ = o * i + a * r + h, m = s * i + u * r + l, c = _ < c ? _ : c, d = m < d ? m : d, f = _ > f ? _ : f, p = m > p ? m : p, _ = o * e + a * n + h, m = s * e + u * n + l, c = _ < c ? _ : c, d = m < d ? m : d, f = _ > f ? _ : f, p = m > p ? m : p, _ = o * i + a * n + h, m = s * i + u * n + l, c = _ < c ? _ : c, d = m < d ? m : d, f = _ > f ? _ : f, p = m > p ? m : p, this.minX = c, this.minY = d, this.maxX = f, this.maxY = p }, t.prototype.addVertexData = function (t, e, r) { for (var i = this.minX, n = this.minY, o = this.maxX, s = this.maxY, a = e; a < r; a += 2) { var u = t[a], h = t[a + 1]; i = u < i ? u : i, n = h < n ? h : n, o = u > o ? u : o, s = h > s ? h : s } this.minX = i, this.minY = n, this.maxX = o, this.maxY = s }, t.prototype.addVertices = function (t, e, r, i) { this.addVerticesMatrix(t.worldTransform, e, r, i) }, t.prototype.addVerticesMatrix = function (t, e, r, i, n, o) { void 0 === n && (n = 0), void 0 === o && (o = n); for (var s = t.a, a = t.b, u = t.c, h = t.d, l = t.tx, c = t.ty, d = this.minX, f = this.minY, p = this.maxX, _ = this.maxY, m = r; m < i; m += 2) { var g = e[m], v = e[m + 1], y = s * g + u * v + l, b = h * v + a * g + c; d = Math.min(d, y - n), p = Math.max(p, y + n), f = Math.min(f, b - o), _ = Math.max(_, b + o) } this.minX = d, this.minY = f, this.maxX = p, this.maxY = _ }, t.prototype.addBounds = function (t) { var e = this.minX, r = this.minY, i = this.maxX, n = this.maxY; this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > i ? t.maxX : i, this.maxY = t.maxY > n ? t.maxY : n }, t.prototype.addBoundsMask = function (t, e) { var r = t.minX > e.minX ? t.minX : e.minX, i = t.minY > e.minY ? t.minY : e.minY, n = t.maxX < e.maxX ? t.maxX : e.maxX, o = t.maxY < e.maxY ? t.maxY : e.maxY; if (r <= n && i <= o) { var s = this.minX, a = this.minY, u = this.maxX, h = this.maxY; this.minX = r < s ? r : s, this.minY = i < a ? i : a, this.maxX = n > u ? n : u, this.maxY = o > h ? o : h } }, t.prototype.addBoundsMatrix = function (t, e) { this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY) }, t.prototype.addBoundsArea = function (t, e) { var r = t.minX > e.x ? t.minX : e.x, i = t.minY > e.y ? t.minY : e.y, n = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height; if (r <= n && i <= o) { var s = this.minX, a = this.minY, u = this.maxX, h = this.maxY; this.minX = r < s ? r : s, this.minY = i < a ? i : a, this.maxX = n > u ? n : u, this.maxY = o > h ? o : h } }, t.prototype.pad = function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e) }, t.prototype.addFramePad = function (t, e, r, i, n, o) { t -= n, e -= o, r += n, i += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > i ? this.maxY : i }, t }(), u = function (t, e) { return u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, u(t, e) };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function h(t, e) { function r() { this.constructor = t } u(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var l = function (t) { function e() { var e = t.call(this) || this; return e.tempDisplayObjectParent = null, e.transform = new n.wx, e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new a, e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e } return h(e, t), e.mixin = function (t) { for (var r = Object.keys(t), i = 0; i < r.length; ++i) { var n = r[i]; Object.defineProperty(e.prototype, n, Object.getOwnPropertyDescriptor(t, n)) } }, Object.defineProperty(e.prototype, "destroyed", { get: function () { return this._destroyed }, enumerable: !1, configurable: !0 }), e.prototype._recursivePostUpdateTransform = function () { this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform) }, e.prototype.updateTransform = function () { this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha }, e.prototype.getBounds = function (t, e) { return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e || (this._boundsRect || (this._boundsRect = new n.Ae), e = this._boundsRect), this._bounds.getRectangle(e) }, e.prototype.getLocalBounds = function (t) { t || (this._localBoundsRect || (this._localBoundsRect = new n.Ae), t = this._localBoundsRect), this._localBounds || (this._localBounds = new a); var e = this.transform, r = this.parent; this.parent = null, this.transform = this._tempDisplayObjectParent.transform; var i = this._bounds, o = this._boundsID; this._bounds = this._localBounds; var s = this.getBounds(!1, t); return this.parent = r, this.transform = e, this._bounds = i, this._bounds.updateID += this._boundsID - o, s }, e.prototype.toGlobal = function (t, e, r) { return void 0 === r && (r = !1), r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, e) }, e.prototype.toLocal = function (t, e, r, i) { return e && (t = e.toGlobal(t, r, i)), i || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, r) }, e.prototype.setParent = function (t) { if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container"); return t.addChild(this), t }, e.prototype.setTransform = function (t, e, r, i, n, o, s, a, u) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === r && (r = 1), void 0 === i && (i = 1), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === a && (a = 0), void 0 === u && (u = 0), this.position.x = t, this.position.y = e, this.scale.x = r || 1, this.scale.y = i || 1, this.rotation = n, this.skew.x = o, this.skew.y = s, this.pivot.x = a, this.pivot.y = u, this }, e.prototype.destroy = function (t) { this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners() }, Object.defineProperty(e.prototype, "_tempDisplayObjectParent", { get: function () { return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new c), this.tempDisplayObjectParent }, enumerable: !1, configurable: !0 }), e.prototype.enableTempParent = function () { var t = this.parent; return this.parent = this._tempDisplayObjectParent, t }, e.prototype.disableTempParent = function (t) { this.parent = t }, Object.defineProperty(e.prototype, "x", { get: function () { return this.position.x }, set: function (t) { this.transform.position.x = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "y", { get: function () { return this.position.y }, set: function (t) { this.transform.position.y = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "worldTransform", { get: function () { return this.transform.worldTransform }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "localTransform", { get: function () { return this.transform.localTransform }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "position", { get: function () { return this.transform.position }, set: function (t) { this.transform.position.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "scale", { get: function () { return this.transform.scale }, set: function (t) { this.transform.scale.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "pivot", { get: function () { return this.transform.pivot }, set: function (t) { this.transform.pivot.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "skew", { get: function () { return this.transform.skew }, set: function (t) { this.transform.skew.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "rotation", { get: function () { return this.transform.rotation }, set: function (t) { this.transform.rotation = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "angle", { get: function () { return this.transform.rotation * n.jl }, set: function (t) { this.transform.rotation = t * n.ZX }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "zIndex", { get: function () { return this._zIndex }, set: function (t) { this._zIndex = t, this.parent && (this.parent.sortDirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "worldVisible", { get: function () { var t = this; do { if (!t.visible) return !1; t = t.parent } while (t); return !0 }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "mask", { get: function () { return this._mask }, set: function (t) { if (this._mask !== t) { if (this._mask) { var e = this._mask.isMaskData ? this._mask.maskObject : this._mask; e && (e._maskRefCount--, 0 === e._maskRefCount && (e.renderable = !0, e.isMask = !1)) } if (this._mask = t, this._mask) { e = this._mask.isMaskData ? this._mask.maskObject : this._mask; e && (0 === e._maskRefCount && (e.renderable = !1, e.isMask = !0), e._maskRefCount++) } } }, enumerable: !1, configurable: !0 }), e }(o.EventEmitter), c = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.sortDirty = null, e } return h(e, t), e }(l); function d(t, e) { return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex } l.prototype.displayObjectUpdateTransform = l.prototype.updateTransform; var f = function (t) { function e() { var e = t.call(this) || this; return e.children = [], e.sortableChildren = i.Xd.SORTABLE_CHILDREN, e.sortDirty = !1, e } return h(e, t), e.prototype.onChildrenChange = function (t) { }, e.prototype.addChild = function () { for (var t = arguments, e = [], r = 0; r < arguments.length; r++)e[r] = t[r]; if (e.length > 1) for (var i = 0; i < e.length; i++)this.addChild(e[i]); else { var n = e[0]; n.parent && n.parent.removeChild(n), n.parent = this, this.sortDirty = !0, n.transform._parentID = -1, this.children.push(n), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", n, this, this.children.length - 1), n.emit("added", this) } return e[0] }, e.prototype.addChildAt = function (t, e) { if (e < 0 || e > this.children.length) throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length); return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.splice(e, 0, t), this._boundsID++, this.onChildrenChange(e), t.emit("added", this), this.emit("childAdded", t, this, e), t }, e.prototype.swapChildren = function (t, e) { if (t !== e) { var r = this.getChildIndex(t), i = this.getChildIndex(e); this.children[r] = e, this.children[i] = t, this.onChildrenChange(r < i ? r : i) } }, e.prototype.getChildIndex = function (t) { var e = this.children.indexOf(t); if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller"); return e }, e.prototype.setChildIndex = function (t, e) { if (e < 0 || e >= this.children.length) throw new Error("The index " + e + " supplied is out of bounds " + this.children.length); var r = this.getChildIndex(t); (0, o.removeItems)(this.children, r, 1), this.children.splice(e, 0, t), this.onChildrenChange(e) }, e.prototype.getChildAt = function (t) { if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Index (" + t + ") does not exist."); return this.children[t] }, e.prototype.removeChild = function () { for (var t = arguments, e = [], r = 0; r < arguments.length; r++)e[r] = t[r]; if (e.length > 1) for (var i = 0; i < e.length; i++)this.removeChild(e[i]); else { var n = e[0], s = this.children.indexOf(n); if (-1 === s) return null; n.parent = null, n.transform._parentID = -1, (0, o.removeItems)(this.children, s, 1), this._boundsID++, this.onChildrenChange(s), n.emit("removed", this), this.emit("childRemoved", n, this, s) } return e[0] }, e.prototype.removeChildAt = function (t) { var e = this.getChildAt(t); return e.parent = null, e.transform._parentID = -1, (0, o.removeItems)(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), e.emit("removed", this), this.emit("childRemoved", e, this, t), e }, e.prototype.removeChildren = function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = this.children.length); var r, i = t, n = e, o = n - i; if (o > 0 && o <= n) { r = this.children.splice(i, o); for (var s = 0; s < r.length; ++s)r[s].parent = null, r[s].transform && (r[s].transform._parentID = -1); this._boundsID++, this.onChildrenChange(t); for (s = 0; s < r.length; ++s)r[s].emit("removed", this), this.emit("childRemoved", r[s], this, s); return r } if (0 === o && 0 === this.children.length) return []; throw new RangeError("removeChildren: numeric values are outside the acceptable range.") }, e.prototype.sortChildren = function () { for (var t = !1, e = 0, r = this.children.length; e < r; ++e) { var i = this.children[e]; i._lastSortedIndex = e, t || 0 === i.zIndex || (t = !0) } t && this.children.length > 1 && this.children.sort(d), this.sortDirty = !1 }, e.prototype.updateTransform = function () { this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha; for (var t = 0, e = this.children.length; t < e; ++t) { var r = this.children[t]; r.visible && r.updateTransform() } }, e.prototype.calculateBounds = function () { this._bounds.clear(), this._calculateBounds(); for (var t = 0; t < this.children.length; t++) { var e = this.children[t]; if (e.visible && e.renderable) if (e.calculateBounds(), e._mask) { var r = e._mask.isMaskData ? e._mask.maskObject : e._mask; r ? (r.calculateBounds(), this._bounds.addBoundsMask(e._bounds, r._bounds)) : this._bounds.addBounds(e._bounds) } else e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds) } this._bounds.updateID = this._boundsID }, e.prototype.getLocalBounds = function (e, r) { void 0 === r && (r = !1); var i = t.prototype.getLocalBounds.call(this, e); if (!r) for (var n = 0, o = this.children.length; n < o; ++n) { var s = this.children[n]; s.visible && s.updateTransform() } return i }, e.prototype._calculateBounds = function () { }, e.prototype._renderWithCulling = function (t) { var r = t.renderTexture.sourceFrame; if (r.width > 0 && r.height > 0) { var i, n; if (this.cullArea ? (i = this.cullArea, n = this.worldTransform) : this._render !== e.prototype._render && (i = this.getBounds(!0)), i && r.intersects(i, n)) this._render(t); else if (this.cullArea) return; for (var o = 0, s = this.children.length; o < s; ++o) { var a = this.children[o], u = a.cullable; a.cullable = u || !this.cullArea, a.render(t), a.cullable = u } } }, e.prototype.render = function (t) { if (this.visible && !(this.worldAlpha <= 0) && this.renderable) if (this._mask || this.filters && this.filters.length) this.renderAdvanced(t); else if (this.cullable) this._renderWithCulling(t); else { this._render(t); for (var e = 0, r = this.children.length; e < r; ++e)this.children[e].render(t) } }, e.prototype.renderAdvanced = function (t) { var e = this.filters, r = this._mask; if (e) { this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0; for (var i = 0; i < e.length; i++)e[i].enabled && this._enabledFilters.push(e[i]) } var n = e && this._enabledFilters && this._enabledFilters.length || r && (!r.isMaskData || r.enabled && (r.autoDetect || r.type !== s.A7.NONE)); if (n && t.batch.flush(), e && this._enabledFilters && this._enabledFilters.length && t.filter.push(this, this._enabledFilters), r && t.mask.push(this, this._mask), this.cullable) this._renderWithCulling(t); else { this._render(t); i = 0; for (var o = this.children.length; i < o; ++i)this.children[i].render(t) } n && t.batch.flush(), r && t.mask.pop(this), e && this._enabledFilters && this._enabledFilters.length && t.filter.pop() }, e.prototype._render = function (t) { }, e.prototype.destroy = function (e) { t.prototype.destroy.call(this), this.sortDirty = !1; var r = "boolean" === typeof e ? e : e && e.children, i = this.removeChildren(0, this.children.length); if (r) for (var n = 0; n < i.length; ++n)i[n].destroy(e) }, Object.defineProperty(e.prototype, "width", { get: function () { return this.scale.x * this.getLocalBounds().width }, set: function (t) { var e = this.getLocalBounds().width; this.scale.x = 0 !== e ? t / e : 1, this._width = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this.scale.y * this.getLocalBounds().height }, set: function (t) { var e = this.getLocalBounds().height; this.scale.y = 0 !== e ? t / e : 1, this._height = t }, enumerable: !1, configurable: !0 }), e }(l); f.prototype.containerUpdateTransform = f.prototype.updateTransform
    }, 3640: function (t, e, r) {
        "use strict"; r.d(e, { R: function () { return s }, n: function () { return i } }); r(7658);
/*!
 * @pixi/extensions - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var i, n = function () { return n = Object.assign || function (t) { for (var e, r = arguments, i = 1, n = arguments.length; i < n; i++)for (var o in e = r[i], e) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]); return t }, n.apply(this, arguments) }; (function (t) { t["Application"] = "application", t["RendererPlugin"] = "renderer-webgl-plugin", t["CanvasRendererPlugin"] = "renderer-canvas-plugin", t["Loader"] = "loader", t["LoadParser"] = "load-parser", t["ResolveParser"] = "resolve-parser", t["CacheParser"] = "cache-parser", t["DetectionParser"] = "detection-parser" })(i || (i = {})); var o = function (t) { if ("function" === typeof t || "object" === typeof t && t.extension) { if (!t.extension) throw new Error("Extension class must have an extension object"); var e = "object" !== typeof t.extension ? { type: t.extension } : t.extension; t = n(n({}, e), { ref: t }) } if ("object" !== typeof t) throw new Error("Invalid extension type"); return t = n({}, t), "string" === typeof t.type && (t.type = [t.type]), t }, s = { _addHandlers: null, _removeHandlers: null, _queue: {}, remove: function () { for (var t = arguments, e = this, r = [], i = 0; i < arguments.length; i++)r[i] = t[i]; return r.map(o).forEach((function (t) { t.type.forEach((function (r) { var i, n; return null === (n = (i = e._removeHandlers)[r]) || void 0 === n ? void 0 : n.call(i, t) })) })), this }, add: function () { for (var t = arguments, e = this, r = [], i = 0; i < arguments.length; i++)r[i] = t[i]; return r.map(o).forEach((function (t) { t.type.forEach((function (r) { var i = e._addHandlers, n = e._queue; i[r] ? i[r](t) : (n[r] = n[r] || [], n[r].push(t)) })) })), this }, handle: function (t, e, r) { var i = this._addHandlers = this._addHandlers || {}, n = this._removeHandlers = this._removeHandlers || {}; if (i[t] || n[t]) throw new Error("Extension type " + t + " already has a handler"); i[t] = e, n[t] = r; var o = this._queue; return o[t] && (o[t].forEach((function (t) { return e(t) })), delete o[t]), this }, handleByMap: function (t, e) { return this.handle(t, (function (t) { e[t.name] = t.ref }), (function (t) { delete e[t.name] })) }, handleByList: function (t, e) { return this.handle(t, (function (r) { var n, o; e.includes(r.ref) || (e.push(r.ref), t === i.Loader && (null === (o = (n = r.ref).add) || void 0 === o || o.call(n))) }), (function (t) { var r = e.indexOf(t.ref); -1 !== r && e.splice(r, 1) })) } }
    }, 565: function (t, e, r) { "use strict"; r.d(e, { AB: function () { return p }, Ae: function () { return h }, Cd: function () { return l }, E9: function () { return a }, HS: function () { return i }, Lv: function () { return S }, Pj: function () { return c }, ZX: function () { return s }, _b: function () { return n }, c9: function () { return f }, jl: function () { return o }, mg: function () { return d }, wx: function () { return w }, y3: function () { return _ } }); r(7658), r(3767), r(8585), r(8696); var i, n = 2 * Math.PI, o = 180 / Math.PI, s = Math.PI / 180; (function (t) { t[t["POLY"] = 0] = "POLY", t[t["RECT"] = 1] = "RECT", t[t["CIRC"] = 2] = "CIRC", t[t["ELIP"] = 3] = "ELIP", t[t["RREC"] = 4] = "RREC" })(i || (i = {})); var a = function () { function t(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e } return t.prototype.clone = function () { return new t(this.x, this.y) }, t.prototype.copyFrom = function (t) { return this.set(t.x, t.y), this }, t.prototype.copyTo = function (t) { return t.set(this.x, this.y), t }, t.prototype.equals = function (t) { return t.x === this.x && t.y === this.y }, t.prototype.set = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this }, t.prototype.toString = function () { return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]" }, t }(), u = [new a, new a, new a, new a], h = function () { function t(t, e, r, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === n && (n = 0), this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(n), this.type = i.RECT } return Object.defineProperty(t.prototype, "left", { get: function () { return this.x }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "right", { get: function () { return this.x + this.width }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "top", { get: function () { return this.y }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "bottom", { get: function () { return this.y + this.height }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "EMPTY", { get: function () { return new t(0, 0, 0, 0) }, enumerable: !1, configurable: !0 }), t.prototype.clone = function () { return new t(this.x, this.y, this.width, this.height) }, t.prototype.copyFrom = function (t) { return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this }, t.prototype.copyTo = function (t) { return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t }, t.prototype.contains = function (t, e) { return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height) }, t.prototype.intersects = function (t, e) { if (!e) { var r = this.x < t.x ? t.x : this.x, i = this.right > t.right ? t.right : this.right; if (i <= r) return !1; var n = this.y < t.y ? t.y : this.y, o = this.bottom > t.bottom ? t.bottom : this.bottom; return o > n } var s = this.left, a = this.right, h = this.top, l = this.bottom; if (a <= s || l <= h) return !1; var c = u[0].set(t.left, t.top), d = u[1].set(t.left, t.bottom), f = u[2].set(t.right, t.top), p = u[3].set(t.right, t.bottom); if (f.x <= c.x || d.y <= c.y) return !1; var _ = Math.sign(e.a * e.d - e.b * e.c); if (0 === _) return !1; if (e.apply(c, c), e.apply(d, d), e.apply(f, f), e.apply(p, p), Math.max(c.x, d.x, f.x, p.x) <= s || Math.min(c.x, d.x, f.x, p.x) >= a || Math.max(c.y, d.y, f.y, p.y) <= h || Math.min(c.y, d.y, f.y, p.y) >= l) return !1; var m = _ * (d.y - c.y), g = _ * (c.x - d.x), v = m * s + g * h, y = m * a + g * h, b = m * s + g * l, x = m * a + g * l; if (Math.max(v, y, b, x) <= m * c.x + g * c.y || Math.min(v, y, b, x) >= m * p.x + g * p.y) return !1; var T = _ * (c.y - f.y), E = _ * (f.x - c.x), S = T * s + E * h, w = T * a + E * h, A = T * s + E * l, R = T * a + E * l; return !(Math.max(S, w, A, R) <= T * c.x + E * c.y || Math.min(S, w, A, R) >= T * p.x + E * p.y) }, t.prototype.pad = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e, this }, t.prototype.fit = function (t) { var e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), i = Math.max(this.y, t.y), n = Math.min(this.y + this.height, t.y + t.height); return this.x = e, this.width = Math.max(r - e, 0), this.y = i, this.height = Math.max(n - i, 0), this }, t.prototype.ceil = function (t, e) { void 0 === t && (t = 1), void 0 === e && (e = .001); var r = Math.ceil((this.x + this.width - e) * t) / t, i = Math.ceil((this.y + this.height - e) * t) / t; return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = i - this.y, this }, t.prototype.enlarge = function (t) { var e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), i = Math.min(this.y, t.y), n = Math.max(this.y + this.height, t.y + t.height); return this.x = e, this.width = r - e, this.y = i, this.height = n - i, this }, t.prototype.toString = function () { return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]" }, t }(), l = function () { function t(t, e, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === r && (r = 0), this.x = t, this.y = e, this.radius = r, this.type = i.CIRC } return t.prototype.clone = function () { return new t(this.x, this.y, this.radius) }, t.prototype.contains = function (t, e) { if (this.radius <= 0) return !1; var r = this.radius * this.radius, i = this.x - t, n = this.y - e; return i *= i, n *= n, i + n <= r }, t.prototype.getBounds = function () { return new h(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius) }, t.prototype.toString = function () { return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]" }, t }(), c = function () { function t(t, e, r, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.width = r, this.height = n, this.type = i.ELIP } return t.prototype.clone = function () { return new t(this.x, this.y, this.width, this.height) }, t.prototype.contains = function (t, e) { if (this.width <= 0 || this.height <= 0) return !1; var r = (t - this.x) / this.width, i = (e - this.y) / this.height; return r *= r, i *= i, r + i <= 1 }, t.prototype.getBounds = function () { return new h(this.x - this.width, this.y - this.height, this.width, this.height) }, t.prototype.toString = function () { return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]" }, t }(), d = function () { function t() { for (var t = arguments, e = [], r = 0; r < arguments.length; r++)e[r] = t[r]; var n = Array.isArray(e[0]) ? e[0] : e; if ("number" !== typeof n[0]) { for (var o = [], s = 0, a = n.length; s < a; s++)o.push(n[s].x, n[s].y); n = o } this.points = n, this.type = i.POLY, this.closeStroke = !0 } return t.prototype.clone = function () { var e = this.points.slice(), r = new t(e); return r.closeStroke = this.closeStroke, r }, t.prototype.contains = function (t, e) { for (var r = !1, i = this.points.length / 2, n = 0, o = i - 1; n < i; o = n++) { var s = this.points[2 * n], a = this.points[2 * n + 1], u = this.points[2 * o], h = this.points[2 * o + 1], l = a > e !== h > e && t < (e - a) / (h - a) * (u - s) + s; l && (r = !r) } return r }, t.prototype.toString = function () { return "[@pixi/math:PolygoncloseStroke=" + this.closeStroke + "points=" + this.points.reduce((function (t, e) { return t + ", " + e }), "") + "]" }, t }(), f = function () { function t(t, e, r, n, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === n && (n = 0), void 0 === o && (o = 20), this.x = t, this.y = e, this.width = r, this.height = n, this.radius = o, this.type = i.RREC } return t.prototype.clone = function () { return new t(this.x, this.y, this.width, this.height, this.radius) }, t.prototype.contains = function (t, e) { if (this.width <= 0 || this.height <= 0) return !1; if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) { var r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2)); if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r) return !0; var i = t - (this.x + r), n = e - (this.y + r), o = r * r; if (i * i + n * n <= o) return !0; if (i = t - (this.x + this.width - r), i * i + n * n <= o) return !0; if (n = e - (this.y + this.height - r), i * i + n * n <= o) return !0; if (i = t - (this.x + r), i * i + n * n <= o) return !0 } return !1 }, t.prototype.toString = function () { return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + "width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]" }, t }(), p = function () { function t(t, e, r, i) { void 0 === r && (r = 0), void 0 === i && (i = 0), this._x = r, this._y = i, this.cb = t, this.scope = e } return t.prototype.clone = function (e, r) { return void 0 === e && (e = this.cb), void 0 === r && (r = this.scope), new t(e, r, this._x, this._y) }, t.prototype.set = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this._x === t && this._y === e || (this._x = t, this._y = e, this.cb.call(this.scope)), this }, t.prototype.copyFrom = function (t) { return this._x === t.x && this._y === t.y || (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this }, t.prototype.copyTo = function (t) { return t.set(this._x, this._y), t }, t.prototype.equals = function (t) { return t.x === this._x && t.y === this._y }, t.prototype.toString = function () { return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]" }, Object.defineProperty(t.prototype, "x", { get: function () { return this._x }, set: function (t) { this._x !== t && (this._x = t, this.cb.call(this.scope)) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "y", { get: function () { return this._y }, set: function (t) { this._y !== t && (this._y = t, this.cb.call(this.scope)) }, enumerable: !1, configurable: !0 }), t }(), _ = function () { function t(t, e, r, i, n, o) { void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === r && (r = 0), void 0 === i && (i = 1), void 0 === n && (n = 0), void 0 === o && (o = 0), this.array = null, this.a = t, this.b = e, this.c = r, this.d = i, this.tx = n, this.ty = o } return t.prototype.fromArray = function (t) { this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5] }, t.prototype.set = function (t, e, r, i, n, o) { return this.a = t, this.b = e, this.c = r, this.d = i, this.tx = n, this.ty = o, this }, t.prototype.toArray = function (t, e) { this.array || (this.array = new Float32Array(9)); var r = e || this.array; return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r }, t.prototype.apply = function (t, e) { e = e || new a; var r = t.x, i = t.y; return e.x = this.a * r + this.c * i + this.tx, e.y = this.b * r + this.d * i + this.ty, e }, t.prototype.applyInverse = function (t, e) { e = e || new a; var r = 1 / (this.a * this.d + this.c * -this.b), i = t.x, n = t.y; return e.x = this.d * r * i + -this.c * r * n + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * n + -this.b * r * i + (-this.ty * this.a + this.tx * this.b) * r, e }, t.prototype.translate = function (t, e) { return this.tx += t, this.ty += e, this }, t.prototype.scale = function (t, e) { return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this }, t.prototype.rotate = function (t) { var e = Math.cos(t), r = Math.sin(t), i = this.a, n = this.c, o = this.tx; return this.a = i * e - this.b * r, this.b = i * r + this.b * e, this.c = n * e - this.d * r, this.d = n * r + this.d * e, this.tx = o * e - this.ty * r, this.ty = o * r + this.ty * e, this }, t.prototype.append = function (t) { var e = this.a, r = this.b, i = this.c, n = this.d; return this.a = t.a * e + t.b * i, this.b = t.a * r + t.b * n, this.c = t.c * e + t.d * i, this.d = t.c * r + t.d * n, this.tx = t.tx * e + t.ty * i + this.tx, this.ty = t.tx * r + t.ty * n + this.ty, this }, t.prototype.setTransform = function (t, e, r, i, n, o, s, a, u) { return this.a = Math.cos(s + u) * n, this.b = Math.sin(s + u) * n, this.c = -Math.sin(s - a) * o, this.d = Math.cos(s - a) * o, this.tx = t - (r * this.a + i * this.c), this.ty = e - (r * this.b + i * this.d), this }, t.prototype.prepend = function (t) { var e = this.tx; if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) { var r = this.a, i = this.c; this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = i * t.a + this.d * t.c, this.d = i * t.b + this.d * t.d } return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this }, t.prototype.decompose = function (t) { var e = this.a, r = this.b, i = this.c, o = this.d, s = t.pivot, a = -Math.atan2(-i, o), u = Math.atan2(r, e), h = Math.abs(a + u); return h < 1e-5 || Math.abs(n - h) < 1e-5 ? (t.rotation = u, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = u), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(i * i + o * o), t.position.x = this.tx + (s.x * e + s.y * i), t.position.y = this.ty + (s.x * r + s.y * o), t }, t.prototype.invert = function () { var t = this.a, e = this.b, r = this.c, i = this.d, n = this.tx, o = t * i - e * r; return this.a = i / o, this.b = -e / o, this.c = -r / o, this.d = t / o, this.tx = (r * this.ty - i * n) / o, this.ty = -(t * this.ty - e * n) / o, this }, t.prototype.identity = function () { return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this }, t.prototype.clone = function () { var e = new t; return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e }, t.prototype.copyTo = function (t) { return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t }, t.prototype.copyFrom = function (t) { return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this }, t.prototype.toString = function () { return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]" }, Object.defineProperty(t, "IDENTITY", { get: function () { return new t }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "TEMP_MATRIX", { get: function () { return new t }, enumerable: !1, configurable: !0 }), t }(), m = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], g = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], v = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], y = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], b = [], x = [], T = Math.sign; function E() { for (var t = 0; t < 16; t++) { var e = []; b.push(e); for (var r = 0; r < 16; r++)for (var i = T(m[t] * m[r] + v[t] * g[r]), n = T(g[t] * m[r] + y[t] * g[r]), o = T(m[t] * v[r] + v[t] * y[r]), s = T(g[t] * v[r] + y[t] * y[r]), a = 0; a < 16; a++)if (m[a] === i && g[a] === n && v[a] === o && y[a] === s) { e.push(a); break } } for (t = 0; t < 16; t++) { var u = new _; u.set(m[t], g[t], v[t], y[t], 0, 0), x.push(u) } } E(); var S = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: function (t) { return m[t] }, uY: function (t) { return g[t] }, vX: function (t) { return v[t] }, vY: function (t) { return y[t] }, inv: function (t) { return 8 & t ? 15 & t : 7 & -t }, add: function (t, e) { return b[t][e] }, sub: function (t, e) { return b[t][S.inv(e)] }, rotate180: function (t) { return 4 ^ t }, isVertical: function (t) { return 2 === (3 & t) }, byDirection: function (t, e) { return 2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? S.S : S.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? S.E : S.W : e > 0 ? t > 0 ? S.SE : S.SW : t > 0 ? S.NE : S.NW }, matrixAppendRotationInv: function (t, e, r, i) { void 0 === r && (r = 0), void 0 === i && (i = 0); var n = x[S.inv(e)]; n.tx = r, n.ty = i, t.append(n) } }, w = function () { function t() { this.worldTransform = new _, this.localTransform = new _, this.position = new p(this.onChange, this, 0, 0), this.scale = new p(this.onChange, this, 1, 1), this.pivot = new p(this.onChange, this, 0, 0), this.skew = new p(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0 } return t.prototype.onChange = function () { this._localID++ }, t.prototype.updateSkew = function () { this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++ }, t.prototype.toString = function () { return "[@pixi/math:Transform position=(" + this.position.x + ", " + this.position.y + ") rotation=" + this.rotation + " scale=(" + this.scale.x + ", " + this.scale.y + ") skew=(" + this.skew.x + ", " + this.skew.y + ") ]" }, t.prototype.updateLocalTransform = function () { var t = this.localTransform; this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1) }, t.prototype.updateTransform = function (t) { var e = this.localTransform; if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) { var r = t.worldTransform, i = this.worldTransform; i.a = e.a * r.a + e.b * r.c, i.b = e.a * r.b + e.b * r.d, i.c = e.c * r.a + e.d * r.c, i.d = e.c * r.b + e.d * r.d, i.tx = e.tx * r.a + e.ty * r.c + r.tx, i.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++ } }, t.prototype.setFromMatrix = function (t) { t.decompose(this), this._localID++ }, Object.defineProperty(t.prototype, "rotation", { get: function () { return this._rotation }, set: function (t) { this._rotation !== t && (this._rotation = t, this.updateSkew()) }, enumerable: !1, configurable: !0 }), t.IDENTITY = new t, t }() }, 1922: function (t, e, r) {
        "use strict"; r.d(e, { R: function () { return i } }); r(7658);
/*!
 * @pixi/runner - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */var i = function () { function t(t) { this.items = [], this._name = t, this._aliasCount = 0 } return t.prototype.emit = function (t, e, r, i, n, o, s, a) { if (arguments.length > 8) throw new Error("max arguments reached"); var u = this, h = u.name, l = u.items; this._aliasCount++; for (var c = 0, d = l.length; c < d; c++)l[c][h](t, e, r, i, n, o, s, a); return l === this.items && this._aliasCount--, this }, t.prototype.ensureNonAliasedItems = function () { this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0)) }, t.prototype.add = function (t) { return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this }, t.prototype.remove = function (t) { var e = this.items.indexOf(t); return -1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this }, t.prototype.contains = function (t) { return -1 !== this.items.indexOf(t) }, t.prototype.removeAll = function () { return this.ensureNonAliasedItems(), this.items.length = 0, this }, t.prototype.destroy = function () { this.removeAll(), this.items = null, this._name = null }, Object.defineProperty(t.prototype, "empty", { get: function () { return 0 === this.items.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "name", { get: function () { return this._name }, enumerable: !1, configurable: !0 }), t }(); Object.defineProperties(i.prototype, { dispatch: { value: i.prototype.emit }, run: { value: i.prototype.emit } })
    }, 950: function (t, e, r) {
        "use strict"; r.d(e, { Xd: function () { return A }, ZQ: function () { return n }, tq: function () { return E } }); var i = r(8676), n = { createCanvas: function (t, e) { var r = document.createElement("canvas"); return r.width = t, r.height = e, r }, getWebGLRenderingContext: function () { return WebGLRenderingContext }, getNavigator: function () { return navigator }, getBaseUrl: function () { var t; return null !== (t = document.baseURI) && void 0 !== t ? t : window.location.href }, fetch: function (t, e) { return fetch(t, e) } }, o = /iPhone/i, s = /iPod/i, a = /iPad/i, u = /\biOS-universal(?:.+)Mac\b/i, h = /\bAndroid(?:.+)Mobile\b/i, l = /Android/i, c = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, d = /Silk/i, f = /Windows Phone/i, p = /\bWindows(?:.+)ARM\b/i, _ = /BlackBerry/i, m = /BB10/i, g = /Opera Mini/i, v = /\b(CriOS|Chrome)(?:.+)Mobile/i, y = /Mobile(?:.+)Firefox\b/i, b = function (t) { return "undefined" !== typeof t && "MacIntel" === t.platform && "number" === typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" === typeof MSStream };
/*!
 * @pixi/settings - v6.5.9
 * Compiled Wed, 25 Jan 2023 05:01:45 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */function x(t) { return function (e) { return e.test(t) } } function T(t) { var e = { userAgent: "", platform: "", maxTouchPoints: 0 }; t || "undefined" === typeof navigator ? "string" === typeof t ? e.userAgent = t : t && t.userAgent && (e = { userAgent: t.userAgent, platform: t.platform, maxTouchPoints: t.maxTouchPoints || 0 }) : e = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 }; var r = e.userAgent, i = r.split("[FBAN"); "undefined" !== typeof i[1] && (r = i[0]), i = r.split("Twitter"), "undefined" !== typeof i[1] && (r = i[0]); var n = x(r), T = { apple: { phone: n(o) && !n(f), ipod: n(s), tablet: !n(o) && (n(a) || b(e)) && !n(f), universal: n(u), device: (n(o) || n(s) || n(a) || n(u) || b(e)) && !n(f) }, amazon: { phone: n(c), tablet: !n(c) && n(d), device: n(c) || n(d) }, android: { phone: !n(f) && n(c) || !n(f) && n(h), tablet: !n(f) && !n(c) && !n(h) && (n(d) || n(l)), device: !n(f) && (n(c) || n(d) || n(h) || n(l)) || n(/\bokhttp\b/i) }, windows: { phone: n(f), tablet: n(p), device: n(f) || n(p) }, other: { blackberry: n(_), blackberry10: n(m), opera: n(g), firefox: n(y), chrome: n(v), device: n(_) || n(m) || n(g) || n(y) || n(v) }, any: !1, phone: !1, tablet: !1 }; return T.any = T.apple.device || T.android.device || T.windows.device || T.other.device, T.phone = T.apple.phone || T.android.phone || T.windows.phone, T.tablet = T.apple.tablet || T.android.tablet || T.windows.tablet, T } var E = T(globalThis.navigator); function S() { return !E.apple.device } function w(t) { var e = !0; if (E.tablet || E.phone) { if (E.apple.device) { var r = navigator.userAgent.match(/OS (\d+)_(\d+)?/); if (r) { var i = parseInt(r[1], 10); i < 11 && (e = !1) } } if (E.android.device) { r = navigator.userAgent.match(/Android\s([0-9.]*)/); if (r) { i = parseInt(r[1], 10); i < 7 && (e = !1) } } } return e ? t : 4 } var A = { ADAPTER: n, MIPMAP_TEXTURES: i.WB.POW2, ANISOTROPIC_LEVEL: 0, RESOLUTION: 1, FILTER_RESOLUTION: 1, FILTER_MULTISAMPLE: i.G5.NONE, SPRITE_MAX_TEXTURES: w(32), SPRITE_BATCH_SIZE: 4096, RENDER_OPTIONS: { view: null, antialias: !1, autoDensity: !1, backgroundColor: 0, backgroundAlpha: 1, useContextAlpha: !0, clearBeforeRender: !0, preserveDrawingBuffer: !1, width: 800, height: 600, legacy: !1 }, GC_MODE: i.UN.AUTO, GC_MAX_IDLE: 3600, GC_MAX_CHECK_COUNT: 600, WRAP_MODE: i.Nt.CLAMP, SCALE_MODE: i.aH.LINEAR, PRECISION_VERTEX: i.cB.HIGH, PRECISION_FRAGMENT: E.apple.device ? i.cB.HIGH : i.cB.MEDIUM, CAN_UPLOAD_SAME_BUFFER: S(), CREATE_IMAGE_BITMAP: !1, ROUND_PIXELS: !1 }
    }, 6565: function (t, e, r) {
        "use strict"; r.d(e, { Sb: function () { return u }, uF: function () { return i }, vB: function () { return a } }); var i, n = r(950), o = r(3640);
        /*!
         * @pixi/ticker - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * @pixi/ticker is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        n.Xd.TARGET_FPMS = .06, function (t) { t[t["INTERACTION"] = 50] = "INTERACTION", t[t["HIGH"] = 25] = "HIGH", t[t["NORMAL"] = 0] = "NORMAL", t[t["LOW"] = -25] = "LOW", t[t["UTILITY"] = -50] = "UTILITY" }(i || (i = {})); var s = function () { function t(t, e, r, i) { void 0 === e && (e = null), void 0 === r && (r = 0), void 0 === i && (i = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = r, this.once = i } return t.prototype.match = function (t, e) { return void 0 === e && (e = null), this.fn === t && this.context === e }, t.prototype.emit = function (t) { this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t)); var e = this.next; return this.once && this.destroy(!0), this._destroyed && (this.next = null), e }, t.prototype.connect = function (t) { this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this }, t.prototype.destroy = function (t) { void 0 === t && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous); var e = this.next; return this.next = t ? null : e, this.previous = null, e }, t }(), a = function () { function t() { var t = this; this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new s(null, null, 1 / 0), this.deltaMS = 1 / n.Xd.TARGET_FPMS, this.elapsedMS = 1 / n.Xd.TARGET_FPMS, this._tick = function (e) { t._requestId = null, t.started && (t.update(e), t.started && null === t._requestId && t._head.next && (t._requestId = requestAnimationFrame(t._tick))) } } return t.prototype._requestIfNeeded = function () { null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick)) }, t.prototype._cancelIfNeeded = function () { null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null) }, t.prototype._startIfPossible = function () { this.started ? this._requestIfNeeded() : this.autoStart && this.start() }, t.prototype.add = function (t, e, r) { return void 0 === r && (r = i.NORMAL), this._addListener(new s(t, e, r)) }, t.prototype.addOnce = function (t, e, r) { return void 0 === r && (r = i.NORMAL), this._addListener(new s(t, e, r, !0)) }, t.prototype._addListener = function (t) { var e = this._head.next, r = this._head; if (e) { while (e) { if (t.priority > e.priority) { t.connect(r); break } r = e, e = e.next } t.previous || t.connect(r) } else t.connect(r); return this._startIfPossible(), this }, t.prototype.remove = function (t, e) { var r = this._head.next; while (r) r = r.match(t, e) ? r.destroy() : r.next; return this._head.next || this._cancelIfNeeded(), this }, Object.defineProperty(t.prototype, "count", { get: function () { if (!this._head) return 0; var t = 0, e = this._head; while (e = e.next) t++; return t }, enumerable: !1, configurable: !0 }), t.prototype.start = function () { this.started || (this.started = !0, this._requestIfNeeded()) }, t.prototype.stop = function () { this.started && (this.started = !1, this._cancelIfNeeded()) }, t.prototype.destroy = function () { if (!this._protected) { this.stop(); var t = this._head.next; while (t) t = t.destroy(!0); this._head.destroy(), this._head = null } }, t.prototype.update = function (t) { var e; if (void 0 === t && (t = performance.now()), t > this.lastTime) { if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) { var r = t - this._lastFrame | 0; if (r < this._minElapsedMS) return; this._lastFrame = t - r % this._minElapsedMS } this.deltaMS = e, this.deltaTime = this.deltaMS * n.Xd.TARGET_FPMS; var i = this._head, o = i.next; while (o) o = o.emit(this.deltaTime); i.next || this._cancelIfNeeded() } else this.deltaTime = this.deltaMS = this.elapsedMS = 0; this.lastTime = t }, Object.defineProperty(t.prototype, "FPS", { get: function () { return 1e3 / this.elapsedMS }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "minFPS", { get: function () { return 1e3 / this._maxElapsedMS }, set: function (t) { var e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, n.Xd.TARGET_FPMS); this._maxElapsedMS = 1 / r }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "maxFPS", { get: function () { return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0 }, set: function (t) { if (0 === t) this._minElapsedMS = 0; else { var e = Math.max(this.minFPS, t); this._minElapsedMS = 1 / (e / 1e3) } }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "shared", { get: function () { if (!t._shared) { var e = t._shared = new t; e.autoStart = !0, e._protected = !0 } return t._shared }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "system", { get: function () { if (!t._system) { var e = t._system = new t; e.autoStart = !0, e._protected = !0 } return t._system }, enumerable: !1, configurable: !0 }), t }(), u = function () { function t() { } return t.init = function (t) { var e = this; t = Object.assign({ autoStart: !0, sharedTicker: !1 }, t), Object.defineProperty(this, "ticker", { set: function (t) { this._ticker && this._ticker.remove(this.render, this), this._ticker = t, t && t.add(this.render, this, i.LOW) }, get: function () { return this._ticker } }), this.stop = function () { e._ticker.stop() }, this.start = function () { e._ticker.start() }, this._ticker = null, this.ticker = t.sharedTicker ? a.shared : new a, t.autoStart && this.start() }, t.destroy = function () { if (this._ticker) { var t = this._ticker; this.ticker = null, t.destroy() } }, t.extension = o.n.Application, t }()
    }, 5506: function (t, e, r) { "use strict"; r.r(e), r.d(e, { BaseTextureCache: function () { return Dr }, CanvasRenderTarget: function () { return Nr }, DATA_URI: function () { return kr }, EventEmitter: function () { return n }, ProgramCache: function () { return Mr }, TextureCache: function () { return Cr }, clearTextureCache: function () { return Fr }, correctBlendMode: function () { return pr }, createIndicesForQuads: function () { return vr }, decomposeDataUri: function () { return Gr }, deprecation: function () { return Pr }, destroyTextureCache: function () { return Lr }, determineCrossOrigin: function () { return Xr }, earcut: function () { return o }, getBufferType: function () { return yr }, getResolutionOfUrl: function () { return jr }, hex2rgb: function () { return ur }, hex2string: function () { return hr }, interleaveTypedArrays: function () { return xr }, isMobile: function () { return i.tq }, isPow2: function () { return Er }, isWebGLSupported: function () { return b }, log2: function () { return Sr }, nextPow2: function () { return Tr }, path: function () { return p }, premultiplyBlendMode: function () { return fr }, premultiplyRgba: function () { return _r }, premultiplyTint: function () { return mr }, premultiplyTintToRgba: function () { return gr }, removeItems: function () { return wr }, rgb2hex: function () { return cr }, sayHello: function () { return y }, sign: function () { return Ar }, skipHello: function () { return v }, string2hex: function () { return lr }, trimCanvas: function () { return Br }, uid: function () { return Or }, url: function () { return u } }); r(7658), r(3767), r(8585), r(8696); var i = r(950), n = r(1907), o = r(8745), s = r(4030), a = r(8676), u = { parse: s.Qc, format: s.WU, resolve: s.DB }; function h(t) { if ("string" !== typeof t) throw new TypeError("Path must be a string. Received " + JSON.stringify(t)) } function l(t) { var e = t.split("?")[0]; return e.split("#")[0] } function c(t) { return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } function d(t, e, r) { return t.replace(new RegExp(c(e), "g"), r) } function f(t, e) { for (var r, i = "", n = 0, o = -1, s = 0, a = 0; a <= t.length; ++a) { if (a < t.length) r = t.charCodeAt(a); else { if (47 === r) break; r = 47 } if (47 === r) { if (o === a - 1 || 1 === s); else if (o !== a - 1 && 2 === s) { if (i.length < 2 || 2 !== n || 46 !== i.charCodeAt(i.length - 1) || 46 !== i.charCodeAt(i.length - 2)) if (i.length > 2) { var u = i.lastIndexOf("/"); if (u !== i.length - 1) { -1 === u ? (i = "", n = 0) : (i = i.slice(0, u), n = i.length - 1 - i.lastIndexOf("/")), o = a, s = 0; continue } } else if (2 === i.length || 1 === i.length) { i = "", n = 0, o = a, s = 0; continue } e && (i.length > 0 ? i += "/.." : i = "..", n = 2) } else i.length > 0 ? i += "/" + t.slice(o + 1, a) : i = t.slice(o + 1, a), n = a - o - 1; o = a, s = 0 } else 46 === r && -1 !== s ? ++s : s = -1 } return i } var p = { toPosix: function (t) { return d(t, "\\", "/") }, isUrl: function (t) { return /^https?:/.test(this.toPosix(t)) }, isDataUrl: function (t) { return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t) }, hasProtocol: function (t) { return /^[^/:]+:\//.test(this.toPosix(t)) }, getProtocol: function (t) { h(t), t = this.toPosix(t); var e = "", r = /^file:\/\/\//.exec(t), i = /^[^/:]+:\/\//.exec(t), n = /^[^/:]+:\//.exec(t); if (r || i || n) { var o = (null === r || void 0 === r ? void 0 : r[0]) || (null === i || void 0 === i ? void 0 : i[0]) || (null === n || void 0 === n ? void 0 : n[0]); e = o, t = t.slice(o.length) } return e }, toAbsolute: function (t, e, r) { if (this.isDataUrl(t)) return t; var n = l(this.toPosix(null !== e && void 0 !== e ? e : i.Xd.ADAPTER.getBaseUrl())), o = l(this.toPosix(null !== r && void 0 !== r ? r : this.rootname(n))); if (h(t), t = this.toPosix(t), t.startsWith("/")) return p.join(o, t.slice(1)); var s = this.isAbsolute(t) ? t : this.join(n, t); return s }, normalize: function (t) { if (t = this.toPosix(t), h(t), 0 === t.length) return "."; var e = "", r = t.startsWith("/"); this.hasProtocol(t) && (e = this.rootname(t), t = t.slice(e.length)); var i = t.endsWith("/"); return t = f(t, !1), t.length > 0 && i && (t += "/"), r ? "/" + t : e + t }, isAbsolute: function (t) { return h(t), t = this.toPosix(t), !!this.hasProtocol(t) || t.startsWith("/") }, join: function () { for (var t, e, r = arguments, i = [], n = 0; n < arguments.length; n++)i[n] = r[n]; if (0 === i.length) return "."; for (var o = 0; o < i.length; ++o) { var s = i[o]; if (h(s), s.length > 0) if (void 0 === e) e = s; else { var a = null !== (t = i[o - 1]) && void 0 !== t ? t : ""; this.extname(a) ? e += "/../" + s : e += "/" + s } } return void 0 === e ? "." : this.normalize(e) }, dirname: function (t) { if (h(t), 0 === t.length) return "."; t = this.toPosix(t); var e = t.charCodeAt(0), r = 47 === e, i = -1, n = !0, o = this.getProtocol(t), s = t; t = t.slice(o.length); for (var a = t.length - 1; a >= 1; --a)if (e = t.charCodeAt(a), 47 === e) { if (!n) { i = a; break } } else n = !1; return -1 === i ? r ? "/" : this.isUrl(s) ? o + t : o : r && 1 === i ? "//" : o + t.slice(0, i) }, rootname: function (t) { h(t), t = this.toPosix(t); var e = ""; if (e = t.startsWith("/") ? "/" : this.getProtocol(t), this.isUrl(t)) { var r = t.indexOf("/", e.length); e = -1 !== r ? t.slice(0, r) : t, e.endsWith("/") || (e += "/") } return e }, basename: function (t, e) { h(t), e && h(e), t = this.toPosix(t); var r, i = 0, n = -1, o = !0; if (void 0 !== e && e.length > 0 && e.length <= t.length) { if (e.length === t.length && e === t) return ""; var s = e.length - 1, a = -1; for (r = t.length - 1; r >= 0; --r) { var u = t.charCodeAt(r); if (47 === u) { if (!o) { i = r + 1; break } } else -1 === a && (o = !1, a = r + 1), s >= 0 && (u === e.charCodeAt(s) ? -1 === --s && (n = r) : (s = -1, n = a)) } return i === n ? n = a : -1 === n && (n = t.length), t.slice(i, n) } for (r = t.length - 1; r >= 0; --r)if (47 === t.charCodeAt(r)) { if (!o) { i = r + 1; break } } else -1 === n && (o = !1, n = r + 1); return -1 === n ? "" : t.slice(i, n) }, extname: function (t) { h(t), t = this.toPosix(t); for (var e = -1, r = 0, i = -1, n = !0, o = 0, s = t.length - 1; s >= 0; --s) { var a = t.charCodeAt(s); if (47 !== a) -1 === i && (n = !1, i = s + 1), 46 === a ? -1 === e ? e = s : 1 !== o && (o = 1) : -1 !== e && (o = -1); else if (!n) { r = s + 1; break } } return -1 === e || -1 === i || 0 === o || 1 === o && e === i - 1 && e === r + 1 ? "" : t.slice(e, i) }, parse: function (t) { h(t); var e = { root: "", dir: "", base: "", ext: "", name: "" }; if (0 === t.length) return e; t = this.toPosix(t); var r, i = t.charCodeAt(0), n = this.isAbsolute(t); e.root = this.rootname(t), r = n || this.hasProtocol(t) ? 1 : 0; for (var o = -1, s = 0, a = -1, u = !0, l = t.length - 1, c = 0; l >= r; --l)if (i = t.charCodeAt(l), 47 !== i) -1 === a && (u = !1, a = l + 1), 46 === i ? -1 === o ? o = l : 1 !== c && (c = 1) : -1 !== o && (c = -1); else if (!u) { s = l + 1; break } return -1 === o || -1 === a || 0 === c || 1 === c && o === a - 1 && o === s + 1 ? -1 !== a && (e.base = e.name = 0 === s && n ? t.slice(1, a) : t.slice(s, a)) : (0 === s && n ? (e.name = t.slice(1, o), e.base = t.slice(1, a)) : (e.name = t.slice(s, o), e.base = t.slice(s, a)), e.ext = t.slice(o, a)), e.dir = this.dirname(t), e }, sep: "/", delimiter: ":" }; i.Xd.RETINA_PREFIX = /@([0-9\.]+)x/, i.Xd.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1; var _, m = !1, g = "6.5.9"; function v() { m = !0 } function y(t) { var e; if (!m) { if (i.Xd.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) { var r = ["\n %c %c %c PixiJS " + g + " - â° " + t + " â°  %c  %c  http://www.pixijs.com/  %c %c â¥%câ¥%câ¥ \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"]; (e = globalThis.console).log.apply(e, r) } else globalThis.console && globalThis.console.log("PixiJS " + g + " - " + t + " - http://www.pixijs.com/"); m = !0 } } function b() { return "undefined" === typeof _ && (_ = function () { var t = { stencil: !0, failIfMajorPerformanceCaveat: i.Xd.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT }; try { if (!i.Xd.ADAPTER.getWebGLRenderingContext()) return !1; var e = i.Xd.ADAPTER.createCanvas(), r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), n = !(!r || !r.getContextAttributes().stencil); if (r) { var o = r.getExtension("WEBGL_lose_context"); o && o.loseContext() } return r = null, n } catch (s) { return !1 } }()), _ } var x = "#f0f8ff", T = "#faebd7", E = "#00ffff", S = "#7fffd4", w = "#f0ffff", A = "#f5f5dc", R = "#ffe4c4", O = "#000000", I = "#ffebcd", P = "#0000ff", M = "#8a2be2", C = "#a52a2a", D = "#deb887", L = "#5f9ea0", F = "#7fff00", N = "#d2691e", B = "#ff7f50", U = "#6495ed", k = "#fff8dc", G = "#dc143c", X = "#00ffff", j = "#00008b", H = "#008b8b", V = "#b8860b", z = "#a9a9a9", Y = "#006400", W = "#a9a9a9", $ = "#bdb76b", q = "#8b008b", K = "#556b2f", Z = "#ff8c00", J = "#9932cc", Q = "#8b0000", tt = "#e9967a", et = "#8fbc8f", rt = "#483d8b", it = "#2f4f4f", nt = "#2f4f4f", ot = "#00ced1", st = "#9400d3", at = "#ff1493", ut = "#00bfff", ht = "#696969", lt = "#696969", ct = "#1e90ff", dt = "#b22222", ft = "#fffaf0", pt = "#228b22", _t = "#ff00ff", mt = "#dcdcdc", gt = "#f8f8ff", vt = "#daa520", yt = "#ffd700", bt = "#808080", xt = "#008000", Tt = "#adff2f", Et = "#808080", St = "#f0fff0", wt = "#ff69b4", At = "#cd5c5c", Rt = "#4b0082", Ot = "#fffff0", It = "#f0e68c", Pt = "#fff0f5", Mt = "#e6e6fa", Ct = "#7cfc00", Dt = "#fffacd", Lt = "#add8e6", Ft = "#f08080", Nt = "#e0ffff", Bt = "#fafad2", Ut = "#d3d3d3", kt = "#90ee90", Gt = "#d3d3d3", Xt = "#ffb6c1", jt = "#ffa07a", Ht = "#20b2aa", Vt = "#87cefa", zt = "#778899", Yt = "#778899", Wt = "#b0c4de", $t = "#ffffe0", qt = "#00ff00", Kt = "#32cd32", Zt = "#faf0e6", Jt = "#ff00ff", Qt = "#800000", te = "#66cdaa", ee = "#0000cd", re = "#ba55d3", ie = "#9370db", ne = "#3cb371", oe = "#7b68ee", se = "#00fa9a", ae = "#48d1cc", ue = "#c71585", he = "#191970", le = "#f5fffa", ce = "#ffe4e1", de = "#ffe4b5", fe = "#ffdead", pe = "#000080", _e = "#fdf5e6", me = "#808000", ge = "#6b8e23", ve = "#ffa500", ye = "#ff4500", be = "#da70d6", xe = "#eee8aa", Te = "#98fb98", Ee = "#afeeee", Se = "#db7093", we = "#ffefd5", Ae = "#ffdab9", Re = "#cd853f", Oe = "#ffc0cb", Ie = "#dda0dd", Pe = "#b0e0e6", Me = "#800080", Ce = "#663399", De = "#ff0000", Le = "#bc8f8f", Fe = "#4169e1", Ne = "#8b4513", Be = "#fa8072", Ue = "#f4a460", ke = "#2e8b57", Ge = "#fff5ee", Xe = "#a0522d", je = "#c0c0c0", He = "#87ceeb", Ve = "#6a5acd", ze = "#708090", Ye = "#708090", We = "#fffafa", $e = "#00ff7f", qe = "#4682b4", Ke = "#d2b48c", Ze = "#008080", Je = "#d8bfd8", Qe = "#ff6347", tr = "#40e0d0", er = "#ee82ee", rr = "#f5deb3", ir = "#ffffff", nr = "#f5f5f5", or = "#ffff00", sr = "#9acd32", ar = { aliceblue: x, antiquewhite: T, aqua: E, aquamarine: S, azure: w, beige: A, bisque: R, black: O, blanchedalmond: I, blue: P, blueviolet: M, brown: C, burlywood: D, cadetblue: L, chartreuse: F, chocolate: N, coral: B, cornflowerblue: U, cornsilk: k, crimson: G, cyan: X, darkblue: j, darkcyan: H, darkgoldenrod: V, darkgray: z, darkgreen: Y, darkgrey: W, darkkhaki: $, darkmagenta: q, darkolivegreen: K, darkorange: Z, darkorchid: J, darkred: Q, darksalmon: tt, darkseagreen: et, darkslateblue: rt, darkslategray: it, darkslategrey: nt, darkturquoise: ot, darkviolet: st, deeppink: at, deepskyblue: ut, dimgray: ht, dimgrey: lt, dodgerblue: ct, firebrick: dt, floralwhite: ft, forestgreen: pt, fuchsia: _t, gainsboro: mt, ghostwhite: gt, goldenrod: vt, gold: yt, gray: bt, green: xt, greenyellow: Tt, grey: Et, honeydew: St, hotpink: wt, indianred: At, indigo: Rt, ivory: Ot, khaki: It, lavenderblush: Pt, lavender: Mt, lawngreen: Ct, lemonchiffon: Dt, lightblue: Lt, lightcoral: Ft, lightcyan: Nt, lightgoldenrodyellow: Bt, lightgray: Ut, lightgreen: kt, lightgrey: Gt, lightpink: Xt, lightsalmon: jt, lightseagreen: Ht, lightskyblue: Vt, lightslategray: zt, lightslategrey: Yt, lightsteelblue: Wt, lightyellow: $t, lime: qt, limegreen: Kt, linen: Zt, magenta: Jt, maroon: Qt, mediumaquamarine: te, mediumblue: ee, mediumorchid: re, mediumpurple: ie, mediumseagreen: ne, mediumslateblue: oe, mediumspringgreen: se, mediumturquoise: ae, mediumvioletred: ue, midnightblue: he, mintcream: le, mistyrose: ce, moccasin: de, navajowhite: fe, navy: pe, oldlace: _e, olive: me, olivedrab: ge, orange: ve, orangered: ye, orchid: be, palegoldenrod: xe, palegreen: Te, paleturquoise: Ee, palevioletred: Se, papayawhip: we, peachpuff: Ae, peru: Re, pink: Oe, plum: Ie, powderblue: Pe, purple: Me, rebeccapurple: Ce, red: De, rosybrown: Le, royalblue: Fe, saddlebrown: Ne, salmon: Be, sandybrown: Ue, seagreen: ke, seashell: Ge, sienna: Xe, silver: je, skyblue: He, slateblue: Ve, slategray: ze, slategrey: Ye, snow: We, springgreen: $e, steelblue: qe, tan: Ke, teal: Ze, thistle: Je, tomato: Qe, turquoise: tr, violet: er, wheat: rr, white: ir, whitesmoke: nr, yellow: or, yellowgreen: sr }; function ur(t, e) { return void 0 === e && (e = []), e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255, e } function hr(t) { var e = t.toString(16); return e = "000000".substring(0, 6 - e.length) + e, "#" + e } function lr(t) { return "string" === typeof t && (t = ar[t.toLowerCase()] || t, "#" === t[0] && (t = t.slice(1))), parseInt(t, 16) } function cr(t) { return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0) } function dr() { for (var t = [], e = [], r = 0; r < 32; r++)t[r] = r, e[r] = r; t[a.T$.NORMAL_NPM] = a.T$.NORMAL, t[a.T$.ADD_NPM] = a.T$.ADD, t[a.T$.SCREEN_NPM] = a.T$.SCREEN, e[a.T$.NORMAL] = a.T$.NORMAL_NPM, e[a.T$.ADD] = a.T$.ADD_NPM, e[a.T$.SCREEN] = a.T$.SCREEN_NPM; var i = []; return i.push(e), i.push(t), i } var fr = dr(); function pr(t, e) { return fr[e ? 1 : 0][t] } function _r(t, e, r, i) { return r = r || new Float32Array(4), i || void 0 === i ? (r[0] = t[0] * e, r[1] = t[1] * e, r[2] = t[2] * e) : (r[0] = t[0], r[1] = t[1], r[2] = t[2]), r[3] = e, r } function mr(t, e) { if (1 === e) return (255 * e << 24) + t; if (0 === e) return 0; var r = t >> 16 & 255, i = t >> 8 & 255, n = 255 & t; return r = r * e + .5 | 0, i = i * e + .5 | 0, n = n * e + .5 | 0, (255 * e << 24) + (r << 16) + (i << 8) + n } function gr(t, e, r, i) { return r = r || new Float32Array(4), r[0] = (t >> 16 & 255) / 255, r[1] = (t >> 8 & 255) / 255, r[2] = (255 & t) / 255, (i || void 0 === i) && (r[0] *= e, r[1] *= e, r[2] *= e), r[3] = e, r } function vr(t, e) { void 0 === e && (e = null); var r = 6 * t; if (e = e || new Uint16Array(r), e.length !== r) throw new Error("Out buffer length is incorrect, got " + e.length + " and expected " + r); for (var i = 0, n = 0; i < r; i += 6, n += 4)e[i + 0] = n + 0, e[i + 1] = n + 1, e[i + 2] = n + 2, e[i + 3] = n + 0, e[i + 4] = n + 2, e[i + 5] = n + 3; return e } function yr(t) { if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array"; if (2 === t.BYTES_PER_ELEMENT) { if (t instanceof Uint16Array) return "Uint16Array" } else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array"; return null } var br = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array }; function xr(t, e) { for (var r = 0, i = 0, n = {}, o = 0; o < t.length; o++)i += e[o], r += t[o].length; var s = new ArrayBuffer(4 * r), a = null, u = 0; for (o = 0; o < t.length; o++) { var h = e[o], l = t[o], c = yr(l); n[c] || (n[c] = new br[c](s)), a = n[c]; for (var d = 0; d < l.length; d++) { var f = (d / h | 0) * i + u, p = d % h; a[f + p] = l[d] } u += h } return new Float32Array(s) } function Tr(t) { return t += 0 === t ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t + 1 } function Er(t) { return !(t & t - 1) && !!t } function Sr(t) { var e = (t > 65535 ? 1 : 0) << 4; t >>>= e; var r = (t > 255 ? 1 : 0) << 3; return t >>>= r, e |= r, r = (t > 15 ? 1 : 0) << 2, t >>>= r, e |= r, r = (t > 3 ? 1 : 0) << 1, t >>>= r, e |= r, e | t >> 1 } function wr(t, e, r) { var i, n = t.length; if (!(e >= n || 0 === r)) { r = e + r > n ? n - e : r; var o = n - r; for (i = e; i < o; ++i)t[i] = t[i + r]; t.length = o } } function Ar(t) { return 0 === t ? 0 : t < 0 ? -1 : 1 } var Rr = 0; function Or() { return ++Rr } var Ir = {}; function Pr(t, e, r) { if (void 0 === r && (r = 3), !Ir[e]) { var i = (new Error).stack; "undefined" === typeof i ? console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t) : (i = i.split("\n").splice(r).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e + "\nDeprecated since v" + t), console.warn(i), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t), console.warn(i))), Ir[e] = !0 } } var Mr = {}, Cr = Object.create(null), Dr = Object.create(null); function Lr() { var t; for (t in Cr) Cr[t].destroy(); for (t in Dr) Dr[t].destroy() } function Fr() { var t; for (t in Cr) delete Cr[t]; for (t in Dr) delete Dr[t] } var Nr = function () { function t(t, e, r) { this.canvas = i.Xd.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = r || i.Xd.RESOLUTION, this.resize(t, e) } return t.prototype.clear = function () { this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height) }, t.prototype.resize = function (t, e) { this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution) }, t.prototype.destroy = function () { this.context = null, this.canvas = null }, Object.defineProperty(t.prototype, "width", { get: function () { return this.canvas.width }, set: function (t) { this.canvas.width = Math.round(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "height", { get: function () { return this.canvas.height }, set: function (t) { this.canvas.height = Math.round(t) }, enumerable: !1, configurable: !0 }), t }(); function Br(t) { var e, r, i, n = t.width, o = t.height, s = t.getContext("2d", { willReadFrequently: !0 }), a = s.getImageData(0, 0, n, o), u = a.data, h = u.length, l = { top: null, left: null, right: null, bottom: null }, c = null; for (e = 0; e < h; e += 4)0 !== u[e + 3] && (r = e / 4 % n, i = ~~(e / 4 / n), null === l.top && (l.top = i), (null === l.left || r < l.left) && (l.left = r), (null === l.right || l.right < r) && (l.right = r + 1), (null === l.bottom || l.bottom < i) && (l.bottom = i)); return null !== l.top && (n = l.right - l.left, o = l.bottom - l.top + 1, c = s.getImageData(l.left, l.top, n, o)), { height: o, width: n, data: c } } var Ur, kr = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i; function Gr(t) { var e = kr.exec(t); if (e) return { mediaType: e[1] ? e[1].toLowerCase() : void 0, subType: e[2] ? e[2].toLowerCase() : void 0, charset: e[3] ? e[3].toLowerCase() : void 0, encoding: e[4] ? e[4].toLowerCase() : void 0, data: e[5] } } function Xr(t, e) { if (void 0 === e && (e = globalThis.location), 0 === t.indexOf("data:")) return ""; e = e || globalThis.location, Ur || (Ur = document.createElement("a")), Ur.href = t; var r = u.parse(Ur.href), i = !r.port && "" === e.port || r.port === e.port; return r.hostname === e.hostname && i && r.protocol === e.protocol ? "" : "anonymous" } function jr(t, e) { var r = i.Xd.RETINA_PREFIX.exec(t); return r ? parseFloat(r[1]) : void 0 !== e ? e : 1 } }, 4161: function (t, e, r) { "use strict"; r.d(e, { Z: function () { return Ue } }); r(3767), r(8585), r(8696), r(7658); function i(t, e) { return function () { return t.apply(e, arguments) } } const { toString: n } = Object.prototype, { getPrototypeOf: o } = Object, s = (t => e => { const r = n.call(e); return t[r] || (t[r] = r.slice(8, -1).toLowerCase()) })(Object.create(null)), a = t => (t = t.toLowerCase(), e => s(e) === t), u = t => e => typeof e === t, { isArray: h } = Array, l = u("undefined"); function c(t) { return null !== t && !l(t) && null !== t.constructor && !l(t.constructor) && _(t.constructor.isBuffer) && t.constructor.isBuffer(t) } const d = a("ArrayBuffer"); function f(t) { let e; return e = "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && d(t.buffer), e } const p = u("string"), _ = u("function"), m = u("number"), g = t => null !== t && "object" === typeof t, v = t => !0 === t || !1 === t, y = t => { if ("object" !== s(t)) return !1; const e = o(t); return (null === e || e === Object.prototype || null === Object.getPrototypeOf(e)) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t) }, b = a("Date"), x = a("File"), T = a("Blob"), E = a("FileList"), S = t => g(t) && _(t.pipe), w = t => { let e; return t && ("function" === typeof FormData && t instanceof FormData || _(t.append) && ("formdata" === (e = s(t)) || "object" === e && _(t.toString) && "[object FormData]" === t.toString())) }, A = a("URLSearchParams"), R = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function O(t, e, { allOwnKeys: r = !1 } = {}) { if (null === t || "undefined" === typeof t) return; let i, n; if ("object" !== typeof t && (t = [t]), h(t)) for (i = 0, n = t.length; i < n; i++)e.call(null, t[i], i, t); else { const n = r ? Object.getOwnPropertyNames(t) : Object.keys(t), o = n.length; let s; for (i = 0; i < o; i++)s = n[i], e.call(null, t[s], s, t) } } function I(t, e) { e = e.toLowerCase(); const r = Object.keys(t); let i, n = r.length; while (n-- > 0) if (i = r[n], e === i.toLowerCase()) return i; return null } const P = (() => "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : global)(), M = t => !l(t) && t !== P; function C() { const { caseless: t } = M(this) && this || {}, e = {}, r = (r, i) => { const n = t && I(e, i) || i; y(e[n]) && y(r) ? e[n] = C(e[n], r) : y(r) ? e[n] = C({}, r) : h(r) ? e[n] = r.slice() : e[n] = r }; for (let i = 0, n = arguments.length; i < n; i++)arguments[i] && O(arguments[i], r); return e } const D = (t, e, r, { allOwnKeys: n } = {}) => (O(e, ((e, n) => { r && _(e) ? t[n] = i(e, r) : t[n] = e }), { allOwnKeys: n }), t), L = t => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t), F = (t, e, r, i) => { t.prototype = Object.create(e.prototype, i), t.prototype.constructor = t, Object.defineProperty(t, "super", { value: e.prototype }), r && Object.assign(t.prototype, r) }, N = (t, e, r, i) => { let n, s, a; const u = {}; if (e = e || {}, null == t) return e; do { n = Object.getOwnPropertyNames(t), s = n.length; while (s-- > 0) a = n[s], i && !i(a, t, e) || u[a] || (e[a] = t[a], u[a] = !0); t = !1 !== r && o(t) } while (t && (!r || r(t, e)) && t !== Object.prototype); return e }, B = (t, e, r) => { t = String(t), (void 0 === r || r > t.length) && (r = t.length), r -= e.length; const i = t.indexOf(e, r); return -1 !== i && i === r }, U = t => { if (!t) return null; if (h(t)) return t; let e = t.length; if (!m(e)) return null; const r = new Array(e); while (e-- > 0) r[e] = t[e]; return r }, k = (t => e => t && e instanceof t)("undefined" !== typeof Uint8Array && o(Uint8Array)), G = (t, e) => { const r = t && t[Symbol.iterator], i = r.call(t); let n; while ((n = i.next()) && !n.done) { const r = n.value; e.call(t, r[0], r[1]) } }, X = (t, e) => { let r; const i = []; while (null !== (r = t.exec(e))) i.push(r); return i }, j = a("HTMLFormElement"), H = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function (t, e, r) { return e.toUpperCase() + r })), V = (({ hasOwnProperty: t }) => (e, r) => t.call(e, r))(Object.prototype), z = a("RegExp"), Y = (t, e) => { const r = Object.getOwnPropertyDescriptors(t), i = {}; O(r, ((r, n) => { !1 !== e(r, n, t) && (i[n] = r) })), Object.defineProperties(t, i) }, W = t => { Y(t, ((e, r) => { if (_(t) && -1 !== ["arguments", "caller", "callee"].indexOf(r)) return !1; const i = t[r]; _(i) && (e.enumerable = !1, "writable" in e ? e.writable = !1 : e.set || (e.set = () => { throw Error("Can not rewrite read-only method '" + r + "'") })) })) }, $ = (t, e) => { const r = {}, i = t => { t.forEach((t => { r[t] = !0 })) }; return h(t) ? i(t) : i(String(t).split(e)), r }, q = () => { }, K = (t, e) => (t = +t, Number.isFinite(t) ? t : e), Z = "abcdefghijklmnopqrstuvwxyz", J = "0123456789", Q = { DIGIT: J, ALPHA: Z, ALPHA_DIGIT: Z + Z.toUpperCase() + J }, tt = (t = 16, e = Q.ALPHA_DIGIT) => { let r = ""; const { length: i } = e; while (t--) r += e[Math.random() * i | 0]; return r }; function et(t) { return !!(t && _(t.append) && "FormData" === t[Symbol.toStringTag] && t[Symbol.iterator]) } const rt = t => { const e = new Array(10), r = (t, i) => { if (g(t)) { if (e.indexOf(t) >= 0) return; if (!("toJSON" in t)) { e[i] = t; const n = h(t) ? [] : {}; return O(t, ((t, e) => { const o = r(t, i + 1); !l(o) && (n[e] = o) })), e[i] = void 0, n } } return t }; return r(t, 0) }, it = a("AsyncFunction"), nt = t => t && (g(t) || _(t)) && _(t.then) && _(t.catch); var ot = { isArray: h, isArrayBuffer: d, isBuffer: c, isFormData: w, isArrayBufferView: f, isString: p, isNumber: m, isBoolean: v, isObject: g, isPlainObject: y, isUndefined: l, isDate: b, isFile: x, isBlob: T, isRegExp: z, isFunction: _, isStream: S, isURLSearchParams: A, isTypedArray: k, isFileList: E, forEach: O, merge: C, extend: D, trim: R, stripBOM: L, inherits: F, toFlatObject: N, kindOf: s, kindOfTest: a, endsWith: B, toArray: U, forEachEntry: G, matchAll: X, isHTMLForm: j, hasOwnProperty: V, hasOwnProp: V, reduceDescriptors: Y, freezeMethods: W, toObjectSet: $, toCamelCase: H, noop: q, toFiniteNumber: K, findKey: I, global: P, isContextDefined: M, ALPHABET: Q, generateString: tt, isSpecCompliantForm: et, toJSONObject: rt, isAsyncFn: it, isThenable: nt }; r(541); function st(t, e, r, i, n) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), i && (this.request = i), n && (this.response = n) } ot.inherits(st, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: ot.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null } } }); const at = st.prototype, ut = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((t => { ut[t] = { value: t } })), Object.defineProperties(st, ut), Object.defineProperty(at, "isAxiosError", { value: !0 }), st.from = (t, e, r, i, n, o) => { const s = Object.create(at); return ot.toFlatObject(t, s, (function (t) { return t !== Error.prototype }), (t => "isAxiosError" !== t)), st.call(s, t.message, e, r, i, n), s.cause = t, s.name = t.name, o && Object.assign(s, o), s }; var ht = st, lt = null; function ct(t) { return ot.isPlainObject(t) || ot.isArray(t) } function dt(t) { return ot.endsWith(t, "[]") ? t.slice(0, -2) : t } function ft(t, e, r) { return t ? t.concat(e).map((function (t, e) { return t = dt(t), !r && e ? "[" + t + "]" : t })).join(r ? "." : "") : e } function pt(t) { return ot.isArray(t) && !t.some(ct) } const _t = ot.toFlatObject(ot, {}, null, (function (t) { return /^is[A-Z]/.test(t) })); function mt(t, e, r) { if (!ot.isObject(t)) throw new TypeError("target must be an object"); e = e || new (lt || FormData), r = ot.toFlatObject(r, { metaTokens: !0, dots: !1, indexes: !1 }, !1, (function (t, e) { return !ot.isUndefined(e[t]) })); const i = r.metaTokens, n = r.visitor || l, o = r.dots, s = r.indexes, a = r.Blob || "undefined" !== typeof Blob && Blob, u = a && ot.isSpecCompliantForm(e); if (!ot.isFunction(n)) throw new TypeError("visitor must be a function"); function h(t) { if (null === t) return ""; if (ot.isDate(t)) return t.toISOString(); if (!u && ot.isBlob(t)) throw new ht("Blob is not supported. Use a Buffer instead."); return ot.isArrayBuffer(t) || ot.isTypedArray(t) ? u && "function" === typeof Blob ? new Blob([t]) : Buffer.from(t) : t } function l(t, r, n) { let a = t; if (t && !n && "object" === typeof t) if (ot.endsWith(r, "{}")) r = i ? r : r.slice(0, -2), t = JSON.stringify(t); else if (ot.isArray(t) && pt(t) || (ot.isFileList(t) || ot.endsWith(r, "[]")) && (a = ot.toArray(t))) return r = dt(r), a.forEach((function (t, i) { !ot.isUndefined(t) && null !== t && e.append(!0 === s ? ft([r], i, o) : null === s ? r : r + "[]", h(t)) })), !1; return !!ct(t) || (e.append(ft(n, r, o), h(t)), !1) } const c = [], d = Object.assign(_t, { defaultVisitor: l, convertValue: h, isVisitable: ct }); function f(t, r) { if (!ot.isUndefined(t)) { if (-1 !== c.indexOf(t)) throw Error("Circular reference detected in " + r.join(".")); c.push(t), ot.forEach(t, (function (t, i) { const o = !(ot.isUndefined(t) || null === t) && n.call(e, t, ot.isString(i) ? i.trim() : i, r, d); !0 === o && f(t, r ? r.concat(i) : [i]) })), c.pop() } } if (!ot.isObject(t)) throw new TypeError("data must be an object"); return f(t), e } var gt = mt; function vt(t) { const e = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, (function (t) { return e[t] })) } function yt(t, e) { this._pairs = [], t && gt(t, this, e) } const bt = yt.prototype; bt.append = function (t, e) { this._pairs.push([t, e]) }, bt.toString = function (t) { const e = t ? function (e) { return t.call(this, e, vt) } : vt; return this._pairs.map((function (t) { return e(t[0]) + "=" + e(t[1]) }), "").join("&") }; var xt = yt; function Tt(t) { return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function Et(t, e, r) { if (!e) return t; const i = r && r.encode || Tt, n = r && r.serialize; let o; if (o = n ? n(e, r) : ot.isURLSearchParams(e) ? e.toString() : new xt(e, r).toString(i), o) { const e = t.indexOf("#"); -1 !== e && (t = t.slice(0, e)), t += (-1 === t.indexOf("?") ? "?" : "&") + o } return t } class St { constructor() { this.handlers = [] } use(t, e, r) { return this.handlers.push({ fulfilled: t, rejected: e, synchronous: !!r && r.synchronous, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(t) { this.handlers[t] && (this.handlers[t] = null) } clear() { this.handlers && (this.handlers = []) } forEach(t) { ot.forEach(this.handlers, (function (e) { null !== e && t(e) })) } } var wt = St, At = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Rt = "undefined" !== typeof URLSearchParams ? URLSearchParams : xt, Ot = "undefined" !== typeof FormData ? FormData : null, It = "undefined" !== typeof Blob ? Blob : null; const Pt = (() => { let t; return ("undefined" === typeof navigator || "ReactNative" !== (t = navigator.product) && "NativeScript" !== t && "NS" !== t) && ("undefined" !== typeof window && "undefined" !== typeof document) })(), Mt = (() => "undefined" !== typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" === typeof self.importScripts)(); var Ct = { isBrowser: !0, classes: { URLSearchParams: Rt, FormData: Ot, Blob: It }, isStandardBrowserEnv: Pt, isStandardBrowserWebWorkerEnv: Mt, protocols: ["http", "https", "file", "blob", "url", "data"] }; function Dt(t, e) { return gt(t, new Ct.classes.URLSearchParams, Object.assign({ visitor: function (t, e, r, i) { return Ct.isNode && ot.isBuffer(t) ? (this.append(e, t.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments) } }, e)) } function Lt(t) { return ot.matchAll(/\w+|\[(\w*)]/g, t).map((t => "[]" === t[0] ? "" : t[1] || t[0])) } function Ft(t) { const e = {}, r = Object.keys(t); let i; const n = r.length; let o; for (i = 0; i < n; i++)o = r[i], e[o] = t[o]; return e } function Nt(t) { function e(t, r, i, n) { let o = t[n++]; const s = Number.isFinite(+o), a = n >= t.length; if (o = !o && ot.isArray(i) ? i.length : o, a) return ot.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !s; i[o] && ot.isObject(i[o]) || (i[o] = []); const u = e(t, r, i[o], n); return u && ot.isArray(i[o]) && (i[o] = Ft(i[o])), !s } if (ot.isFormData(t) && ot.isFunction(t.entries)) { const r = {}; return ot.forEachEntry(t, ((t, i) => { e(Lt(t), i, r, 0) })), r } return null } var Bt = Nt; const Ut = { "Content-Type": void 0 }; function kt(t, e, r) { if (ot.isString(t)) try { return (e || JSON.parse)(t), ot.trim(t) } catch (i) { if ("SyntaxError" !== i.name) throw i } return (r || JSON.stringify)(t) } const Gt = { transitional: At, adapter: ["xhr", "http"], transformRequest: [function (t, e) { const r = e.getContentType() || "", i = r.indexOf("application/json") > -1, n = ot.isObject(t); n && ot.isHTMLForm(t) && (t = new FormData(t)); const o = ot.isFormData(t); if (o) return i && i ? JSON.stringify(Bt(t)) : t; if (ot.isArrayBuffer(t) || ot.isBuffer(t) || ot.isStream(t) || ot.isFile(t) || ot.isBlob(t)) return t; if (ot.isArrayBufferView(t)) return t.buffer; if (ot.isURLSearchParams(t)) return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString(); let s; if (n) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return Dt(t, this.formSerializer).toString(); if ((s = ot.isFileList(t)) || r.indexOf("multipart/form-data") > -1) { const e = this.env && this.env.FormData; return gt(s ? { "files[]": t } : t, e && new e, this.formSerializer) } } return n || i ? (e.setContentType("application/json", !1), kt(t)) : t }], transformResponse: [function (t) { const e = this.transitional || Gt.transitional, r = e && e.forcedJSONParsing, i = "json" === this.responseType; if (t && ot.isString(t) && (r && !this.responseType || i)) { const r = e && e.silentJSONParsing, o = !r && i; try { return JSON.parse(t) } catch (n) { if (o) { if ("SyntaxError" === n.name) throw ht.from(n, ht.ERR_BAD_RESPONSE, this, null, this.response); throw n } } } return t }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Ct.classes.FormData, Blob: Ct.classes.Blob }, validateStatus: function (t) { return t >= 200 && t < 300 }, headers: { common: { Accept: "application/json, text/plain, */*" } } }; ot.forEach(["delete", "get", "head"], (function (t) { Gt.headers[t] = {} })), ot.forEach(["post", "put", "patch"], (function (t) { Gt.headers[t] = ot.merge(Ut) })); var Xt = Gt; const jt = ot.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]); var Ht = t => { const e = {}; let r, i, n; return t && t.split("\n").forEach((function (t) { n = t.indexOf(":"), r = t.substring(0, n).trim().toLowerCase(), i = t.substring(n + 1).trim(), !r || e[r] && jt[r] || ("set-cookie" === r ? e[r] ? e[r].push(i) : e[r] = [i] : e[r] = e[r] ? e[r] + ", " + i : i) })), e }; const Vt = Symbol("internals"); function zt(t) { return t && String(t).trim().toLowerCase() } function Yt(t) { return !1 === t || null == t ? t : ot.isArray(t) ? t.map(Yt) : String(t) } function Wt(t) { const e = Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let i; while (i = r.exec(t)) e[i[1]] = i[2]; return e } const $t = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()); function qt(t, e, r, i, n) { return ot.isFunction(i) ? i.call(this, e, r) : (n && (e = r), ot.isString(e) ? ot.isString(i) ? -1 !== e.indexOf(i) : ot.isRegExp(i) ? i.test(e) : void 0 : void 0) } function Kt(t) { return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((t, e, r) => e.toUpperCase() + r)) } function Zt(t, e) { const r = ot.toCamelCase(" " + e);["get", "set", "has"].forEach((i => { Object.defineProperty(t, i + r, { value: function (t, r, n) { return this[i].call(this, e, t, r, n) }, configurable: !0 }) })) } class Jt { constructor(t) { t && this.set(t) } set(t, e, r) { const i = this; function n(t, e, r) { const n = zt(e); if (!n) throw new Error("header name must be a non-empty string"); const o = ot.findKey(i, n); (!o || void 0 === i[o] || !0 === r || void 0 === r && !1 !== i[o]) && (i[o || e] = Yt(t)) } const o = (t, e) => ot.forEach(t, ((t, r) => n(t, r, e))); return ot.isPlainObject(t) || t instanceof this.constructor ? o(t, e) : ot.isString(t) && (t = t.trim()) && !$t(t) ? o(Ht(t), e) : null != t && n(e, t, r), this } get(t, e) { if (t = zt(t), t) { const r = ot.findKey(this, t); if (r) { const t = this[r]; if (!e) return t; if (!0 === e) return Wt(t); if (ot.isFunction(e)) return e.call(this, t, r); if (ot.isRegExp(e)) return e.exec(t); throw new TypeError("parser must be boolean|regexp|function") } } } has(t, e) { if (t = zt(t), t) { const r = ot.findKey(this, t); return !(!r || void 0 === this[r] || e && !qt(this, this[r], r, e)) } return !1 } delete(t, e) { const r = this; let i = !1; function n(t) { if (t = zt(t), t) { const n = ot.findKey(r, t); !n || e && !qt(r, r[n], n, e) || (delete r[n], i = !0) } } return ot.isArray(t) ? t.forEach(n) : n(t), i } clear(t) { const e = Object.keys(this); let r = e.length, i = !1; while (r--) { const n = e[r]; t && !qt(this, this[n], n, t, !0) || (delete this[n], i = !0) } return i } normalize(t) { const e = this, r = {}; return ot.forEach(this, ((i, n) => { const o = ot.findKey(r, n); if (o) return e[o] = Yt(i), void delete e[n]; const s = t ? Kt(n) : String(n).trim(); s !== n && delete e[n], e[s] = Yt(i), r[s] = !0 })), this } concat(...t) { return this.constructor.concat(this, ...t) } toJSON(t) { const e = Object.create(null); return ot.forEach(this, ((r, i) => { null != r && !1 !== r && (e[i] = t && ot.isArray(r) ? r.join(", ") : r) })), e } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() { return Object.entries(this.toJSON()).map((([t, e]) => t + ": " + e)).join("\n") } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(t) { return t instanceof this ? t : new this(t) } static concat(t, ...e) { const r = new this(t); return e.forEach((t => r.set(t))), r } static accessor(t) { const e = this[Vt] = this[Vt] = { accessors: {} }, r = e.accessors, i = this.prototype; function n(t) { const e = zt(t); r[e] || (Zt(i, t), r[e] = !0) } return ot.isArray(t) ? t.forEach(n) : n(t), this } } Jt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), ot.freezeMethods(Jt.prototype), ot.freezeMethods(Jt); var Qt = Jt; function te(t, e) { const r = this || Xt, i = e || r, n = Qt.from(i.headers); let o = i.data; return ot.forEach(t, (function (t) { o = t.call(r, o, n.normalize(), e ? e.status : void 0) })), n.normalize(), o } function ee(t) { return !(!t || !t.__CANCEL__) } function re(t, e, r) { ht.call(this, null == t ? "canceled" : t, ht.ERR_CANCELED, e, r), this.name = "CanceledError" } ot.inherits(re, ht, { __CANCEL__: !0 }); var ie = re; r(2801); function ne(t, e, r) { const i = r.config.validateStatus; r.status && i && !i(r.status) ? e(new ht("Request failed with status code " + r.status, [ht.ERR_BAD_REQUEST, ht.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4], r.config, r.request, r)) : t(r) } var oe = Ct.isStandardBrowserEnv ? function () { return { write: function (t, e, r, i, n, o) { const s = []; s.push(t + "=" + encodeURIComponent(e)), ot.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), ot.isString(i) && s.push("path=" + i), ot.isString(n) && s.push("domain=" + n), !0 === o && s.push("secure"), document.cookie = s.join("; ") }, read: function (t) { const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")); return e ? decodeURIComponent(e[3]) : null }, remove: function (t) { this.write(t, "", Date.now() - 864e5) } } }() : function () { return { write: function () { }, read: function () { return null }, remove: function () { } } }(); function se(t) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) } function ae(t, e) { return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t } function ue(t, e) { return t && !se(e) ? ae(t, e) : e } var he = Ct.isStandardBrowserEnv ? function () { const t = /(msie|trident)/i.test(navigator.userAgent), e = document.createElement("a"); let r; function i(r) { let i = r; return t && (e.setAttribute("href", i), i = e.href), e.setAttribute("href", i), { href: e.href, protocol: e.protocol ? e.protocol.replace(/:$/, "") : "", host: e.host, search: e.search ? e.search.replace(/^\?/, "") : "", hash: e.hash ? e.hash.replace(/^#/, "") : "", hostname: e.hostname, port: e.port, pathname: "/" === e.pathname.charAt(0) ? e.pathname : "/" + e.pathname } } return r = i(window.location.href), function (t) { const e = ot.isString(t) ? i(t) : t; return e.protocol === r.protocol && e.host === r.host } }() : function () { return function () { return !0 } }(); function le(t) { const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t); return e && e[1] || "" } function ce(t, e) { t = t || 10; const r = new Array(t), i = new Array(t); let n, o = 0, s = 0; return e = void 0 !== e ? e : 1e3, function (a) { const u = Date.now(), h = i[s]; n || (n = u), r[o] = a, i[o] = u; let l = s, c = 0; while (l !== o) c += r[l++], l %= t; if (o = (o + 1) % t, o === s && (s = (s + 1) % t), u - n < e) return; const d = h && u - h; return d ? Math.round(1e3 * c / d) : void 0 } } var de = ce; function fe(t, e) { let r = 0; const i = de(50, 250); return n => { const o = n.loaded, s = n.lengthComputable ? n.total : void 0, a = o - r, u = i(a), h = o <= s; r = o; const l = { loaded: o, total: s, progress: s ? o / s : void 0, bytes: a, rate: u || void 0, estimated: u && s && h ? (s - o) / u : void 0, event: n }; l[e ? "download" : "upload"] = !0, t(l) } } const pe = "undefined" !== typeof XMLHttpRequest; var _e = pe && function (t) { return new Promise((function (e, r) { let i = t.data; const n = Qt.from(t.headers).normalize(), o = t.responseType; let s; function a() { t.cancelToken && t.cancelToken.unsubscribe(s), t.signal && t.signal.removeEventListener("abort", s) } ot.isFormData(i) && (Ct.isStandardBrowserEnv || Ct.isStandardBrowserWebWorkerEnv ? n.setContentType(!1) : n.setContentType("multipart/form-data;", !1)); let u = new XMLHttpRequest; if (t.auth) { const e = t.auth.username || "", r = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : ""; n.set("Authorization", "Basic " + btoa(e + ":" + r)) } const h = ue(t.baseURL, t.url); function l() { if (!u) return; const i = Qt.from("getAllResponseHeaders" in u && u.getAllResponseHeaders()), n = o && "text" !== o && "json" !== o ? u.response : u.responseText, s = { data: n, status: u.status, statusText: u.statusText, headers: i, config: t, request: u }; ne((function (t) { e(t), a() }), (function (t) { r(t), a() }), s), u = null } if (u.open(t.method.toUpperCase(), Et(h, t.params, t.paramsSerializer), !0), u.timeout = t.timeout, "onloadend" in u ? u.onloadend = l : u.onreadystatechange = function () { u && 4 === u.readyState && (0 !== u.status || u.responseURL && 0 === u.responseURL.indexOf("file:")) && setTimeout(l) }, u.onabort = function () { u && (r(new ht("Request aborted", ht.ECONNABORTED, t, u)), u = null) }, u.onerror = function () { r(new ht("Network Error", ht.ERR_NETWORK, t, u)), u = null }, u.ontimeout = function () { let e = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded"; const i = t.transitional || At; t.timeoutErrorMessage && (e = t.timeoutErrorMessage), r(new ht(e, i.clarifyTimeoutError ? ht.ETIMEDOUT : ht.ECONNABORTED, t, u)), u = null }, Ct.isStandardBrowserEnv) { const e = (t.withCredentials || he(h)) && t.xsrfCookieName && oe.read(t.xsrfCookieName); e && n.set(t.xsrfHeaderName, e) } void 0 === i && n.setContentType(null), "setRequestHeader" in u && ot.forEach(n.toJSON(), (function (t, e) { u.setRequestHeader(e, t) })), ot.isUndefined(t.withCredentials) || (u.withCredentials = !!t.withCredentials), o && "json" !== o && (u.responseType = t.responseType), "function" === typeof t.onDownloadProgress && u.addEventListener("progress", fe(t.onDownloadProgress, !0)), "function" === typeof t.onUploadProgress && u.upload && u.upload.addEventListener("progress", fe(t.onUploadProgress)), (t.cancelToken || t.signal) && (s = e => { u && (r(!e || e.type ? new ie(null, t, u) : e), u.abort(), u = null) }, t.cancelToken && t.cancelToken.subscribe(s), t.signal && (t.signal.aborted ? s() : t.signal.addEventListener("abort", s))); const c = le(h); c && -1 === Ct.protocols.indexOf(c) ? r(new ht("Unsupported protocol " + c + ":", ht.ERR_BAD_REQUEST, t)) : u.send(i || null) })) }; const me = { http: lt, xhr: _e }; ot.forEach(me, ((t, e) => { if (t) { try { Object.defineProperty(t, "name", { value: e }) } catch (r) { } Object.defineProperty(t, "adapterName", { value: e }) } })); var ge = { getAdapter: t => { t = ot.isArray(t) ? t : [t]; const { length: e } = t; let r, i; for (let n = 0; n < e; n++)if (r = t[n], i = ot.isString(r) ? me[r.toLowerCase()] : r) break; if (!i) { if (!1 === i) throw new ht(`Adapter ${r} is not supported by the environment`, "ERR_NOT_SUPPORT"); throw new Error(ot.hasOwnProp(me, r) ? `Adapter '${r}' is not available in the build` : `Unknown adapter '${r}'`) } if (!ot.isFunction(i)) throw new TypeError("adapter is not a function"); return i }, adapters: me }; function ve(t) { if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new ie(null, t) } function ye(t) { ve(t), t.headers = Qt.from(t.headers), t.data = te.call(t, t.transformRequest), -1 !== ["post", "put", "patch"].indexOf(t.method) && t.headers.setContentType("application/x-www-form-urlencoded", !1); const e = ge.getAdapter(t.adapter || Xt.adapter); return e(t).then((function (e) { return ve(t), e.data = te.call(t, t.transformResponse, e), e.headers = Qt.from(e.headers), e }), (function (e) { return ee(e) || (ve(t), e && e.response && (e.response.data = te.call(t, t.transformResponse, e.response), e.response.headers = Qt.from(e.response.headers))), Promise.reject(e) })) } const be = t => t instanceof Qt ? t.toJSON() : t; function xe(t, e) { e = e || {}; const r = {}; function i(t, e, r) { return ot.isPlainObject(t) && ot.isPlainObject(e) ? ot.merge.call({ caseless: r }, t, e) : ot.isPlainObject(e) ? ot.merge({}, e) : ot.isArray(e) ? e.slice() : e } function n(t, e, r) { return ot.isUndefined(e) ? ot.isUndefined(t) ? void 0 : i(void 0, t, r) : i(t, e, r) } function o(t, e) { if (!ot.isUndefined(e)) return i(void 0, e) } function s(t, e) { return ot.isUndefined(e) ? ot.isUndefined(t) ? void 0 : i(void 0, t) : i(void 0, e) } function a(r, n, o) { return o in e ? i(r, n) : o in t ? i(void 0, r) : void 0 } const u = { url: o, method: o, data: o, baseURL: s, transformRequest: s, transformResponse: s, paramsSerializer: s, timeout: s, timeoutMessage: s, withCredentials: s, adapter: s, responseType: s, xsrfCookieName: s, xsrfHeaderName: s, onUploadProgress: s, onDownloadProgress: s, decompress: s, maxContentLength: s, maxBodyLength: s, beforeRedirect: s, transport: s, httpAgent: s, httpsAgent: s, cancelToken: s, socketPath: s, responseEncoding: s, validateStatus: a, headers: (t, e) => n(be(t), be(e), !0) }; return ot.forEach(Object.keys(Object.assign({}, t, e)), (function (i) { const o = u[i] || n, s = o(t[i], e[i], i); ot.isUndefined(s) && o !== a || (r[i] = s) })), r } const Te = "1.4.0", Ee = {};["object", "boolean", "number", "function", "string", "symbol"].forEach(((t, e) => { Ee[t] = function (r) { return typeof r === t || "a" + (e < 1 ? "n " : " ") + t } })); const Se = {}; function we(t, e, r) { if ("object" !== typeof t) throw new ht("options must be an object", ht.ERR_BAD_OPTION_VALUE); const i = Object.keys(t); let n = i.length; while (n-- > 0) { const o = i[n], s = e[o]; if (s) { const e = t[o], r = void 0 === e || s(e, o, t); if (!0 !== r) throw new ht("option " + o + " must be " + r, ht.ERR_BAD_OPTION_VALUE) } else if (!0 !== r) throw new ht("Unknown option " + o, ht.ERR_BAD_OPTION) } } Ee.transitional = function (t, e, r) { function i(t, e) { return "[Axios v" + Te + "] Transitional option '" + t + "'" + e + (r ? ". " + r : "") } return (r, n, o) => { if (!1 === t) throw new ht(i(n, " has been removed" + (e ? " in " + e : "")), ht.ERR_DEPRECATED); return e && !Se[n] && (Se[n] = !0, console.warn(i(n, " has been deprecated since v" + e + " and will be removed in the near future"))), !t || t(r, n, o) } }; var Ae = { assertOptions: we, validators: Ee }; const Re = Ae.validators; class Oe { constructor(t) { this.defaults = t, this.interceptors = { request: new wt, response: new wt } } request(t, e) { "string" === typeof t ? (e = e || {}, e.url = t) : e = t || {}, e = xe(this.defaults, e); const { transitional: r, paramsSerializer: i, headers: n } = e; let o; void 0 !== r && Ae.assertOptions(r, { silentJSONParsing: Re.transitional(Re.boolean), forcedJSONParsing: Re.transitional(Re.boolean), clarifyTimeoutError: Re.transitional(Re.boolean) }, !1), null != i && (ot.isFunction(i) ? e.paramsSerializer = { serialize: i } : Ae.assertOptions(i, { encode: Re.function, serialize: Re.function }, !0)), e.method = (e.method || this.defaults.method || "get").toLowerCase(), o = n && ot.merge(n.common, n[e.method]), o && ot.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (t => { delete n[t] })), e.headers = Qt.concat(o, n); const s = []; let a = !0; this.interceptors.request.forEach((function (t) { "function" === typeof t.runWhen && !1 === t.runWhen(e) || (a = a && t.synchronous, s.unshift(t.fulfilled, t.rejected)) })); const u = []; let h; this.interceptors.response.forEach((function (t) { u.push(t.fulfilled, t.rejected) })); let l, c = 0; if (!a) { const t = [ye.bind(this), void 0]; t.unshift.apply(t, s), t.push.apply(t, u), l = t.length, h = Promise.resolve(e); while (c < l) h = h.then(t[c++], t[c++]); return h } l = s.length; let d = e; c = 0; while (c < l) { const t = s[c++], e = s[c++]; try { d = t(d) } catch (f) { e.call(this, f); break } } try { h = ye.call(this, d) } catch (f) { return Promise.reject(f) } c = 0, l = u.length; while (c < l) h = h.then(u[c++], u[c++]); return h } getUri(t) { t = xe(this.defaults, t); const e = ue(t.baseURL, t.url); return Et(e, t.params, t.paramsSerializer) } } ot.forEach(["delete", "get", "head", "options"], (function (t) { Oe.prototype[t] = function (e, r) { return this.request(xe(r || {}, { method: t, url: e, data: (r || {}).data })) } })), ot.forEach(["post", "put", "patch"], (function (t) { function e(e) { return function (r, i, n) { return this.request(xe(n || {}, { method: t, headers: e ? { "Content-Type": "multipart/form-data" } : {}, url: r, data: i })) } } Oe.prototype[t] = e(), Oe.prototype[t + "Form"] = e(!0) })); var Ie = Oe; class Pe { constructor(t) { if ("function" !== typeof t) throw new TypeError("executor must be a function."); let e; this.promise = new Promise((function (t) { e = t })); const r = this; this.promise.then((t => { if (!r._listeners) return; let e = r._listeners.length; while (e-- > 0) r._listeners[e](t); r._listeners = null })), this.promise.then = t => { let e; const i = new Promise((t => { r.subscribe(t), e = t })).then(t); return i.cancel = function () { r.unsubscribe(e) }, i }, t((function (t, i, n) { r.reason || (r.reason = new ie(t, i, n), e(r.reason)) })) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(t) { this.reason ? t(this.reason) : this._listeners ? this._listeners.push(t) : this._listeners = [t] } unsubscribe(t) { if (!this._listeners) return; const e = this._listeners.indexOf(t); -1 !== e && this._listeners.splice(e, 1) } static source() { let t; const e = new Pe((function (e) { t = e })); return { token: e, cancel: t } } } var Me = Pe; function Ce(t) { return function (e) { return t.apply(null, e) } } function De(t) { return ot.isObject(t) && !0 === t.isAxiosError } const Le = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Le).forEach((([t, e]) => { Le[e] = t })); var Fe = Le; function Ne(t) { const e = new Ie(t), r = i(Ie.prototype.request, e); return ot.extend(r, Ie.prototype, e, { allOwnKeys: !0 }), ot.extend(r, e, null, { allOwnKeys: !0 }), r.create = function (e) { return Ne(xe(t, e)) }, r } const Be = Ne(Xt); Be.Axios = Ie, Be.CanceledError = ie, Be.CancelToken = Me, Be.isCancel = ee, Be.VERSION = Te, Be.toFormData = gt, Be.AxiosError = ht, Be.Cancel = Be.CanceledError, Be.all = function (t) { return Promise.all(t) }, Be.spread = Ce, Be.isAxiosError = De, Be.mergeConfig = xe, Be.AxiosHeaders = Qt, Be.formToJSON = t => Bt(ot.isHTMLForm(t) ? new FormData(t) : t), Be.HttpStatusCode = Fe, Be.default = Be; var Ue = Be }, 9858: function (t, e, r) {
        "use strict"; r.r(e), r.d(e, { ALPHA_MODES: function () { return et.iw }, AbstractBatchRenderer: function () { return M.eo }, AbstractMultiResource: function () { return M.M4 }, AbstractRenderer: function () { return M.I8 }, AccessibilityManager: function () { return j }, AnimatedSprite: function () { return kn }, AppLoaderPlugin: function () { return Rt }, Application: function () { return An }, ArrayResource: function () { return M.$N }, Attribute: function () { return M.ah }, BLEND_MODES: function () { return et.T$ }, BUFFER_BITS: function () { return et.V0 }, BUFFER_TYPE: function () { return et.mr }, BaseImageResource: function () { return M.bg }, BasePrepare: function () { return qr }, BaseRenderTexture: function () { return M.jd }, BaseTexture: function () { return M.VL }, BatchDrawCall: function () { return M.a$ }, BatchGeometry: function () { return M.JZ }, BatchPluginFactory: function () { return M.TJ }, BatchRenderer: function () { return M.Bv }, BatchShaderGenerator: function () { return M.Zk }, BatchSystem: function () { return M.Sj }, BatchTextureArray: function () { return M.Ie }, BitmapFont: function () { return Bi }, BitmapFontData: function () { return Ai }, BitmapFontLoader: function () { return Vi }, BitmapText: function () { return Hi }, BlobResource: function () { return Ht }, Bounds: function () { return P.YZ }, BrowserAdapter: function () { return Ft.ZQ }, Buffer: function () { return M.lW }, BufferResource: function () { return M.qm }, CLEAR_MODES: function () { return et.yl }, COLOR_MASK_BITS: function () { return et.V3 }, CanvasResource: function () { return M.Y8 }, Circle: function () { return H.Cd }, CompressedTextureLoader: function () { return zt }, CompressedTextureResource: function () { return Vt }, Container: function () { return P.W2 }, ContextSystem: function () { return M.lH }, CountLimiter: function () { return Xr }, CubeResource: function () { return M.TA }, DDSLoader: function () { return Me }, DEG_TO_RAD: function () { return H.ZX }, DRAW_MODES: function () { return et.lg }, DisplayObject: function () { return P.s$ }, ENV: function () { return et.Vi }, Ellipse: function () { return H.Pj }, ExtensionType: function () { return M.nw }, Extract: function () { return nt }, FORMATS: function () { return et.I2 }, FORMATS_TO_COMPONENTS: function () { return we }, FillStyle: function () { return He }, Filter: function () { return M.wn }, FilterState: function () { return M.jV }, FilterSystem: function () { return M.kV }, Framebuffer: function () { return M.AI }, FramebufferSystem: function () { return M.WB }, GC_MODES: function () { return et.UN }, GLFramebuffer: function () { return M.tT }, GLProgram: function () { return M.Ei }, GLTexture: function () { return M.fy }, GRAPHICS_CURVES: function () { return je }, Geometry: function () { return M.ZX }, GeometrySystem: function () { return M.TO }, Graphics: function () { return vr }, GraphicsData: function () { return dr }, GraphicsGeometry: function () { return pr }, IGLUniformData: function () { return M.W1 }, INSTALLED: function () { return M.e_ }, INTERNAL_FORMATS: function () { return Lt }, INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: function () { return Nt }, ImageBitmapResource: function () { return M._w }, ImageResource: function () { return M.PA }, InteractionData: function () { return z }, InteractionEvent: function () { return $ }, InteractionManager: function () { return tt }, InteractionTrackingData: function () { return q }, KTXLoader: function () { return Ce }, LINE_CAP: function () { return Ne }, LINE_JOIN: function () { return Fe }, LineStyle: function () { return _r }, Loader: function () { return At }, LoaderResource: function () { return yt }, MASK_TYPES: function () { return et.A7 }, MIPMAP_MODES: function () { return et.WB }, MSAA_QUALITY: function () { return et.G5 }, MaskData: function () { return M.HI }, MaskSystem: function () { return M.zj }, Matrix: function () { return H.y3 }, Mesh: function () { return yi }, MeshBatchUvs: function () { return mi }, MeshGeometry: function () { return Ei }, MeshMaterial: function () { return Ti }, NineSlicePlane: function () { return Fn }, ObjectRenderer: function () { return M.bO }, ObservablePoint: function () { return H.AB }, PI_2: function () { return H._b }, PRECISION: function () { return et.cB }, ParticleContainer: function () { return Be }, ParticleRenderer: function () { return Xe }, PlaneGeometry: function () { return In }, Point: function () { return H.E9 }, Polygon: function () { return H.mg }, Prepare: function () { return Qr }, Program: function () { return M.$r }, ProjectionSystem: function () { return M.NW }, Quad: function () { return M.lD }, QuadUv: function () { return M.ud }, RAD_TO_DEG: function () { return H.jl }, RENDERER_TYPE: function () { return et.N3 }, Rectangle: function () { return H.Ae }, RenderTexture: function () { return M.TI }, RenderTexturePool: function () { return M.uW }, RenderTextureSystem: function () { return M.J$ }, Renderer: function () { return M.Th }, ResizePlugin: function () { return wn }, Resource: function () { return M._z }, RopeGeometry: function () { return Pn }, RoundedRectangle: function () { return H.c9 }, Runner: function () { return Nn.R }, SAMPLER_TYPES: function () { return et.oT }, SCALE_MODES: function () { return et.aH }, SHAPES: function () { return H.HS }, SVGResource: function () { return M.pX }, ScissorSystem: function () { return M.id }, Shader: function () { return M.ex }, ShaderSystem: function () { return M.p }, SimpleMesh: function () { return Dn }, SimplePlane: function () { return Cn }, SimpleRope: function () { return Mn }, Sprite: function () { return wr }, SpriteMaskFilter: function () { return M.z9 }, Spritesheet: function () { return ei }, SpritesheetLoader: function () { return ri }, State: function () { return M.ZM }, StateSystem: function () { return M.zI }, StencilSystem: function () { return M.Ld }, System: function () { return M.xP }, TARGETS: function () { return et.sp }, TEXT_GRADIENT: function () { return Tr }, TYPES: function () { return et.vK }, TYPES_TO_BYTES_PER_COMPONENT: function () { return Se }, TYPES_TO_BYTES_PER_PIXEL: function () { return Ae }, TemporaryDisplayObject: function () { return P.Ql }, Text: function () { return Ur }, TextFormat: function () { return Ri }, TextMetrics: function () { return Nr }, TextStyle: function () { return Pr }, Texture: function () { return M.xE }, TextureGCSystem: function () { return M.wr }, TextureLoader: function () { return Ot }, TextureMatrix: function () { return M.UX }, TextureSystem: function () { return M.CT }, TextureUvs: function () { return M.aF }, Ticker: function () { return V.vB }, TickerPlugin: function () { return V.Sb }, TilingSprite: function () { return si }, TilingSpriteRenderer: function () { return fi }, TimeLimiter: function () { return ti }, Transform: function () { return H.wx }, UPDATE_PRIORITY: function () { return V.uF }, UniformGroup: function () { return M.oo }, VERSION: function () { return M.q4 }, VideoResource: function () { return M.eH }, ViewableBuffer: function () { return M.Rv }, WRAP_MODES: function () { return et.Nt }, XMLFormat: function () { return Oi }, XMLStringFormat: function () { return Ii }, accessibleTarget: function () { return C }, autoDetectFormat: function () { return Mi }, autoDetectRenderer: function () { return M.e6 }, autoDetectResource: function () { return M.pb }, checkMaxIfStatementsInShader: function () { return M.a7 }, createUBOElements: function () { return M.TF }, defaultFilterVertex: function () { return M.Y9 }, defaultVertex: function () { return M.kP }, extensions: function () { return M.Rw }, filters: function () { return Gn }, generateProgram: function () { return M.qw }, generateUniformBufferSync: function () { return M.K0 }, getTestContext: function () { return M.Kc }, getUBOData: function () { return M.DL }, graphicsUtils: function () { return yr }, groupD8: function () { return H.Lv }, interactiveTarget: function () { return Z }, isMobile: function () { return Ft.tq }, parseDDS: function () { return ye }, parseKTX: function () { return Re }, resources: function () { return M.Jb }, settings: function () { return Ft.Xd }, systems: function () { return M.eG }, uniformParsers: function () { return M.sg }, utils: function () { return I } }); r(3767), r(8585), r(8696); function i(t) { var e = this.constructor; return this.then((function (r) { return e.resolve(t()).then((function () { return r })) }), (function (r) { return e.resolve(t()).then((function () { return e.reject(r) })) })) } var n = i; function o(t) { var e = this; return new e((function (e, r) { if (!t || "undefined" === typeof t.length) return r(new TypeError(typeof t + " " + t + " is not iterable(cannot read property Symbol(Symbol.iterator))")); var i = Array.prototype.slice.call(t); if (0 === i.length) return e([]); var n = i.length; function o(t, r) { if (r && ("object" === typeof r || "function" === typeof r)) { var s = r.then; if ("function" === typeof s) return void s.call(r, (function (e) { o(t, e) }), (function (r) { i[t] = { status: "rejected", reason: r }, 0 === --n && e(i) })) } i[t] = { status: "fulfilled", value: r }, 0 === --n && e(i) } for (var s = 0; s < i.length; s++)o(s, i[s]) })) } var s = o; function a(t, e) { this.name = "AggregateError", this.errors = t, this.message = e || "" } function u(t) { var e = this; return new e((function (r, i) { if (!t || "undefined" === typeof t.length) return i(new TypeError("Promise.any accepts an array")); var n = Array.prototype.slice.call(t); if (0 === n.length) return i(); for (var o = [], s = 0; s < n.length; s++)try { e.resolve(n[s]).then(r).catch((function (t) { o.push(t), o.length === n.length && i(new a(o, "All promises were rejected")) })) } catch (u) { i(u) } })) } a.prototype = Error.prototype; var h = u, l = setTimeout; function c(t) { return Boolean(t && "undefined" !== typeof t.length) } function d() { } function f(t, e) { return function () { t.apply(e, arguments) } } function p(t) { if (!(this instanceof p)) throw new TypeError("Promises must be constructed via new"); if ("function" !== typeof t) throw new TypeError("not a function"); this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], b(t, this) } function _(t, e) { while (3 === t._state) t = t._value; 0 !== t._state ? (t._handled = !0, p._immediateFn((function () { var r = 1 === t._state ? e.onFulfilled : e.onRejected; if (null !== r) { var i; try { i = r(t._value) } catch (n) { return void g(e.promise, n) } m(e.promise, i) } else (1 === t._state ? m : g)(e.promise, t._value) }))) : t._deferreds.push(e) } function m(t, e) { try { if (e === t) throw new TypeError("A promise cannot be resolved with itself."); if (e && ("object" === typeof e || "function" === typeof e)) { var r = e.then; if (e instanceof p) return t._state = 3, t._value = e, void v(t); if ("function" === typeof r) return void b(f(r, e), t) } t._state = 1, t._value = e, v(t) } catch (i) { g(t, i) } } function g(t, e) { t._state = 2, t._value = e, v(t) } function v(t) { 2 === t._state && 0 === t._deferreds.length && p._immediateFn((function () { t._handled || p._unhandledRejectionFn(t._value) })); for (var e = 0, r = t._deferreds.length; e < r; e++)_(t, t._deferreds[e]); t._deferreds = null } function y(t, e, r) { this.onFulfilled = "function" === typeof t ? t : null, this.onRejected = "function" === typeof e ? e : null, this.promise = r } function b(t, e) { var r = !1; try { t((function (t) { r || (r = !0, m(e, t)) }), (function (t) { r || (r = !0, g(e, t)) })) } catch (i) { if (r) return; r = !0, g(e, i) } } p.prototype["catch"] = function (t) { return this.then(null, t) }, p.prototype.then = function (t, e) { var r = new this.constructor(d); return _(this, new y(t, e, r)), r }, p.prototype["finally"] = n, p.all = function (t) { return new p((function (e, r) { if (!c(t)) return r(new TypeError("Promise.all accepts an array")); var i = Array.prototype.slice.call(t); if (0 === i.length) return e([]); var n = i.length; function o(t, s) { try { if (s && ("object" === typeof s || "function" === typeof s)) { var a = s.then; if ("function" === typeof a) return void a.call(s, (function (e) { o(t, e) }), r) } i[t] = s, 0 === --n && e(i) } catch (u) { r(u) } } for (var s = 0; s < i.length; s++)o(s, i[s]) })) }, p.any = h, p.allSettled = s, p.resolve = function (t) { return t && "object" === typeof t && t.constructor === p ? t : new p((function (e) { e(t) })) }, p.reject = function (t) { return new p((function (e, r) { r(t) })) }, p.race = function (t) { return new p((function (e, r) { if (!c(t)) return r(new TypeError("Promise.race accepts an array")); for (var i = 0, n = t.length; i < n; i++)p.resolve(t[i]).then(e, r) })) }, p._immediateFn = "function" === typeof setImmediate && function (t) { setImmediate(t) } || function (t) { l(t, 0) }, p._unhandledRejectionFn = function (t) { "undefined" !== typeof console && console && console.warn("Possible Unhandled Promise Rejection:", t) }; var x = p, T = r(7167);
        /*!
         * @pixi/polyfill - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * @pixi/polyfill is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        "undefined" === typeof globalThis && ("undefined" !== typeof self ? self.globalThis = self : "undefined" !== typeof global && (global.globalThis = global)), globalThis.Promise || (globalThis.Promise = x), Object.assign || (Object.assign = T); var E = 16; if (Date.now && Date.prototype.getTime || (Date.now = function () { return (new Date).getTime() }), !globalThis.performance || !globalThis.performance.now) { var S = Date.now(); globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function () { return Date.now() - S } } for (var w = Date.now(), A = ["ms", "moz", "webkit", "o"], R = 0; R < A.length && !globalThis.requestAnimationFrame; ++R) { var O = A[R]; globalThis.requestAnimationFrame = globalThis[O + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[O + "CancelAnimationFrame"] || globalThis[O + "CancelRequestAnimationFrame"] } globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function (t) { if ("function" !== typeof t) throw new TypeError(t + "is not a function"); var e = Date.now(), r = E + w - e; return r < 0 && (r = 0), w = e, globalThis.self.setTimeout((function () { w = Date.now(), t(performance.now()) }), r) }), globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function (t) { return clearTimeout(t) }), Math.sign || (Math.sign = function (t) { return t = Number(t), 0 === t || isNaN(t) ? t : t > 0 ? 1 : -1 }), Number.isInteger || (Number.isInteger = function (t) { return "number" === typeof t && isFinite(t) && Math.floor(t) === t }), globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array), globalThis.Float32Array || (globalThis.Float32Array = Array), globalThis.Uint32Array || (globalThis.Uint32Array = Array), globalThis.Uint16Array || (globalThis.Uint16Array = Array), globalThis.Uint8Array || (globalThis.Uint8Array = Array), globalThis.Int32Array || (globalThis.Int32Array = Array); var I = r(5506), P = (r(7658), r(9782)), M = r(1493), C = { accessible: !1, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: !1, _accessibleDiv: null, accessibleType: "button", accessiblePointerEvents: "auto", accessibleChildren: !0, renderId: -1 }; P.s$.mixin(C); var D = 9, L = 100, F = 0, N = 0, B = 2, U = 1, k = -1e3, G = -1e3, X = 2, j = function () { function t(t) { this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (I.isMobile.tablet || I.isMobile.phone) && this.createTouchHook(); var e = document.createElement("div"); e.style.width = L + "px", e.style.height = L + "px", e.style.position = "absolute", e.style.top = F + "px", e.style.left = N + "px", e.style.zIndex = B.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1) } return Object.defineProperty(t.prototype, "isActive", { get: function () { return this._isActive }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "isMobileAccessibility", { get: function () { return this._isMobileAccessibility }, enumerable: !1, configurable: !0 }), t.prototype.createTouchHook = function () { var t = this, e = document.createElement("button"); e.style.width = U + "px", e.style.height = U + "px", e.style.position = "absolute", e.style.top = k + "px", e.style.left = G + "px", e.style.zIndex = X.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", (function () { t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook() })), document.body.appendChild(e), this._hookDiv = e }, t.prototype.destroyTouchHook = function () { this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null) }, t.prototype.activate = function () { var t; this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), null === (t = this.renderer.view.parentNode) || void 0 === t || t.appendChild(this.div)) }, t.prototype.deactivate = function () { var t; this._isActive && !this._isMobileAccessibility && (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), null === (t = this.div.parentNode) || void 0 === t || t.removeChild(this.div)) }, t.prototype.updateAccessibleObjects = function (t) { if (t.visible && t.accessibleChildren) { t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId); var e = t.children; if (e) for (var r = 0; r < e.length; r++)this.updateAccessibleObjects(e[r]) } }, t.prototype.update = function () { var t = performance.now(); if (!(I.isMobile.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, this.renderer.renderingToScreen)) { this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered); var e = this.renderer.view.getBoundingClientRect(), r = e.left, i = e.top, n = e.width, o = e.height, s = this.renderer, a = s.width, u = s.height, h = s.resolution, l = n / a * h, c = o / u * h, d = this.div; d.style.left = r + "px", d.style.top = i + "px", d.style.width = a + "px", d.style.height = u + "px"; for (var f = 0; f < this.children.length; f++) { var p = this.children[f]; if (p.renderId !== this.renderId) p._accessibleActive = !1, (0, I.removeItems)(this.children, f, 1), this.div.removeChild(p._accessibleDiv), this.pool.push(p._accessibleDiv), p._accessibleDiv = null, f--; else { d = p._accessibleDiv; var _ = p.hitArea, m = p.worldTransform; p.hitArea ? (d.style.left = (m.tx + _.x * m.a) * l + "px", d.style.top = (m.ty + _.y * m.d) * c + "px", d.style.width = _.width * m.a * l + "px", d.style.height = _.height * m.d * c + "px") : (_ = p.getBounds(), this.capHitArea(_), d.style.left = _.x * l + "px", d.style.top = _.y * c + "px", d.style.width = _.width * l + "px", d.style.height = _.height * c + "px", d.title !== p.accessibleTitle && null !== p.accessibleTitle && (d.title = p.accessibleTitle), d.getAttribute("aria-label") !== p.accessibleHint && null !== p.accessibleHint && d.setAttribute("aria-label", p.accessibleHint)), p.accessibleTitle === d.title && p.tabIndex === d.tabIndex || (d.title = p.accessibleTitle, d.tabIndex = p.tabIndex, this.debug && this.updateDebugHTML(d)) } } this.renderId++ } }, t.prototype.updateDebugHTML = function (t) { t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex }, t.prototype.capHitArea = function (t) { t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0); var e = this.renderer, r = e.width, i = e.height; t.x + t.width > r && (t.width = r - t.x), t.y + t.height > i && (t.height = i - t.y) }, t.prototype.addChild = function (t) { var e = this.pool.pop(); e || (e = document.createElement("button"), e.style.width = L + "px", e.style.height = L + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = B.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && null !== t.accessibleTitle ? e.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (e.title = "displayObject " + t.tabIndex), t.accessibleHint && null !== t.accessibleHint && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex }, t.prototype._onClick = function (t) { var e = this.renderer.plugins.interaction, r = t.target.displayObject, i = e.eventData; e.dispatchEvent(r, "click", i), e.dispatchEvent(r, "pointertap", i), e.dispatchEvent(r, "tap", i) }, t.prototype._onFocus = function (t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"); var e = this.renderer.plugins.interaction, r = t.target.displayObject, i = e.eventData; e.dispatchEvent(r, "mouseover", i) }, t.prototype._onFocusOut = function (t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"); var e = this.renderer.plugins.interaction, r = t.target.displayObject, i = e.eventData; e.dispatchEvent(r, "mouseout", i) }, t.prototype._onKeyDown = function (t) { t.keyCode === D && this.activate() }, t.prototype._onMouseMove = function (t) { 0 === t.movementX && 0 === t.movementY || this.deactivate() }, t.prototype.destroy = function () { this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null }, t.extension = { name: "accessibility", type: [M.nw.RendererPlugin, M.nw.CanvasRendererPlugin] }, t }(), H = (r(2087), r(565)), V = r(6565), z = function () { function t() { this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new H.E9, this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0 } return Object.defineProperty(t.prototype, "pointerId", { get: function () { return this.identifier }, enumerable: !1, configurable: !0 }), t.prototype.getLocalPosition = function (t, e, r) { return t.worldTransform.applyInverse(r || this.global, e) }, t.prototype.copyEvent = function (t) { "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button; var e = "buttons" in t && t.buttons; this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0 }, t.prototype.reset = function () { this.isPrimary = !1 }, t }(), Y = function (t, e) { return Y = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, Y(t, e) }; function W(t, e) { function r() { this.constructor = t } Y(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var $ = function () { function t() { this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null } return t.prototype.stopPropagation = function () { this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget }, t.prototype.reset = function () { this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null }, t }(), q = function () { function t(e) { this._pointerId = e, this._flags = t.FLAGS.NONE } return t.prototype._doSet = function (t, e) { this._flags = e ? this._flags | t : this._flags & ~t }, Object.defineProperty(t.prototype, "pointerId", { get: function () { return this._pointerId }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "flags", { get: function () { return this._flags }, set: function (t) { this._flags = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "none", { get: function () { return this._flags === t.FLAGS.NONE }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "over", { get: function () { return 0 !== (this._flags & t.FLAGS.OVER) }, set: function (e) { this._doSet(t.FLAGS.OVER, e) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "rightDown", { get: function () { return 0 !== (this._flags & t.FLAGS.RIGHT_DOWN) }, set: function (e) { this._doSet(t.FLAGS.RIGHT_DOWN, e) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "leftDown", { get: function () { return 0 !== (this._flags & t.FLAGS.LEFT_DOWN) }, set: function (e) { this._doSet(t.FLAGS.LEFT_DOWN, e) }, enumerable: !1, configurable: !0 }), t.FLAGS = Object.freeze({ NONE: 0, OVER: 1, LEFT_DOWN: 2, RIGHT_DOWN: 4 }), t }(), K = function () { function t() { this._tempPoint = new H.E9 } return t.prototype.recursiveFindHit = function (t, e, r, i, n) { var o; if (!e || !e.visible) return !1; var s = t.data.global; n = e.interactive || n; var a = !1, u = n, h = !0; if (e.hitArea) i && (e.worldTransform.applyInverse(s, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? a = !0 : (i = !1, h = !1)), u = !1; else if (e._mask && i) { var l = e._mask.isMaskData ? e._mask.maskObject : e._mask; l && !(null === (o = l.containsPoint) || void 0 === o ? void 0 : o.call(l, s)) && (i = !1) } if (h && e.interactiveChildren && e.children) for (var c = e.children, d = c.length - 1; d >= 0; d--) { var f = c[d], p = this.recursiveFindHit(t, f, r, i, u); if (p) { if (!f.parent) continue; u = !1, p && (t.target && (i = !1), a = !0) } } return n && (i && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(s) && (a = !0), e.interactive && (a && !t.target && (t.target = e), r && r(t, e, !!a))), a }, t.prototype.findHit = function (t, e, r, i) { this.recursiveFindHit(t, e, r, i, !1) }, t }(), Z = { interactive: !1, interactiveChildren: !0, hitArea: null, get buttonMode() { return "pointer" === this.cursor }, set buttonMode(t) { t ? this.cursor = "pointer" : "pointer" === this.cursor && (this.cursor = null) }, cursor: null, get trackedPointers() { return void 0 === this._trackedPointers && (this._trackedPointers = {}), this._trackedPointers }, _trackedPointers: void 0 }; P.s$.mixin(Z); var J = 1, Q = { target: null, data: { global: null } }, tt = function (t) { function e(e, r) { var i = t.call(this) || this; return r = r || {}, i.renderer = e, i.autoPreventDefault = void 0 === r.autoPreventDefault || r.autoPreventDefault, i.interactionFrequency = r.interactionFrequency || 10, i.mouse = new z, i.mouse.identifier = J, i.mouse.global.set(-999999), i.activeInteractionData = {}, i.activeInteractionData[J] = i.mouse, i.interactionDataPool = [], i.eventData = new $, i.interactionDOMElement = null, i.moveWhenInside = !1, i.eventsAdded = !1, i.tickerAdded = !1, i.mouseOverRenderer = !("PointerEvent" in globalThis), i.supportsTouchEvents = "ontouchstart" in globalThis, i.supportsPointerEvents = !!globalThis.PointerEvent, i.onPointerUp = i.onPointerUp.bind(i), i.processPointerUp = i.processPointerUp.bind(i), i.onPointerCancel = i.onPointerCancel.bind(i), i.processPointerCancel = i.processPointerCancel.bind(i), i.onPointerDown = i.onPointerDown.bind(i), i.processPointerDown = i.processPointerDown.bind(i), i.onPointerMove = i.onPointerMove.bind(i), i.processPointerMove = i.processPointerMove.bind(i), i.onPointerOut = i.onPointerOut.bind(i), i.processPointerOverOut = i.processPointerOverOut.bind(i), i.onPointerOver = i.onPointerOver.bind(i), i.cursorStyles = { default: "inherit", pointer: "pointer" }, i.currentCursorMode = null, i.cursor = null, i.resolution = 1, i.delayedEvents = [], i.search = new K, i._tempDisplayObject = new P.Ql, i._eventListenerOptions = { capture: !0, passive: !1 }, i._useSystemTicker = void 0 === r.useSystemTicker || r.useSystemTicker, i.setTargetElement(i.renderer.view, i.renderer.resolution), i } return W(e, t), Object.defineProperty(e.prototype, "useSystemTicker", { get: function () { return this._useSystemTicker }, set: function (t) { this._useSystemTicker = t, t ? this.addTickerListener() : this.removeTickerListener() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "lastObjectRendered", { get: function () { return this.renderer._lastObjectRendered || this._tempDisplayObject }, enumerable: !1, configurable: !0 }), e.prototype.hitTest = function (t, e) { return Q.target = null, Q.data.global = t, e || (e = this.lastObjectRendered), this.processInteractive(Q, e, null, !0), Q.target }, e.prototype.setTargetElement = function (t, e) { void 0 === e && (e = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t, this.resolution = e, this.addEvents(), this.addTickerListener() }, e.prototype.addTickerListener = function () { !this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (V.vB.system.add(this.tickerUpdate, this, V.uF.INTERACTION), this.tickerAdded = !0) }, e.prototype.removeTickerListener = function () { this.tickerAdded && (V.vB.system.remove(this.tickerUpdate, this), this.tickerAdded = !1) }, e.prototype.addEvents = function () { if (!this.eventsAdded && this.interactionDOMElement) { var t = this.interactionDOMElement.style; globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0 } }, e.prototype.removeEvents = function () { if (this.eventsAdded && this.interactionDOMElement) { var t = this.interactionDOMElement.style; globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1 } }, e.prototype.tickerUpdate = function (t) { this._deltaTime += t, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update()) }, e.prototype.update = function () { if (this.interactionDOMElement) if (this._didMove) this._didMove = !1; else { for (var t in this.cursor = null, this.activeInteractionData) if (this.activeInteractionData.hasOwnProperty(t)) { var e = this.activeInteractionData[t]; if (e.originalEvent && "touch" !== e.pointerType) { var r = this.configureInteractionEventForDOMEvent(this.eventData, e.originalEvent, e); this.processInteractive(r, this.lastObjectRendered, this.processPointerOverOut, !0) } } this.setCursorMode(this.cursor) } }, e.prototype.setCursorMode = function (t) { t = t || "default"; var e = !0; if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (e = !1), this.currentCursorMode !== t) { this.currentCursorMode = t; var r = this.cursorStyles[t]; if (r) switch (typeof r) { case "string": e && (this.interactionDOMElement.style.cursor = r); break; case "function": r(t); break; case "object": e && Object.assign(this.interactionDOMElement.style, r); break } else e && "string" === typeof t && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.interactionDOMElement.style.cursor = t) } }, e.prototype.dispatchEvent = function (t, e, r) { r.stopPropagationHint && t !== r.stopsPropagatingAt || (r.currentTarget = t, r.type = e, t.emit(e, r), t[e] && t[e](r)) }, e.prototype.delayDispatchEvent = function (t, e, r) { this.delayedEvents.push({ displayObject: t, eventString: e, eventData: r }) }, e.prototype.mapPositionToPoint = function (t, e, r) { var i; i = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : { x: 0, y: 0, width: this.interactionDOMElement.width, height: this.interactionDOMElement.height, left: 0, top: 0 }; var n = 1 / this.resolution; t.x = (e - i.left) * (this.interactionDOMElement.width / i.width) * n, t.y = (r - i.top) * (this.interactionDOMElement.height / i.height) * n }, e.prototype.processInteractive = function (t, e, r, i) { var n = this.search.findHit(t, e, r, i), o = this.delayedEvents; if (!o.length) return n; t.stopPropagationHint = !1; var s = o.length; this.delayedEvents = []; for (var a = 0; a < s; a++) { var u = o[a], h = u.displayObject, l = u.eventString, c = u.eventData; c.stopsPropagatingAt === h && (c.stopPropagationHint = !0), this.dispatchEvent(h, l, c) } return n }, e.prototype.onPointerDown = function (t) { if (!this.supportsTouchEvents || "touch" !== t.pointerType) { var e = this.normalizeToPointerData(t); if (this.autoPreventDefault && e[0].isNormalized) { var r = t.cancelable || !("cancelable" in t); r && t.preventDefault() } for (var i = e.length, n = 0; n < i; n++) { var o = e[n], s = this.getInteractionDataForPointerId(o), a = this.configureInteractionEventForDOMEvent(this.eventData, o, s); if (a.data.originalEvent = t, this.processInteractive(a, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", a), "touch" === o.pointerType) this.emit("touchstart", a); else if ("mouse" === o.pointerType || "pen" === o.pointerType) { var u = 2 === o.button; this.emit(u ? "rightdown" : "mousedown", this.eventData) } } } }, e.prototype.processPointerDown = function (t, e, r) { var i = t.data, n = t.data.identifier; if (r) if (e.trackedPointers[n] || (e.trackedPointers[n] = new q(n)), this.dispatchEvent(e, "pointerdown", t), "touch" === i.pointerType) this.dispatchEvent(e, "touchstart", t); else if ("mouse" === i.pointerType || "pen" === i.pointerType) { var o = 2 === i.button; o ? e.trackedPointers[n].rightDown = !0 : e.trackedPointers[n].leftDown = !0, this.dispatchEvent(e, o ? "rightdown" : "mousedown", t) } }, e.prototype.onPointerComplete = function (t, e, r) { var i = this.normalizeToPointerData(t), n = i.length, o = t.target; t.composedPath && t.composedPath().length > 0 && (o = t.composedPath()[0]); for (var s = o !== this.interactionDOMElement ? "outside" : "", a = 0; a < n; a++) { var u = i[a], h = this.getInteractionDataForPointerId(u), l = this.configureInteractionEventForDOMEvent(this.eventData, u, h); if (l.data.originalEvent = t, this.processInteractive(l, this.lastObjectRendered, r, e || !s), this.emit(e ? "pointercancel" : "pointerup" + s, l), "mouse" === u.pointerType || "pen" === u.pointerType) { var c = 2 === u.button; this.emit(c ? "rightup" + s : "mouseup" + s, l) } else "touch" === u.pointerType && (this.emit(e ? "touchcancel" : "touchend" + s, l), this.releaseInteractionDataForPointerId(u.pointerId)) } }, e.prototype.onPointerCancel = function (t) { this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !0, this.processPointerCancel) }, e.prototype.processPointerCancel = function (t, e) { var r = t.data, i = t.data.identifier; void 0 !== e.trackedPointers[i] && (delete e.trackedPointers[i], this.dispatchEvent(e, "pointercancel", t), "touch" === r.pointerType && this.dispatchEvent(e, "touchcancel", t)) }, e.prototype.onPointerUp = function (t) { this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !1, this.processPointerUp) }, e.prototype.processPointerUp = function (t, e, r) { var i = t.data, n = t.data.identifier, o = e.trackedPointers[n], s = "touch" === i.pointerType, a = "mouse" === i.pointerType || "pen" === i.pointerType, u = !1; if (a) { var h = 2 === i.button, l = q.FLAGS, c = h ? l.RIGHT_DOWN : l.LEFT_DOWN, d = void 0 !== o && o.flags & c; r ? (this.dispatchEvent(e, h ? "rightup" : "mouseup", t), d && (this.dispatchEvent(e, h ? "rightclick" : "click", t), u = !0)) : d && this.dispatchEvent(e, h ? "rightupoutside" : "mouseupoutside", t), o && (h ? o.rightDown = !1 : o.leftDown = !1) } r ? (this.dispatchEvent(e, "pointerup", t), s && this.dispatchEvent(e, "touchend", t), o && (a && !u || this.dispatchEvent(e, "pointertap", t), s && (this.dispatchEvent(e, "tap", t), o.over = !1))) : o && (this.dispatchEvent(e, "pointerupoutside", t), s && this.dispatchEvent(e, "touchendoutside", t)), o && o.none && delete e.trackedPointers[n] }, e.prototype.onPointerMove = function (t) { if (!this.supportsTouchEvents || "touch" !== t.pointerType) { var e = this.normalizeToPointerData(t); "mouse" !== e[0].pointerType && "pen" !== e[0].pointerType || (this._didMove = !0, this.cursor = null); for (var r = e.length, i = 0; i < r; i++) { var n = e[i], o = this.getInteractionDataForPointerId(n), s = this.configureInteractionEventForDOMEvent(this.eventData, n, o); s.data.originalEvent = t, this.processInteractive(s, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", s), "touch" === n.pointerType && this.emit("touchmove", s), "mouse" !== n.pointerType && "pen" !== n.pointerType || this.emit("mousemove", s) } "mouse" === e[0].pointerType && this.setCursorMode(this.cursor) } }, e.prototype.processPointerMove = function (t, e, r) { var i = t.data, n = "touch" === i.pointerType, o = "mouse" === i.pointerType || "pen" === i.pointerType; o && this.processPointerOverOut(t, e, r), this.moveWhenInside && !r || (this.dispatchEvent(e, "pointermove", t), n && this.dispatchEvent(e, "touchmove", t), o && this.dispatchEvent(e, "mousemove", t)) }, e.prototype.onPointerOut = function (t) { if (!this.supportsTouchEvents || "touch" !== t.pointerType) { var e = this.normalizeToPointerData(t), r = e[0]; "mouse" === r.pointerType && (this.mouseOverRenderer = !1, this.setCursorMode(null)); var i = this.getInteractionDataForPointerId(r), n = this.configureInteractionEventForDOMEvent(this.eventData, r, i); n.data.originalEvent = r, this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", n), "mouse" === r.pointerType || "pen" === r.pointerType ? this.emit("mouseout", n) : this.releaseInteractionDataForPointerId(i.identifier) } }, e.prototype.processPointerOverOut = function (t, e, r) { var i = t.data, n = t.data.identifier, o = "mouse" === i.pointerType || "pen" === i.pointerType, s = e.trackedPointers[n]; r && !s && (s = e.trackedPointers[n] = new q(n)), void 0 !== s && (r && this.mouseOverRenderer ? (s.over || (s.over = !0, this.delayDispatchEvent(e, "pointerover", t), o && this.delayDispatchEvent(e, "mouseover", t)), o && null === this.cursor && (this.cursor = e.cursor)) : s.over && (s.over = !1, this.dispatchEvent(e, "pointerout", this.eventData), o && this.dispatchEvent(e, "mouseout", t), s.none && delete e.trackedPointers[n])) }, e.prototype.onPointerOver = function (t) { if (!this.supportsTouchEvents || "touch" !== t.pointerType) { var e = this.normalizeToPointerData(t), r = e[0], i = this.getInteractionDataForPointerId(r), n = this.configureInteractionEventForDOMEvent(this.eventData, r, i); n.data.originalEvent = r, "mouse" === r.pointerType && (this.mouseOverRenderer = !0), this.emit("pointerover", n), "mouse" !== r.pointerType && "pen" !== r.pointerType || this.emit("mouseover", n) } }, e.prototype.getInteractionDataForPointerId = function (t) { var e, r = t.pointerId; return r === J || "mouse" === t.pointerType ? e = this.mouse : this.activeInteractionData[r] ? e = this.activeInteractionData[r] : (e = this.interactionDataPool.pop() || new z, e.identifier = r, this.activeInteractionData[r] = e), e.copyEvent(t), e }, e.prototype.releaseInteractionDataForPointerId = function (t) { var e = this.activeInteractionData[t]; e && (delete this.activeInteractionData[t], e.reset(), this.interactionDataPool.push(e)) }, e.prototype.configureInteractionEventForDOMEvent = function (t, e, r) { return t.data = r, this.mapPositionToPoint(r.global, e.clientX, e.clientY), "touch" === e.pointerType && (e.globalX = r.global.x, e.globalY = r.global.y), r.originalEvent = e, t.reset(), t }, e.prototype.normalizeToPointerData = function (t) { var e = []; if (this.supportsTouchEvents && t instanceof TouchEvent) for (var r = 0, i = t.changedTouches.length; r < i; r++) { var n = t.changedTouches[r]; "undefined" === typeof n.button && (n.button = t.touches.length ? 1 : 0), "undefined" === typeof n.buttons && (n.buttons = t.touches.length ? 1 : 0), "undefined" === typeof n.isPrimary && (n.isPrimary = 1 === t.touches.length && "touchstart" === t.type), "undefined" === typeof n.width && (n.width = n.radiusX || 1), "undefined" === typeof n.height && (n.height = n.radiusY || 1), "undefined" === typeof n.tiltX && (n.tiltX = 0), "undefined" === typeof n.tiltY && (n.tiltY = 0), "undefined" === typeof n.pointerType && (n.pointerType = "touch"), "undefined" === typeof n.pointerId && (n.pointerId = n.identifier || 0), "undefined" === typeof n.pressure && (n.pressure = n.force || .5), "undefined" === typeof n.twist && (n.twist = 0), "undefined" === typeof n.tangentialPressure && (n.tangentialPressure = 0), "undefined" === typeof n.layerX && (n.layerX = n.offsetX = n.clientX), "undefined" === typeof n.layerY && (n.layerY = n.offsetY = n.clientY), n.isNormalized = !0, e.push(n) } else if (globalThis.MouseEvent && (!(t instanceof MouseEvent) || this.supportsPointerEvents && t instanceof globalThis.PointerEvent)) e.push(t); else { var o = t; "undefined" === typeof o.isPrimary && (o.isPrimary = !0), "undefined" === typeof o.width && (o.width = 1), "undefined" === typeof o.height && (o.height = 1), "undefined" === typeof o.tiltX && (o.tiltX = 0), "undefined" === typeof o.tiltY && (o.tiltY = 0), "undefined" === typeof o.pointerType && (o.pointerType = "mouse"), "undefined" === typeof o.pointerId && (o.pointerId = J), "undefined" === typeof o.pressure && (o.pressure = .5), "undefined" === typeof o.twist && (o.twist = 0), "undefined" === typeof o.tangentialPressure && (o.tangentialPressure = 0), o.isNormalized = !0, e.push(o) } return e }, e.prototype.destroy = function () { this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null }, e.extension = { name: "interaction", type: [M.nw.RendererPlugin, M.nw.CanvasRendererPlugin] }, e }(I.EventEmitter), et = r(8676), rt = new H.Ae, it = 4, nt = function () { function t(t) { this.renderer = t } return t.prototype.image = function (t, e, r) { var i = new Image; return i.src = this.base64(t, e, r), i }, t.prototype.base64 = function (t, e, r) { return this.canvas(t).toDataURL(e, r) }, t.prototype.canvas = function (e, r) { var i = this._rawPixels(e, r), n = i.pixels, o = i.width, s = i.height, a = i.flipY, u = new I.CanvasRenderTarget(o, s, 1), h = u.context.getImageData(0, 0, o, s); if (t.arrayPostDivide(n, h.data), u.context.putImageData(h, 0, 0), a) { var l = new I.CanvasRenderTarget(u.width, u.height, 1); l.context.scale(1, -1), l.context.drawImage(u.canvas, 0, -s), u.destroy(), u = l } return u.canvas }, t.prototype.pixels = function (e, r) { var i = this._rawPixels(e, r).pixels; return t.arrayPostDivide(i, i), i }, t.prototype._rawPixels = function (t, e) { var r, i, n = this.renderer, o = !1, s = !1; if (t) if (t instanceof M.TI) i = t; else { var a = n.context.webGLVersion >= 2 ? n.multisample : et.G5.NONE; if (i = this.renderer.generateTexture(t, { multisample: a }), a !== et.G5.NONE) { var u = M.TI.create({ width: i.width, height: i.height }); n.framebuffer.bind(i.framebuffer), n.framebuffer.blit(u.framebuffer), n.framebuffer.bind(null), i.destroy(!0), i = u } s = !0 } i ? (r = i.baseTexture.resolution, e = null !== e && void 0 !== e ? e : i.frame, o = !1, n.renderTexture.bind(i)) : (r = n.resolution, e || (e = rt, e.width = n.width, e.height = n.height), o = !0, n.renderTexture.bind(null)); var h = Math.round(e.width * r), l = Math.round(e.height * r), c = new Uint8Array(it * h * l), d = n.gl; return d.readPixels(Math.round(e.x * r), Math.round(e.y * r), h, l, d.RGBA, d.UNSIGNED_BYTE, c), s && i.destroy(!0), { pixels: c, width: h, height: l, flipY: o } }, t.prototype.destroy = function () { this.renderer = null }, t.arrayPostDivide = function (t, e) { for (var r = 0; r < t.length; r += 4) { var i = e[r + 3] = t[r + 3]; 0 !== i ? (e[r] = Math.round(Math.min(255 * t[r] / i, 255)), e[r + 1] = Math.round(Math.min(255 * t[r + 1] / i, 255)), e[r + 2] = Math.round(Math.min(255 * t[r + 2] / i, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2]) } }, t.extension = { name: "extract", type: M.nw.RendererPlugin }, t }(), ot = (r(541), function () { function t(t, e, r) { void 0 === e && (e = !1), this._fn = t, this._once = e, this._thisArg = r, this._next = this._prev = this._owner = null } return t.prototype.detach = function () { return null !== this._owner && (this._owner.detach(this), !0) }, t }()); function st(t, e) { return t._head ? (t._tail._next = e, e._prev = t._tail, t._tail = e) : (t._head = e, t._tail = e), e._owner = t, e } var at, ut = function () { function t() { this._head = this._tail = void 0 } return t.prototype.handlers = function (t) { void 0 === t && (t = !1); var e = this._head; if (t) return !!e; var r = []; while (e) r.push(e), e = e._next; return r }, t.prototype.has = function (t) { if (!(t instanceof ot)) throw new Error("MiniSignal#has(): First arg must be a SignalBinding object."); return t._owner === this }, t.prototype.dispatch = function () { for (var t = arguments, e = [], r = 0; r < arguments.length; r++)e[r] = t[r]; var i = this._head; if (!i) return !1; while (i) i._once && this.detach(i), i._fn.apply(i._thisArg, e), i = i._next; return !0 }, t.prototype.add = function (t, e) { if (void 0 === e && (e = null), "function" !== typeof t) throw new Error("MiniSignal#add(): First arg must be a Function."); return st(this, new ot(t, !1, e)) }, t.prototype.once = function (t, e) { if (void 0 === e && (e = null), "function" !== typeof t) throw new Error("MiniSignal#once(): First arg must be a Function."); return st(this, new ot(t, !0, e)) }, t.prototype.detach = function (t) { if (!(t instanceof ot)) throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object."); return t._owner !== this || (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, null === t._next && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null), this }, t.prototype.detachAll = function () { var t = this._head; if (!t) return this; this._head = this._tail = null; while (t) t._owner = null, t = t._next; return this }, t }(); function ht(t, e) { e = e || {}; var r = { key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], q: { name: "queryKey", parser: /(?:^|&)([^&=]*)=?([^&]*)/g }, parser: { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ } }, i = r.parser[e.strictMode ? "strict" : "loose"].exec(t), n = {}, o = 14; while (o--) n[r.key[o]] = i[o] || ""; return n[r.q.name] = {}, n[r.key[12]].replace(r.q.parser, (function (t, e, i) { e && (n[r.q.name][e] = i) })), n } var lt = null, ct = 0, dt = 200, ft = 204, pt = 1223, _t = 2; function mt() { } function gt(t, e, r) { e && 0 === e.indexOf(".") && (e = e.substring(1)), e && (t[e] = r) } function vt(t) { return t.toString().replace("object ", "") } var yt = function () { function t(e, r, i) { if (this._dequeue = mt, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, "string" !== typeof e || "string" !== typeof r) throw new Error("Both name and url are required for constructing a resource."); i = i || {}, this._flags = 0, this._setFlag(t.STATUS_FLAGS.DATA_URL, 0 === r.indexOf("data:")), this.name = e, this.url = r, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === i.crossOrigin ? "anonymous" : i.crossOrigin, this.timeout = i.timeout || 0, this.loadType = i.loadType || this._determineLoadType(), this.xhrType = i.xhrType, this.metadata = i.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = mt, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new ut, this.onProgress = new ut, this.onComplete = new ut, this.onAfterMiddleware = new ut } return t.setExtensionLoadType = function (e, r) { gt(t._loadTypeMap, e, r) }, t.setExtensionXhrType = function (e, r) { gt(t._xhrTypeMap, e, r) }, Object.defineProperty(t.prototype, "isDataUrl", { get: function () { return this._hasFlag(t.STATUS_FLAGS.DATA_URL) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "isComplete", { get: function () { return this._hasFlag(t.STATUS_FLAGS.COMPLETE) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "isLoading", { get: function () { return this._hasFlag(t.STATUS_FLAGS.LOADING) }, enumerable: !1, configurable: !0 }), t.prototype.complete = function () { this._clearEvents(), this._finish() }, t.prototype.abort = function (e) { if (!this.error) { if (this.error = new Error(e), this._clearEvents(), this.xhr) this.xhr.abort(); else if (this.xdr) this.xdr.abort(); else if (this.data) if (this.data.src) this.data.src = t.EMPTY_GIF; else while (this.data.firstChild) this.data.removeChild(this.data.firstChild); this._finish() } }, t.prototype.load = function (e) { var r = this; if (!this.isLoading) if (this.isComplete) e && setTimeout((function () { return e(r) }), 1); else switch (e && this.onComplete.once(e), this._setFlag(t.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && "string" === typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) { case t.LOAD_TYPE.IMAGE: this.type = t.TYPE.IMAGE, this._loadElement("image"); break; case t.LOAD_TYPE.AUDIO: this.type = t.TYPE.AUDIO, this._loadSourceElement("audio"); break; case t.LOAD_TYPE.VIDEO: this.type = t.TYPE.VIDEO, this._loadSourceElement("video"); break; case t.LOAD_TYPE.XHR: default: "undefined" === typeof at && (at = !(!globalThis.XDomainRequest || "withCredentials" in new XMLHttpRequest)), at && this.crossOrigin ? this._loadXdr() : this._loadXhr(); break } }, t.prototype._hasFlag = function (t) { return 0 !== (this._flags & t) }, t.prototype._setFlag = function (t, e) { this._flags = e ? this._flags | t : this._flags & ~t }, t.prototype._clearEvents = function () { clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null)) }, t.prototype._finish = function () { if (this.isComplete) throw new Error("Complete called again for an already completed resource."); this._setFlag(t.STATUS_FLAGS.COMPLETE, !0), this._setFlag(t.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this) }, t.prototype._loadElement = function (t) { this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t && "undefined" !== typeof globalThis.Image ? this.data = new Image : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout)) }, t.prototype._loadSourceElement = function (t) { if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t && "undefined" !== typeof globalThis.Audio ? this.data = new Audio : this.data = document.createElement(t), null !== this.data) { if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource) if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url; else if (Array.isArray(this.url)) for (var e = this.metadata.mimeType, r = 0; r < this.url.length; ++r)this.data.appendChild(this._createSource(t, this.url[r], Array.isArray(e) ? e[r] : e)); else { e = this.metadata.mimeType; this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e)) } this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout)) } else this.abort("Unsupported element: " + t) }, t.prototype._loadXhr = function () { "string" !== typeof this.xhrType && (this.xhrType = this._determineXhrType()); var e = this.xhr = new XMLHttpRequest; "use-credentials" === this.crossOrigin && (e.withCredentials = !0), e.open("GET", this.url, !0), e.timeout = this.timeout, this.xhrType === t.XHR_RESPONSE_TYPE.JSON || this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT ? e.responseType = t.XHR_RESPONSE_TYPE.TEXT : e.responseType = this.xhrType, e.addEventListener("error", this._boundXhrOnError, !1), e.addEventListener("timeout", this._boundXhrOnTimeout, !1), e.addEventListener("abort", this._boundXhrOnAbort, !1), e.addEventListener("progress", this._boundOnProgress, !1), e.addEventListener("load", this._boundXhrOnLoad, !1), e.send() }, t.prototype._loadXdr = function () { "string" !== typeof this.xhrType && (this.xhrType = this._determineXhrType()); var t = this.xhr = new globalThis.XDomainRequest; t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout((function () { return t.send() }), 1) }, t.prototype._createSource = function (t, e, r) { r || (r = t + "/" + this._getExtension(e)); var i = document.createElement("source"); return i.src = e, i.type = r, i }, t.prototype._onError = function (t) { this.abort("Failed to load element using: " + t.target.nodeName) }, t.prototype._onProgress = function (t) { t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total) }, t.prototype._onTimeout = function () { this.abort("Load timed out.") }, t.prototype._xhrOnError = function () { var t = this.xhr; this.abort(vt(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"') }, t.prototype._xhrOnTimeout = function () { var t = this.xhr; this.abort(vt(t) + " Request timed out.") }, t.prototype._xhrOnAbort = function () { var t = this.xhr; this.abort(vt(t) + " Request was aborted by the user.") }, t.prototype._xhrOnLoad = function () { var e = this.xhr, r = "", i = "undefined" === typeof e.status ? dt : e.status; "" !== e.responseType && "text" !== e.responseType && "undefined" !== typeof e.responseType || (r = e.responseText), i === ct && (r.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER) ? i = dt : i === pt && (i = ft); var n = i / 100 | 0; if (n === _t) { if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT) this.data = r, this.type = t.TYPE.TEXT; else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON) try { this.data = JSON.parse(r), this.type = t.TYPE.JSON } catch (a) { return void this.abort("Error trying to parse loaded json: " + a) } else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT) try { if (globalThis.DOMParser) { var o = new DOMParser; this.data = o.parseFromString(r, "text/xml") } else { var s = document.createElement("div"); s.innerHTML = r, this.data = s } this.type = t.TYPE.XML } catch (u) { return void this.abort("Error trying to parse loaded xml: " + u) } else this.data = e.response || r; this.complete() } else this.abort("[" + e.status + "] " + e.statusText + ": " + e.responseURL) }, t.prototype._determineCrossOrigin = function (t, e) { if (0 === t.indexOf("data:")) return ""; if (globalThis.origin !== globalThis.location.origin) return "anonymous"; e = e || globalThis.location, lt || (lt = document.createElement("a")), lt.href = t; var r = ht(lt.href, { strictMode: !0 }), i = !r.port && "" === e.port || r.port === e.port, n = r.protocol ? r.protocol + ":" : ""; return r.host === e.hostname && i && n === e.protocol ? "" : "anonymous" }, t.prototype._determineXhrType = function () { return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT }, t.prototype._determineLoadType = function () { return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR }, t.prototype._getExtension = function (t) { void 0 === t && (t = this.url); var e = ""; if (this.isDataUrl) { var r = t.indexOf("/"); e = t.substring(r + 1, t.indexOf(";", r)) } else { var i = t.indexOf("?"), n = t.indexOf("#"), o = Math.min(i > -1 ? i : t.length, n > -1 ? n : t.length); t = t.substring(0, o), e = t.substring(t.lastIndexOf(".") + 1) } return e.toLowerCase() }, t.prototype._getMimeFromXhrType = function (e) { switch (e) { case t.XHR_RESPONSE_TYPE.BUFFER: return "application/octet-binary"; case t.XHR_RESPONSE_TYPE.BLOB: return "application/blob"; case t.XHR_RESPONSE_TYPE.DOCUMENT: return "application/xml"; case t.XHR_RESPONSE_TYPE.JSON: return "application/json"; case t.XHR_RESPONSE_TYPE.DEFAULT: case t.XHR_RESPONSE_TYPE.TEXT: default: return "text/plain" } }, t }(); function bt() { } function xt(t) { return function () { for (var e = arguments, r = [], i = 0; i < arguments.length; i++)r[i] = e[i]; if (null === t) throw new Error("Callback was already called."); var n = t; t = null, n.apply(this, r) } } (function (t) { (function (t) { t[t["NONE"] = 0] = "NONE", t[t["DATA_URL"] = 1] = "DATA_URL", t[t["COMPLETE"] = 2] = "COMPLETE", t[t["LOADING"] = 4] = "LOADING" })(t.STATUS_FLAGS || (t.STATUS_FLAGS = {})), function (t) { t[t["UNKNOWN"] = 0] = "UNKNOWN", t[t["JSON"] = 1] = "JSON", t[t["XML"] = 2] = "XML", t[t["IMAGE"] = 3] = "IMAGE", t[t["AUDIO"] = 4] = "AUDIO", t[t["VIDEO"] = 5] = "VIDEO", t[t["TEXT"] = 6] = "TEXT" }(t.TYPE || (t.TYPE = {})), function (t) { t[t["XHR"] = 1] = "XHR", t[t["IMAGE"] = 2] = "IMAGE", t[t["AUDIO"] = 3] = "AUDIO", t[t["VIDEO"] = 4] = "VIDEO" }(t.LOAD_TYPE || (t.LOAD_TYPE = {})), function (t) { t["DEFAULT"] = "text", t["BUFFER"] = "arraybuffer", t["BLOB"] = "blob", t["DOCUMENT"] = "document", t["JSON"] = "json", t["TEXT"] = "text" }(t.XHR_RESPONSE_TYPE || (t.XHR_RESPONSE_TYPE = {})), t._loadTypeMap = { gif: t.LOAD_TYPE.IMAGE, png: t.LOAD_TYPE.IMAGE, bmp: t.LOAD_TYPE.IMAGE, jpg: t.LOAD_TYPE.IMAGE, jpeg: t.LOAD_TYPE.IMAGE, tif: t.LOAD_TYPE.IMAGE, tiff: t.LOAD_TYPE.IMAGE, webp: t.LOAD_TYPE.IMAGE, tga: t.LOAD_TYPE.IMAGE, avif: t.LOAD_TYPE.IMAGE, svg: t.LOAD_TYPE.IMAGE, "svg+xml": t.LOAD_TYPE.IMAGE, mp3: t.LOAD_TYPE.AUDIO, ogg: t.LOAD_TYPE.AUDIO, wav: t.LOAD_TYPE.AUDIO, mp4: t.LOAD_TYPE.VIDEO, webm: t.LOAD_TYPE.VIDEO }, t._xhrTypeMap = { xhtml: t.XHR_RESPONSE_TYPE.DOCUMENT, html: t.XHR_RESPONSE_TYPE.DOCUMENT, htm: t.XHR_RESPONSE_TYPE.DOCUMENT, xml: t.XHR_RESPONSE_TYPE.DOCUMENT, tmx: t.XHR_RESPONSE_TYPE.DOCUMENT, svg: t.XHR_RESPONSE_TYPE.DOCUMENT, tsx: t.XHR_RESPONSE_TYPE.DOCUMENT, gif: t.XHR_RESPONSE_TYPE.BLOB, png: t.XHR_RESPONSE_TYPE.BLOB, bmp: t.XHR_RESPONSE_TYPE.BLOB, jpg: t.XHR_RESPONSE_TYPE.BLOB, jpeg: t.XHR_RESPONSE_TYPE.BLOB, tif: t.XHR_RESPONSE_TYPE.BLOB, tiff: t.XHR_RESPONSE_TYPE.BLOB, webp: t.XHR_RESPONSE_TYPE.BLOB, tga: t.XHR_RESPONSE_TYPE.BLOB, avif: t.XHR_RESPONSE_TYPE.BLOB, json: t.XHR_RESPONSE_TYPE.JSON, text: t.XHR_RESPONSE_TYPE.TEXT, txt: t.XHR_RESPONSE_TYPE.TEXT, ttf: t.XHR_RESPONSE_TYPE.BUFFER, otf: t.XHR_RESPONSE_TYPE.BUFFER }, t.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" })(yt || (yt = {})); var Tt = function () { function t(t, e) { this.data = t, this.callback = e } return t }(), Et = function () { function t(t, e) { var r = this; if (void 0 === e && (e = 1), this.workers = 0, this.saturated = bt, this.unsaturated = bt, this.empty = bt, this.drain = bt, this.error = bt, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function (t, e, i) { if (i && "function" !== typeof i) throw new Error("task callback must be a function"); if (r.started = !0, null == t && r.idle()) setTimeout((function () { return r.drain() }), 1); else { var n = new Tt(t, "function" === typeof i ? i : bt); e ? r._tasks.unshift(n) : r._tasks.push(n), setTimeout(r.process, 1) } }, this.process = function () { while (!r.paused && r.workers < r.concurrency && r._tasks.length) { var t = r._tasks.shift(); 0 === r._tasks.length && r.empty(), r.workers += 1, r.workers === r.concurrency && r.saturated(), r._worker(t.data, xt(r._next(t))) } }, this._worker = t, 0 === e) throw new Error("Concurrency must not be zero"); this.concurrency = e, this.buffer = e / 4 } return t.prototype._next = function (t) { var e = this; return function () { for (var r = arguments, i = [], n = 0; n < arguments.length; n++)i[n] = r[n]; e.workers -= 1, t.callback.apply(t, i), null != i[0] && e.error(i[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process() } }, t.prototype.push = function (t, e) { this._insert(t, !1, e) }, t.prototype.kill = function () { this.workers = 0, this.drain = bt, this.started = !1, this._tasks = [] }, t.prototype.unshift = function (t, e) { this._insert(t, !0, e) }, t.prototype.length = function () { return this._tasks.length }, t.prototype.running = function () { return this.workers }, t.prototype.idle = function () { return this._tasks.length + this.workers === 0 }, t.prototype.pause = function () { !0 !== this.paused && (this.paused = !0) }, t.prototype.resume = function () { if (!1 !== this.paused) { this.paused = !1; for (var t = 1; t <= this.concurrency; t++)this.process() } }, t.eachSeries = function (t, e, r, i) { var n = 0, o = t.length; function s(a) { a || n === o ? r && r(a) : i ? setTimeout((function () { e(t[n++], s) }), 1) : e(t[n++], s) } s() }, t.queue = function (e, r) { return new t(e, r) }, t }(), St = 100, wt = /(#[\w-]+)?$/, At = function () { function t(e, r) { var i = this; void 0 === e && (e = ""), void 0 === r && (r = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function (t, e) { return i._loadResource(t, e) }, this.resources = {}, this.baseUrl = e, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function (t, e) { return i._loadResource(t, e) }, this._queue = Et.queue(this._boundLoadResource, r), this._queue.pause(), this.resources = {}, this.onProgress = new ut, this.onError = new ut, this.onLoad = new ut, this.onStart = new ut, this.onComplete = new ut; for (var n = 0; n < t._plugins.length; ++n) { var o = t._plugins[n], s = o.pre, a = o.use; s && this.pre(s), a && this.use(a) } this._protected = !1 } return t.prototype._add = function (t, e, r, i) { if (this.loading && (!r || !r.parentResource)) throw new Error("Cannot add resources while the loader is running."); if (this.resources[t]) throw new Error('Resource named "' + t + '" already exists.'); if (e = this._prepareUrl(e), this.resources[t] = new yt(t, e, r), "function" === typeof i && this.resources[t].onAfterMiddleware.once(i), this.loading) { for (var n = r.parentResource, o = [], s = 0; s < n.children.length; ++s)n.children[s].isComplete || o.push(n.children[s]); var a = n.progressChunk * (o.length + 1), u = a / (o.length + 2); n.children.push(this.resources[t]), n.progressChunk = u; for (s = 0; s < o.length; ++s)o[s].progressChunk = u; this.resources[t].progressChunk = u } return this._queue.push(this.resources[t]), this }, t.prototype.pre = function (t) { return this._beforeMiddleware.push(t), this }, t.prototype.use = function (t) { return this._afterMiddleware.push(t), this }, t.prototype.reset = function () { for (var t in this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause(), this.resources) { var e = this.resources[t]; e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort("loader reset") } return this.resources = {}, this }, t.prototype.load = function (t) { if ((0, I.deprecation)("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release."), "function" === typeof t && this.onComplete.once(t), this.loading) return this; if (this._queue.idle()) this._onStart(), this._onComplete(); else { for (var e = this._queue._tasks.length, r = St / e, i = 0; i < this._queue._tasks.length; ++i)this._queue._tasks[i].data.progressChunk = r; this._onStart(), this._queue.resume() } return this }, Object.defineProperty(t.prototype, "concurrency", { get: function () { return this._queue.concurrency }, set: function (t) { this._queue.concurrency = t }, enumerable: !1, configurable: !0 }), t.prototype._prepareUrl = function (t) { var e, r = ht(t, { strictMode: !0 }); if (e = r.protocol || !r.path || 0 === t.indexOf("//") ? t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t.charAt(0) ? this.baseUrl + "/" + t : this.baseUrl + t, this.defaultQueryString) { var i = wt.exec(e)[0]; e = e.slice(0, e.length - i.length), -1 !== e.indexOf("?") ? e += "&" + this.defaultQueryString : e += "?" + this.defaultQueryString, e += i } return e }, t.prototype._loadResource = function (t, e) { var r = this; t._dequeue = e, Et.eachSeries(this._beforeMiddleware, (function (e, i) { e.call(r, t, (function () { i(t.isComplete ? {} : null) })) }), (function () { t.isComplete ? r._onLoad(t) : (t._onLoadBinding = t.onComplete.once(r._onLoad, r), t.load()) }), !0) }, t.prototype._onStart = function () { this.progress = 0, this.loading = !0, this.onStart.dispatch(this) }, t.prototype._onComplete = function () { this.progress = St, this.loading = !1, this.onComplete.dispatch(this, this.resources) }, t.prototype._onLoad = function (t) { var e = this; t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), Et.eachSeries(this._afterMiddleware, (function (r, i) { r.call(e, t, i) }), (function () { t.onAfterMiddleware.dispatch(t), e.progress = Math.min(St, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && 0 === e._resourcesParsing.length && e._onComplete() }), !0) }, t.prototype.destroy = function () { this._protected || this.reset() }, Object.defineProperty(t, "shared", { get: function () { var e = t._shared; return e || (e = new t, e._protected = !0, t._shared = e), e }, enumerable: !1, configurable: !0 }), t.registerPlugin = function (e) { return (0, I.deprecation)("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead."), M.Rw.add({ type: M.nw.Loader, ref: e }), t }, t._plugins = [], t }(); M.Rw.handleByList(M.nw.Loader, At._plugins), At.prototype.add = function (t, e, r, i) { if (Array.isArray(t)) { for (var n = 0; n < t.length; ++n)this.add(t[n]); return this } if ("object" === typeof t && (r = t, i = e || r.callback || r.onComplete, e = r.url, t = r.name || r.key || r.url), "string" !== typeof e && (i = r, r = e, e = t), "string" !== typeof e) throw new Error("No url passed to add resource to loader."); return "function" === typeof r && (i = r, r = null), this._add(t, e, r, i) }; var Rt = function () { function t() { } return t.init = function (t) { t = Object.assign({ sharedLoader: !1 }, t), this.loader = t.sharedLoader ? At.shared : new At }, t.destroy = function () { this.loader && (this.loader.destroy(), this.loader = null) }, t.extension = M.nw.Application, t }(), Ot = function () { function t() { } return t.add = function () { yt.setExtensionLoadType("svg", yt.LOAD_TYPE.XHR), yt.setExtensionXhrType("svg", yt.XHR_RESPONSE_TYPE.TEXT) }, t.use = function (t, e) { if (!t.data || t.type !== yt.TYPE.IMAGE && "svg" !== t.extension) e(); else { var r = t.data, i = t.url, n = t.name, o = t.metadata; M.xE.fromLoader(r, i, n, o).then((function (r) { t.texture = r, e() })).catch(e) } }, t.extension = M.nw.Loader, t }(), It = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; function Pt(t) { var e = "", r = 0; while (r < t.length) { for (var i = [0, 0, 0], n = [0, 0, 0, 0], o = 0; o < i.length; ++o)r < t.length ? i[o] = 255 & t.charCodeAt(r++) : i[o] = 0; n[0] = i[0] >> 2, n[1] = (3 & i[0]) << 4 | i[1] >> 4, n[2] = (15 & i[1]) << 2 | i[2] >> 6, n[3] = 63 & i[2]; var s = r - (t.length - 1); switch (s) { case 2: n[3] = 64, n[2] = 64; break; case 1: n[3] = 64; break }for (o = 0; o < n.length; ++o)e += It.charAt(n[o]) } return e } function Mt(t, e) { if (t.data) { if (t.xhr && t.xhrType === yt.XHR_RESPONSE_TYPE.BLOB) if (self.Blob && "string" !== typeof t.data) { if (0 === t.data.type.indexOf("image")) { var r = globalThis.URL || globalThis.webkitURL, i = r.createObjectURL(t.data); return t.blob = t.data, t.data = new Image, t.data.src = i, t.type = yt.TYPE.IMAGE, void (t.data.onload = function () { r.revokeObjectURL(i), t.data.onload = null, e() }) } } else { var n = t.xhr.getResponseHeader("content-type"); if (n && 0 === n.indexOf("image")) return t.data = new Image, t.data.src = "data:" + n + ";base64," + Pt(t.xhr.responseText), t.type = yt.TYPE.IMAGE, void (t.data.onload = function () { t.data.onload = null, e() }) } e() } else e() } var Ct = function () { function t() { } return t.extension = M.nw.Loader, t.use = Mt, t }(); M.Rw.add(Ot, Ct); var Dt, Lt, Ft = r(950); (function (t) { t[t["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t[t["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t[t["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t[t["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t[t["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t[t["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t[t["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t[t["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t[t["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC", t[t["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC", t[t["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC", t[t["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t[t["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2", t[t["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", t[t["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2", t[t["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t[t["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t[t["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t[t["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t[t["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t[t["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t[t["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t[t["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t[t["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", t[t["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR" })(Lt || (Lt = {})); var Nt = (Dt = {}, Dt[Lt.COMPRESSED_RGB_S3TC_DXT1_EXT] = .5, Dt[Lt.COMPRESSED_RGBA_S3TC_DXT1_EXT] = .5, Dt[Lt.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, Dt[Lt.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, Dt[Lt.COMPRESSED_SRGB_S3TC_DXT1_EXT] = .5, Dt[Lt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = .5, Dt[Lt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, Dt[Lt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, Dt[Lt.COMPRESSED_R11_EAC] = .5, Dt[Lt.COMPRESSED_SIGNED_R11_EAC] = .5, Dt[Lt.COMPRESSED_RG11_EAC] = 1, Dt[Lt.COMPRESSED_SIGNED_RG11_EAC] = 1, Dt[Lt.COMPRESSED_RGB8_ETC2] = .5, Dt[Lt.COMPRESSED_RGBA8_ETC2_EAC] = 1, Dt[Lt.COMPRESSED_SRGB8_ETC2] = .5, Dt[Lt.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, Dt[Lt.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = .5, Dt[Lt.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = .5, Dt[Lt.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = .5, Dt[Lt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = .5, Dt[Lt.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = .25, Dt[Lt.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = .25, Dt[Lt.COMPRESSED_RGB_ETC1_WEBGL] = .5, Dt[Lt.COMPRESSED_RGB_ATC_WEBGL] = .5, Dt[Lt.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, Dt[Lt.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, Dt[Lt.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, Dt), Bt = function (t, e) { return Bt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, Bt(t, e) };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function Ut(t, e) { function r() { this.constructor = t } Bt(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } function kt(t, e, r, i) { function n(t) { return t instanceof r ? t : new r((function (e) { e(t) })) } return new (r || (r = Promise))((function (r, o) { function s(t) { try { u(i.next(t)) } catch (e) { o(e) } } function a(t) { try { u(i["throw"](t)) } catch (e) { o(e) } } function u(t) { t.done ? r(t.value) : n(t.value).then(s, a) } u((i = i.apply(t, e || [])).next()) })) } function Gt(t, e) { var r, i, n, o, s = { label: 0, sent: function () { if (1 & n[0]) throw n[1]; return n[1] }, trys: [], ops: [] }; return o = { next: a(0), throw: a(1), return: a(2) }, "function" === typeof Symbol && (o[Symbol.iterator] = function () { return this }), o; function a(t) { return function (e) { return u([t, e]) } } function u(o) { if (r) throw new TypeError("Generator is already executing."); while (s) try { if (r = 1, i && (n = 2 & o[0] ? i["return"] : o[0] ? i["throw"] || ((n = i["return"]) && n.call(i), 0) : i.next) && !(n = n.call(i, o[1])).done) return n; switch (i = 0, n && (o = [2 & o[0], n.value]), o[0]) { case 0: case 1: n = o; break; case 4: return s.label++, { value: o[1], done: !1 }; case 5: s.label++, i = o[1], o = [0]; continue; case 7: o = s.ops.pop(), s.trys.pop(); continue; default: if (n = s.trys, !(n = n.length > 0 && n[n.length - 1]) && (6 === o[0] || 2 === o[0])) { s = 0; continue } if (3 === o[0] && (!n || o[1] > n[0] && o[1] < n[3])) { s.label = o[1]; break } if (6 === o[0] && s.label < n[1]) { s.label = n[1], n = o; break } if (n && s.label < n[2]) { s.label = n[2], s.ops.push(o); break } n[2] && s.ops.pop(), s.trys.pop(); continue }o = e.call(t, s) } catch (a) { o = [6, a], i = 0 } finally { r = n = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } } } var Xt, jt, Ht = function (t) { function e(e, r) { void 0 === r && (r = { width: 1, height: 1, autoLoad: !0 }); var i, n, o = this; return "string" === typeof e ? (i = e, n = new Uint8Array) : (i = null, n = e), o = t.call(this, n, r) || this, o.origin = i, o.buffer = n ? new M.Rv(n) : null, o.origin && !1 !== r.autoLoad && o.load(), n && n.length && (o.loaded = !0, o.onBlobLoaded(o.buffer.rawBinaryData)), o } return Ut(e, t), e.prototype.onBlobLoaded = function (t) { }, e.prototype.load = function () { return kt(this, void 0, Promise, (function () { var t, e, r; return Gt(this, (function (i) { switch (i.label) { case 0: return [4, fetch(this.origin)]; case 1: return t = i.sent(), [4, t.blob()]; case 2: return e = i.sent(), [4, e.arrayBuffer()]; case 3: return r = i.sent(), this.data = new Uint32Array(r), this.buffer = new M.Rv(r), this.loaded = !0, this.onBlobLoaded(r), this.update(), [2, this] } })) })) }, e }(M.qm), Vt = function (t) { function e(r, i) { var n = t.call(this, r, i) || this; return n.format = i.format, n.levels = i.levels || 1, n._width = i.width, n._height = i.height, n._extension = e._formatToExtension(n.format), (i.levelBuffers || n.buffer) && (n._levelBuffers = i.levelBuffers || e._createLevelBuffers(r instanceof Uint8Array ? r : n.buffer.uint8View, n.format, n.levels, 4, 4, n.width, n.height)), n } return Ut(e, t), e.prototype.upload = function (t, e, r) { var i = t.gl, n = t.context.extensions[this._extension]; if (!n) throw new Error(this._extension + " textures are not supported on the current machine"); if (!this._levelBuffers) return !1; for (var o = 0, s = this.levels; o < s; o++) { var a = this._levelBuffers[o], u = a.levelID, h = a.levelWidth, l = a.levelHeight, c = a.levelBuffer; i.compressedTexImage2D(i.TEXTURE_2D, u, this.format, h, l, 0, c) } return !0 }, e.prototype.onBlobLoaded = function () { this._levelBuffers = e._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height) }, e._formatToExtension = function (t) { if (t >= 33776 && t <= 33779) return "s3tc"; if (t >= 37488 && t <= 37497) return "etc"; if (t >= 35840 && t <= 35843) return "pvrtc"; if (t >= 36196) return "etc1"; if (t >= 35986 && t <= 34798) return "atc"; throw new Error("Invalid (compressed) texture format given!") }, e._createLevelBuffers = function (t, e, r, i, n, o, s) { for (var a = new Array(r), u = t.byteOffset, h = o, l = s, c = h + i - 1 & ~(i - 1), d = l + n - 1 & ~(n - 1), f = c * d * Nt[e], p = 0; p < r; p++)a[p] = { levelID: p, levelWidth: r > 1 ? h : c, levelHeight: r > 1 ? l : d, levelBuffer: new Uint8Array(t.buffer, u, f) }, u += f, h = h >> 1 || 1, l = l >> 1 || 1, c = h + i - 1 & ~(i - 1), d = l + n - 1 & ~(n - 1), f = c * d * Nt[e]; return a }, e }(Ht), zt = function () { function t() { } return t.use = function (e, r) { var i = e.data, n = this; if (e.type === yt.TYPE.JSON && i && i.cacheID && i.textures) { for (var o = i.textures, s = void 0, a = void 0, u = 0, h = o.length; u < h; u++) { var l = o[u], c = l.src, d = l.format; if (d || (a = c), t.textureFormats[d]) { s = c; break } } if (s = s || a, !s) return void r(new Error("Cannot load compressed-textures in " + e.url + ", make sure you provide a fallback")); if (s === e.url) return void r(new Error("URL of compressed texture cannot be the same as the manifest's URL")); var f = { crossOrigin: e.crossOrigin, metadata: e.metadata.imageMetadata, parentResource: e }, p = I.url.resolve(e.url.replace(n.baseUrl, ""), s), _ = i.cacheID; n.add(_, p, f, (function (t) { if (t.error) r(t.error); else { var i = t.texture, n = void 0 === i ? null : i, o = t.textures, s = void 0 === o ? {} : o; Object.assign(e, { texture: n, textures: s }), r() } })) } else r() }, Object.defineProperty(t, "textureExtensions", { get: function () { if (!t._textureExtensions) { var e = Ft.Xd.ADAPTER.createCanvas(), r = e.getContext("webgl"); if (!r) return console.warn("WebGL not available for compressed textures. Silently failing."), {}; var i = { s3tc: r.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: r.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: r.getExtension("WEBGL_compressed_texture_etc"), etc1: r.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: r.getExtension("WEBGL_compressed_texture_atc"), astc: r.getExtension("WEBGL_compressed_texture_astc") }; t._textureExtensions = i } return t._textureExtensions }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "textureFormats", { get: function () { if (!t._textureFormats) { var e = t.textureExtensions; for (var r in t._textureFormats = {}, e) { var i = e[r]; i && Object.assign(t._textureFormats, Object.getPrototypeOf(i)) } } return t._textureFormats }, enumerable: !1, configurable: !0 }), t.extension = M.nw.Loader, t }(); function Yt(t, e, r) { var i = { textures: {}, texture: null }; if (!e) return i; var n = e.map((function (t) { return new M.xE(new M.VL(t, Object.assign({ mipmap: et.WB.OFF, alphaMode: et.iw.NO_PREMULTIPLIED_ALPHA }, r))) })); return n.forEach((function (e, r) { var n = e.baseTexture, o = t + "-" + (r + 1); M.VL.addToCache(n, o), M.xE.addToCache(e, o), 0 === r && (M.VL.addToCache(n, t), M.xE.addToCache(e, t), i.texture = e), i.textures[o] = e })), i } var Wt, $t, qt = 4, Kt = 124, Zt = 32, Jt = 20, Qt = 542327876, te = { SIZE: 1, FLAGS: 2, HEIGHT: 3, WIDTH: 4, MIPMAP_COUNT: 7, PIXEL_FORMAT: 19 }, ee = { SIZE: 0, FLAGS: 1, FOURCC: 2, RGB_BITCOUNT: 3, R_BIT_MASK: 4, G_BIT_MASK: 5, B_BIT_MASK: 6, A_BIT_MASK: 7 }, re = { DXGI_FORMAT: 0, RESOURCE_DIMENSION: 1, MISC_FLAG: 2, ARRAY_SIZE: 3, MISC_FLAGS2: 4 }; (function (t) { t[t["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN", t[t["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", t[t["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", t[t["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", t[t["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", t[t["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", t[t["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", t[t["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT", t[t["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT", t[t["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", t[t["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", t[t["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", t[t["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", t[t["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", t[t["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", t[t["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS", t[t["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT", t[t["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT", t[t["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT", t[t["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", t[t["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", t[t["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", t[t["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", t[t["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", t[t["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", t[t["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", t[t["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", t[t["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", t[t["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", t[t["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", t[t["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", t[t["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", t[t["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", t[t["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS", t[t["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT", t[t["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM", t[t["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT", t[t["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM", t[t["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT", t[t["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS", t[t["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT", t[t["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT", t[t["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT", t[t["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT", t[t["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS", t[t["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", t[t["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", t[t["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", t[t["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS", t[t["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM", t[t["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT", t[t["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM", t[t["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT", t[t["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS", t[t["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT", t[t["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM", t[t["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM", t[t["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT", t[t["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM", t[t["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT", t[t["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS", t[t["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM", t[t["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT", t[t["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM", t[t["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT", t[t["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM", t[t["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM", t[t["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", t[t["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", t[t["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", t[t["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS", t[t["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM", t[t["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", t[t["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS", t[t["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM", t[t["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", t[t["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS", t[t["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM", t[t["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", t[t["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS", t[t["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM", t[t["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM", t[t["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS", t[t["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM", t[t["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM", t[t["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM", t[t["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", t[t["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", t[t["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", t[t["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", t[t["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", t[t["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", t[t["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", t[t["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", t[t["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS", t[t["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16", t[t["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16", t[t["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS", t[t["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM", t[t["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", t[t["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV", t[t["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410", t[t["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416", t[t["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12", t[t["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010", t[t["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016", t[t["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE", t[t["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2", t[t["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210", t[t["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216", t[t["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11", t[t["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44", t[t["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44", t[t["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8", t[t["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8", t[t["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", t[t["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208", t[t["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208", t[t["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408", t[t["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", t[t["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", t[t["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT" })(Wt || (Wt = {})), function (t) { t[t["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D", t[t["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D", t[t["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D" }($t || ($t = {})); var ie, ne, oe, se = 1, ae = 2, ue = 4, he = 64, le = 512, ce = 131072, de = 827611204, fe = 861165636, pe = 894720068, _e = 808540228, me = 4, ge = (Xt = {}, Xt[de] = Lt.COMPRESSED_RGBA_S3TC_DXT1_EXT, Xt[fe] = Lt.COMPRESSED_RGBA_S3TC_DXT3_EXT, Xt[pe] = Lt.COMPRESSED_RGBA_S3TC_DXT5_EXT, Xt), ve = (jt = {}, jt[Wt.DXGI_FORMAT_BC1_TYPELESS] = Lt.COMPRESSED_RGBA_S3TC_DXT1_EXT, jt[Wt.DXGI_FORMAT_BC1_UNORM] = Lt.COMPRESSED_RGBA_S3TC_DXT1_EXT, jt[Wt.DXGI_FORMAT_BC2_TYPELESS] = Lt.COMPRESSED_RGBA_S3TC_DXT3_EXT, jt[Wt.DXGI_FORMAT_BC2_UNORM] = Lt.COMPRESSED_RGBA_S3TC_DXT3_EXT, jt[Wt.DXGI_FORMAT_BC3_TYPELESS] = Lt.COMPRESSED_RGBA_S3TC_DXT5_EXT, jt[Wt.DXGI_FORMAT_BC3_UNORM] = Lt.COMPRESSED_RGBA_S3TC_DXT5_EXT, jt[Wt.DXGI_FORMAT_BC1_UNORM_SRGB] = Lt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, jt[Wt.DXGI_FORMAT_BC2_UNORM_SRGB] = Lt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, jt[Wt.DXGI_FORMAT_BC3_UNORM_SRGB] = Lt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, jt); function ye(t) { var e = new Uint32Array(t), r = e[0]; if (r !== Qt) throw new Error("Invalid DDS file magic word"); var i = new Uint32Array(t, 0, Kt / Uint32Array.BYTES_PER_ELEMENT), n = i[te.HEIGHT], o = i[te.WIDTH], s = i[te.MIPMAP_COUNT], a = new Uint32Array(t, te.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, Zt / Uint32Array.BYTES_PER_ELEMENT), u = a[se]; if (u & ue) { var h = a[ee.FOURCC]; if (h !== _e) { var l = ge[h], c = qt + Kt, d = new Uint8Array(t, c), f = new Vt(d, { format: l, width: o, height: n, levels: s }); return [f] } var p = qt + Kt, _ = new Uint32Array(e.buffer, p, Jt / Uint32Array.BYTES_PER_ELEMENT), m = _[re.DXGI_FORMAT], g = _[re.RESOURCE_DIMENSION], v = _[re.MISC_FLAG], y = _[re.ARRAY_SIZE], b = ve[m]; if (void 0 === b) throw new Error("DDSParser cannot parse texture data with DXGI format " + m); if (v === me) throw new Error("DDSParser does not support cubemap textures"); if (g === $t.DDS_DIMENSION_TEXTURE3D) throw new Error("DDSParser does not supported 3D texture data"); var x = new Array, T = qt + Kt + Jt; if (1 === y) x.push(new Uint8Array(t, T)); else { for (var E = Nt[b], S = 0, w = o, A = n, R = 0; R < s; R++) { var O = Math.max(1, w + 3 & -4), I = Math.max(1, A + 3 & -4), P = O * I * E; S += P, w >>>= 1, A >>>= 1 } var M = T; for (R = 0; R < y; R++)x.push(new Uint8Array(t, M, S)), M += S } return x.map((function (t) { return new Vt(t, { format: b, width: o, height: n, levels: s }) })) } if (u & he) throw new Error("DDSParser does not support uncompressed texture data."); if (u & le) throw new Error("DDSParser does not supported YUV uncompressed texture data."); if (u & ce) throw new Error("DDSParser does not support single-channel (lumninance) texture data!"); if (u & ae) throw new Error("DDSParser does not support single-channel (alpha) texture data!"); throw new Error("DDSParser failed to load a texture file due to an unknown reason!") } var be = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], xe = 67305985, Te = { FILE_IDENTIFIER: 0, ENDIANNESS: 12, GL_TYPE: 16, GL_TYPE_SIZE: 20, GL_FORMAT: 24, GL_INTERNAL_FORMAT: 28, GL_BASE_INTERNAL_FORMAT: 32, PIXEL_WIDTH: 36, PIXEL_HEIGHT: 40, PIXEL_DEPTH: 44, NUMBER_OF_ARRAY_ELEMENTS: 48, NUMBER_OF_FACES: 52, NUMBER_OF_MIPMAP_LEVELS: 56, BYTES_OF_KEY_VALUE_DATA: 60 }, Ee = 64, Se = (ie = {}, ie[et.vK.UNSIGNED_BYTE] = 1, ie[et.vK.UNSIGNED_SHORT] = 2, ie[et.vK.INT] = 4, ie[et.vK.UNSIGNED_INT] = 4, ie[et.vK.FLOAT] = 4, ie[et.vK.HALF_FLOAT] = 8, ie), we = (ne = {}, ne[et.I2.RGBA] = 4, ne[et.I2.RGB] = 3, ne[et.I2.RG] = 2, ne[et.I2.RED] = 1, ne[et.I2.LUMINANCE] = 1, ne[et.I2.LUMINANCE_ALPHA] = 2, ne[et.I2.ALPHA] = 1, ne), Ae = (oe = {}, oe[et.vK.UNSIGNED_SHORT_4_4_4_4] = 2, oe[et.vK.UNSIGNED_SHORT_5_5_5_1] = 2, oe[et.vK.UNSIGNED_SHORT_5_6_5] = 2, oe); function Re(t, e, r) { void 0 === r && (r = !1); var i = new DataView(e); if (!Oe(t, i)) return null; var n = i.getUint32(Te.ENDIANNESS, !0) === xe, o = i.getUint32(Te.GL_TYPE, n), s = i.getUint32(Te.GL_FORMAT, n), a = i.getUint32(Te.GL_INTERNAL_FORMAT, n), u = i.getUint32(Te.PIXEL_WIDTH, n), h = i.getUint32(Te.PIXEL_HEIGHT, n) || 1, l = i.getUint32(Te.PIXEL_DEPTH, n) || 1, c = i.getUint32(Te.NUMBER_OF_ARRAY_ELEMENTS, n) || 1, d = i.getUint32(Te.NUMBER_OF_FACES, n), f = i.getUint32(Te.NUMBER_OF_MIPMAP_LEVELS, n), p = i.getUint32(Te.BYTES_OF_KEY_VALUE_DATA, n); if (0 === h || 1 !== l) throw new Error("Only 2D textures are supported"); if (1 !== d) throw new Error("CubeTextures are not supported by KTXLoader yet!"); if (1 !== c) throw new Error("WebGL does not support array textures"); var _, m = 4, g = 4, v = u + 3 & -4, y = h + 3 & -4, b = new Array(c), x = u * h; if (0 === o && (x = v * y), _ = 0 !== o ? Se[o] ? Se[o] * we[s] : Ae[o] : Nt[a], void 0 === _) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!"); for (var T = r ? Pe(i, p, n) : null, E = x * _, S = E, w = u, A = h, R = v, O = y, I = Ee + p, P = 0; P < f; P++) { for (var C = i.getUint32(I, n), D = I + 4, L = 0; L < c; L++) { var F = b[L]; F || (F = b[L] = new Array(f)), F[P] = { levelID: P, levelWidth: f > 1 || 0 !== o ? w : R, levelHeight: f > 1 || 0 !== o ? A : O, levelBuffer: new Uint8Array(e, D, S) }, D += S } I += C + 4, I = I % 4 !== 0 ? I + 4 - I % 4 : I, w = w >> 1 || 1, A = A >> 1 || 1, R = w + m - 1 & ~(m - 1), O = A + g - 1 & ~(g - 1), S = R * O * _ } return 0 !== o ? { uncompressed: b.map((function (t) { var e = t[0].levelBuffer, r = !1; return o === et.vK.FLOAT ? e = new Float32Array(t[0].levelBuffer.buffer, t[0].levelBuffer.byteOffset, t[0].levelBuffer.byteLength / 4) : o === et.vK.UNSIGNED_INT ? (r = !0, e = new Uint32Array(t[0].levelBuffer.buffer, t[0].levelBuffer.byteOffset, t[0].levelBuffer.byteLength / 4)) : o === et.vK.INT && (r = !0, e = new Int32Array(t[0].levelBuffer.buffer, t[0].levelBuffer.byteOffset, t[0].levelBuffer.byteLength / 4)), { resource: new M.qm(e, { width: t[0].levelWidth, height: t[0].levelHeight }), type: o, format: r ? Ie(s) : s } })), kvData: T } : { compressed: b.map((function (t) { return new Vt(null, { format: a, width: u, height: h, levels: f, levelBuffers: t }) })), kvData: T } } function Oe(t, e) { for (var r = 0; r < be.length; r++)if (e.getUint8(r) !== be[r]) return console.error(t + " is not a valid *.ktx file!"), !1; return !0 } function Ie(t) { switch (t) { case et.I2.RGBA: return et.I2.RGBA_INTEGER; case et.I2.RGB: return et.I2.RGB_INTEGER; case et.I2.RG: return et.I2.RG_INTEGER; case et.I2.RED: return et.I2.RED_INTEGER; default: return t } } function Pe(t, e, r) { var i = new Map, n = 0; while (n < e) { var o = t.getUint32(Ee + n, r), s = Ee + n + 4, a = 3 - (o + 3) % 4; if (0 === o || o > e - n) { console.error("KTXLoader: keyAndValueByteSize out of bounds"); break } for (var u = 0; u < o; u++)if (0 === t.getUint8(s + u)) break; if (-1 === u) { console.error("KTXLoader: Failed to find null byte terminating kvData key"); break } var h = (new TextDecoder).decode(new Uint8Array(t.buffer, s, u)), l = new DataView(t.buffer, s + u + 1, o - u - 1); i.set(h, l), n += 4 + o + a } return i } yt.setExtensionXhrType("dds", yt.XHR_RESPONSE_TYPE.BUFFER); var Me = function () { function t() { } return t.use = function (t, e) { if ("dds" === t.extension && t.data) try { Object.assign(t, Yt(t.name || t.url, ye(t.data), t.metadata)) } catch (r) { return void e(r) } e() }, t.extension = M.nw.Loader, t }(); yt.setExtensionXhrType("ktx", yt.XHR_RESPONSE_TYPE.BUFFER); var Ce = function () { function t() { } return t.use = function (t, e) { if ("ktx" === t.extension && t.data) try { var r = t.name || t.url, i = Re(r, t.data, this.loadKeyValueData), n = i.compressed, o = i.uncompressed, s = i.kvData; if (n) { var a = Yt(r, n, t.metadata); if (s && a.textures) for (var u in a.textures) a.textures[u].baseTexture.ktxKeyValueData = s; Object.assign(t, a) } else if (o) { var h = {}; o.forEach((function (t, e) { var i = new M.xE(new M.VL(t.resource, { mipmap: et.WB.OFF, alphaMode: et.iw.NO_PREMULTIPLIED_ALPHA, type: t.type, format: t.format })), n = r + "-" + (e + 1); s && (i.baseTexture.ktxKeyValueData = s), M.VL.addToCache(i.baseTexture, n), M.xE.addToCache(i, n), 0 === e && (h[r] = i, M.VL.addToCache(i.baseTexture, r), M.xE.addToCache(i, r)), h[n] = i })), Object.assign(t, { textures: h }) } } catch (l) { return void e(l) } e() }, t.extension = M.nw.Loader, t.loadKeyValueData = !1, t }(), De = function (t, e) { return De = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, De(t, e) }; function Le(t, e) { function r() { this.constructor = t } De(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var Fe, Ne, Be = function (t) { function e(e, r, i, n) { void 0 === e && (e = 1500), void 0 === i && (i = 16384), void 0 === n && (n = !1); var o = t.call(this) || this, s = 16384; return i > s && (i = s), o._properties = [!1, !0, !1, !1, !1], o._maxSize = e, o._batchSize = i, o._buffers = null, o._bufferUpdateIDs = [], o._updateID = 0, o.interactiveChildren = !1, o.blendMode = et.T$.NORMAL, o.autoResize = n, o.roundPixels = !0, o.baseTexture = null, o.setProperties(r), o._tint = 0, o.tintRgb = new Float32Array(4), o.tint = 16777215, o } return Le(e, t), e.prototype.setProperties = function (t) { t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4]) }, e.prototype.updateTransform = function () { this.displayObjectUpdateTransform() }, Object.defineProperty(e.prototype, "tint", { get: function () { return this._tint }, set: function (t) { this._tint = t, (0, I.hex2rgb)(t, this.tintRgb) }, enumerable: !1, configurable: !0 }), e.prototype.render = function (t) { var e = this; this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", (function () { return e.onChildrenChange(0) }))), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this)) }, e.prototype.onChildrenChange = function (t) { var e = Math.floor(t / this._batchSize); while (this._bufferUpdateIDs.length < e) this._bufferUpdateIDs.push(0); this._bufferUpdateIDs[e] = ++this._updateID }, e.prototype.dispose = function () { if (this._buffers) { for (var t = 0; t < this._buffers.length; ++t)this._buffers[t].destroy(); this._buffers = null } }, e.prototype.destroy = function (e) { t.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null }, e }(P.W2), Ue = function () { function t(t, e, r) { this.geometry = new M.ZX, this.indexBuffer = null, this.size = r, this.dynamicProperties = [], this.staticProperties = []; for (var i = 0; i < t.length; ++i) { var n = t[i]; n = { attributeName: n.attributeName, size: n.size, uploadFunction: n.uploadFunction, type: n.type || et.vK.FLOAT, offset: n.offset }, e[i] ? this.dynamicProperties.push(n) : this.staticProperties.push(n) } this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers() } return t.prototype.initBuffers = function () { var t = this.geometry, e = 0; this.indexBuffer = new M.lW((0, I.createIndicesForQuads)(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0; for (var r = 0; r < this.dynamicProperties.length; ++r) { var i = this.dynamicProperties[r]; i.offset = e, e += i.size, this.dynamicStride += i.size } var n = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4); this.dynamicData = new Float32Array(n), this.dynamicDataUint32 = new Uint32Array(n), this.dynamicBuffer = new M.lW(this.dynamicData, !1, !1); var o = 0; this.staticStride = 0; for (r = 0; r < this.staticProperties.length; ++r) { i = this.staticProperties[r]; i.offset = o, o += i.size, this.staticStride += i.size } var s = new ArrayBuffer(this.size * this.staticStride * 4 * 4); this.staticData = new Float32Array(s), this.staticDataUint32 = new Uint32Array(s), this.staticBuffer = new M.lW(this.staticData, !0, !1); for (r = 0; r < this.dynamicProperties.length; ++r) { i = this.dynamicProperties[r]; t.addAttribute(i.attributeName, this.dynamicBuffer, 0, i.type === et.vK.UNSIGNED_BYTE, i.type, 4 * this.dynamicStride, 4 * i.offset) } for (r = 0; r < this.staticProperties.length; ++r) { i = this.staticProperties[r]; t.addAttribute(i.attributeName, this.staticBuffer, 0, i.type === et.vK.UNSIGNED_BYTE, i.type, 4 * this.staticStride, 4 * i.offset) } }, t.prototype.uploadDynamic = function (t, e, r) { for (var i = 0; i < this.dynamicProperties.length; i++) { var n = this.dynamicProperties[i]; n.uploadFunction(t, e, r, n.type === et.vK.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, n.offset) } this.dynamicBuffer._updateID++ }, t.prototype.uploadStatic = function (t, e, r) { for (var i = 0; i < this.staticProperties.length; i++) { var n = this.staticProperties[i]; n.uploadFunction(t, e, r, n.type === et.vK.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, n.offset) } this.staticBuffer._updateID++ }, t.prototype.destroy = function () { this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy() }, t }(), ke = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", Ge = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", Xe = function (t) { function e(e) { var r = t.call(this, e) || this; return r.shader = null, r.properties = null, r.tempMatrix = new H.y3, r.properties = [{ attributeName: "aVertexPosition", size: 2, uploadFunction: r.uploadVertices, offset: 0 }, { attributeName: "aPositionCoord", size: 2, uploadFunction: r.uploadPosition, offset: 0 }, { attributeName: "aRotation", size: 1, uploadFunction: r.uploadRotation, offset: 0 }, { attributeName: "aTextureCoord", size: 2, uploadFunction: r.uploadUvs, offset: 0 }, { attributeName: "aColor", size: 1, type: et.vK.UNSIGNED_BYTE, uploadFunction: r.uploadTint, offset: 0 }], r.shader = M.ex.from(Ge, ke, {}), r.state = M.ZM.for2d(), r } return Le(e, t), e.prototype.render = function (t) { var e = t.children, r = t._maxSize, i = t._batchSize, n = this.renderer, o = e.length; if (0 !== o) { o > r && !t.autoResize && (o = r); var s = t._buffers; s || (s = t._buffers = this.generateBuffers(t)); var a = e[0]._texture.baseTexture, u = a.alphaMode > 0; this.state.blendMode = (0, I.correctBlendMode)(t.blendMode, u), n.state.set(this.state); var h = n.gl, l = t.worldTransform.copyTo(this.tempMatrix); l.prepend(n.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = l.toArray(!0), this.shader.uniforms.uColor = (0, I.premultiplyRgba)(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, u), this.shader.uniforms.uSampler = a, this.renderer.shader.bind(this.shader); for (var c = !1, d = 0, f = 0; d < o; d += i, f += 1) { var p = o - d; p > i && (p = i), f >= s.length && s.push(this._generateOneMoreBuffer(t)); var _ = s[f]; _.uploadDynamic(e, d, p); var m = t._bufferUpdateIDs[f] || 0; c = c || _._updateID < m, c && (_._updateID = t._updateID, _.uploadStatic(e, d, p)), n.geometry.bind(_.geometry), h.drawElements(h.TRIANGLES, 6 * p, h.UNSIGNED_SHORT, 0) } } }, e.prototype.generateBuffers = function (t) { for (var e = [], r = t._maxSize, i = t._batchSize, n = t._properties, o = 0; o < r; o += i)e.push(new Ue(this.properties, n, i)); return e }, e.prototype._generateOneMoreBuffer = function (t) { var e = t._batchSize, r = t._properties; return new Ue(this.properties, r, e) }, e.prototype.uploadVertices = function (t, e, r, i, n, o) { for (var s = 0, a = 0, u = 0, h = 0, l = 0; l < r; ++l) { var c = t[e + l], d = c._texture, f = c.scale.x, p = c.scale.y, _ = d.trim, m = d.orig; _ ? (a = _.x - c.anchor.x * m.width, s = a + _.width, h = _.y - c.anchor.y * m.height, u = h + _.height) : (s = m.width * (1 - c.anchor.x), a = m.width * -c.anchor.x, u = m.height * (1 - c.anchor.y), h = m.height * -c.anchor.y), i[o] = a * f, i[o + 1] = h * p, i[o + n] = s * f, i[o + n + 1] = h * p, i[o + 2 * n] = s * f, i[o + 2 * n + 1] = u * p, i[o + 3 * n] = a * f, i[o + 3 * n + 1] = u * p, o += 4 * n } }, e.prototype.uploadPosition = function (t, e, r, i, n, o) { for (var s = 0; s < r; s++) { var a = t[e + s].position; i[o] = a.x, i[o + 1] = a.y, i[o + n] = a.x, i[o + n + 1] = a.y, i[o + 2 * n] = a.x, i[o + 2 * n + 1] = a.y, i[o + 3 * n] = a.x, i[o + 3 * n + 1] = a.y, o += 4 * n } }, e.prototype.uploadRotation = function (t, e, r, i, n, o) { for (var s = 0; s < r; s++) { var a = t[e + s].rotation; i[o] = a, i[o + n] = a, i[o + 2 * n] = a, i[o + 3 * n] = a, o += 4 * n } }, e.prototype.uploadUvs = function (t, e, r, i, n, o) { for (var s = 0; s < r; ++s) { var a = t[e + s]._texture._uvs; a ? (i[o] = a.x0, i[o + 1] = a.y0, i[o + n] = a.x1, i[o + n + 1] = a.y1, i[o + 2 * n] = a.x2, i[o + 2 * n + 1] = a.y2, i[o + 3 * n] = a.x3, i[o + 3 * n + 1] = a.y3, o += 4 * n) : (i[o] = 0, i[o + 1] = 0, i[o + n] = 0, i[o + n + 1] = 0, i[o + 2 * n] = 0, i[o + 2 * n + 1] = 0, i[o + 3 * n] = 0, i[o + 3 * n + 1] = 0, o += 4 * n) } }, e.prototype.uploadTint = function (t, e, r, i, n, o) { for (var s = 0; s < r; ++s) { var a = t[e + s], u = a._texture.baseTexture.alphaMode > 0, h = a.alpha, l = h < 1 && u ? (0, I.premultiplyTint)(a._tintRGB, h) : a._tintRGB + (255 * h << 24); i[o] = l, i[o + n] = l, i[o + 2 * n] = l, i[o + 3 * n] = l, o += 4 * n } }, e.prototype.destroy = function () { t.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null }, e.extension = { name: "particle", type: M.nw.RendererPlugin }, e }(M.bO); (function (t) { t["MITER"] = "miter", t["BEVEL"] = "bevel", t["ROUND"] = "round" })(Fe || (Fe = {})), function (t) { t["BUTT"] = "butt", t["ROUND"] = "round", t["SQUARE"] = "square" }(Ne || (Ne = {})); var je = { adaptive: !0, maxLength: 10, minSegments: 8, maxSegments: 2048, epsilon: 1e-4, _segmentsCount: function (t, e) { if (void 0 === e && (e = 20), !this.adaptive || !t || isNaN(t)) return e; var r = Math.ceil(t / this.maxLength); return r < this.minSegments ? r = this.minSegments : r > this.maxSegments && (r = this.maxSegments), r } }, He = function () { function t() { this.color = 16777215, this.alpha = 1, this.texture = M.xE.WHITE, this.matrix = null, this.visible = !1, this.reset() } return t.prototype.clone = function () { var e = new t; return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e }, t.prototype.reset = function () { this.color = 16777215, this.alpha = 1, this.texture = M.xE.WHITE, this.matrix = null, this.visible = !1 }, t.prototype.destroy = function () { this.texture = null, this.matrix = null }, t }(), Ve = function (t, e) { return Ve = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, Ve(t, e) }; function ze(t, e) { function r() { this.constructor = t } Ve(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } function Ye(t, e) { var r, i; void 0 === e && (e = !1); var n = t.length; if (!(n < 6)) { for (var o = 0, s = 0, a = t[n - 2], u = t[n - 1]; s < n; s += 2) { var h = t[s], l = t[s + 1]; o += (h - a) * (l + u), a = h, u = l } if (!e && o > 0 || e && o <= 0) { var c = n / 2; for (s = c + c % 2; s < n; s += 2) { var d = n - s - 2, f = n - s - 1, p = s, _ = s + 1; r = [t[p], t[d]], t[d] = r[0], t[p] = r[1], i = [t[_], t[f]], t[f] = i[0], t[_] = i[1] } } } } var We = { build: function (t) { t.points = t.shape.points.slice() }, triangulate: function (t, e) { var r = t.points, i = t.holes, n = e.points, o = e.indices; if (r.length >= 6) { Ye(r, !1); for (var s = [], a = 0; a < i.length; a++) { var u = i[a]; Ye(u.points, !0), s.push(r.length / 2), r = r.concat(u.points) } var h = (0, I.earcut)(r, s, 2); if (!h) return; var l = n.length / 2; for (a = 0; a < h.length; a += 3)o.push(h[a] + l), o.push(h[a + 1] + l), o.push(h[a + 2] + l); for (a = 0; a < r.length; a++)n.push(r[a]) } } }, $e = { build: function (t) { var e, r, i, n, o, s, a = t.points; if (t.type === H.HS.CIRC) { var u = t.shape; e = u.x, r = u.y, o = s = u.radius, i = n = 0 } else if (t.type === H.HS.ELIP) { var h = t.shape; e = h.x, r = h.y, o = h.width, s = h.height, i = n = 0 } else { var l = t.shape, c = l.width / 2, d = l.height / 2; e = l.x + c, r = l.y + d, o = s = Math.max(0, Math.min(l.radius, Math.min(c, d))), i = c - o, n = d - s } if (o >= 0 && s >= 0 && i >= 0 && n >= 0) { var f = Math.ceil(2.3 * Math.sqrt(o + s)), p = 8 * f + (i ? 4 : 0) + (n ? 4 : 0); if (a.length = p, 0 !== p) { if (0 === f) return a.length = 8, a[0] = a[6] = e + i, a[1] = a[3] = r + n, a[2] = a[4] = e - i, void (a[5] = a[7] = r - n); var _ = 0, m = 4 * f + (i ? 2 : 0) + 2, g = m, v = p, y = i + o, b = n, x = e + y, T = e - y, E = r + b; if (a[_++] = x, a[_++] = E, a[--m] = E, a[--m] = T, n) { var S = r - b; a[g++] = T, a[g++] = S, a[--v] = S, a[--v] = x } for (var w = 1; w < f; w++) { var A = Math.PI / 2 * (w / f); y = i + Math.cos(A) * o, b = n + Math.sin(A) * s, x = e + y, T = e - y, E = r + b, S = r - b; a[_++] = x, a[_++] = E, a[--m] = E, a[--m] = T, a[g++] = T, a[g++] = S, a[--v] = S, a[--v] = x } y = i, b = n + s, x = e + y, T = e - y, E = r + b, S = r - b; a[_++] = x, a[_++] = E, a[--v] = S, a[--v] = x, i && (a[_++] = T, a[_++] = E, a[--v] = S, a[--v] = T) } } else a.length = 0 }, triangulate: function (t, e) { var r = t.points, i = e.points, n = e.indices; if (0 !== r.length) { var o, s, a = i.length / 2, u = a; if (t.type !== H.HS.RREC) { var h = t.shape; o = h.x, s = h.y } else { var l = t.shape; o = l.x + l.width / 2, s = l.y + l.height / 2 } var c = t.matrix; i.push(t.matrix ? c.a * o + c.c * s + c.tx : o, t.matrix ? c.b * o + c.d * s + c.ty : s), a++, i.push(r[0], r[1]); for (var d = 2; d < r.length; d += 2)i.push(r[d], r[d + 1]), n.push(a++, u, a); n.push(u + 1, u, a) } } }, qe = { build: function (t) { var e = t.shape, r = e.x, i = e.y, n = e.width, o = e.height, s = t.points; s.length = 0, s.push(r, i, r + n, i, r + n, i + o, r, i + o) }, triangulate: function (t, e) { var r = t.points, i = e.points, n = i.length / 2; i.push(r[0], r[1], r[2], r[3], r[6], r[7], r[4], r[5]), e.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3) } }; function Ke(t, e, r) { var i = e - t; return t + i * r } function Ze(t, e, r, i, n, o, s) { void 0 === s && (s = []); for (var a = 20, u = s, h = 0, l = 0, c = 0, d = 0, f = 0, p = 0, _ = 0, m = 0; _ <= a; ++_)m = _ / a, h = Ke(t, r, m), l = Ke(e, i, m), c = Ke(r, n, m), d = Ke(i, o, m), f = Ke(h, c, m), p = Ke(l, d, m), 0 === _ && u[u.length - 2] === f && u[u.length - 1] === p || u.push(f, p); return u } var Je = { build: function (t) { if (vr.nextRoundedRectBehavior) $e.build(t); else { var e = t.shape, r = t.points, i = e.x, n = e.y, o = e.width, s = e.height, a = Math.max(0, Math.min(e.radius, Math.min(o, s) / 2)); r.length = 0, a ? (Ze(i, n + a, i, n, i + a, n, r), Ze(i + o - a, n, i + o, n, i + o, n + a, r), Ze(i + o, n + s - a, i + o, n + s, i + o - a, n + s, r), Ze(i + a, n + s, i, n + s, i, n + s - a, r)) : r.push(i, n, i + o, n, i + o, n + s, i, n + s) } }, triangulate: function (t, e) { if (vr.nextRoundedRectBehavior) $e.triangulate(t, e); else { for (var r = t.points, i = e.points, n = e.indices, o = i.length / 2, s = (0, I.earcut)(r, null, 2), a = 0, u = s.length; a < u; a += 3)n.push(s[a] + o), n.push(s[a + 1] + o), n.push(s[a + 2] + o); for (a = 0, u = r.length; a < u; a++)i.push(r[a], r[++a]) } } }; function Qe(t, e, r, i, n, o, s, a) { var u, h, l = t - r * n, c = e - i * n, d = t + r * o, f = e + i * o; s ? (u = i, h = -r) : (u = -i, h = r); var p = l + u, _ = c + h, m = d + u, g = f + h; return a.push(p, _), a.push(m, g), 2 } function tr(t, e, r, i, n, o, s, a) { var u = r - t, h = i - e, l = Math.atan2(u, h), c = Math.atan2(n - t, o - e); a && l < c ? l += 2 * Math.PI : !a && l > c && (c += 2 * Math.PI); var d = l, f = c - l, p = Math.abs(f), _ = Math.sqrt(u * u + h * h), m = 1 + (15 * p * Math.sqrt(_) / Math.PI >> 0), g = f / m; if (d += g, a) { s.push(t, e), s.push(r, i); for (var v = 1, y = d; v < m; v++, y += g)s.push(t, e), s.push(t + Math.sin(y) * _, e + Math.cos(y) * _); s.push(t, e), s.push(n, o) } else { s.push(r, i), s.push(t, e); for (v = 1, y = d; v < m; v++, y += g)s.push(t + Math.sin(y) * _, e + Math.cos(y) * _), s.push(t, e); s.push(n, o), s.push(t, e) } return 2 * m } function er(t, e) { var r = t.shape, i = t.points || r.points.slice(), n = e.closePointEps; if (0 !== i.length) { var o = t.lineStyle, s = new H.E9(i[0], i[1]), a = new H.E9(i[i.length - 2], i[i.length - 1]), u = r.type !== H.HS.POLY || r.closeStroke, h = Math.abs(s.x - a.x) < n && Math.abs(s.y - a.y) < n; if (u) { i = i.slice(), h && (i.pop(), i.pop(), a.set(i[i.length - 2], i[i.length - 1])); var l = .5 * (s.x + a.x), c = .5 * (a.y + s.y); i.unshift(l, c), i.push(l, c) } var d = e.points, f = i.length / 2, p = i.length, _ = d.length / 2, m = o.width / 2, g = m * m, v = o.miterLimit * o.miterLimit, y = i[0], b = i[1], x = i[2], T = i[3], E = 0, S = 0, w = -(b - T), A = y - x, R = 0, O = 0, I = Math.sqrt(w * w + A * A); w /= I, A /= I, w *= m, A *= m; var P = o.alignment, M = 2 * (1 - P), C = 2 * P; u || (o.cap === Ne.ROUND ? p += tr(y - w * (M - C) * .5, b - A * (M - C) * .5, y - w * M, b - A * M, y + w * C, b + A * C, d, !0) + 2 : o.cap === Ne.SQUARE && (p += Qe(y, b, w, A, M, C, !0, d))), d.push(y - w * M, b - A * M), d.push(y + w * C, b + A * C); for (var D = 1; D < f - 1; ++D) { y = i[2 * (D - 1)], b = i[2 * (D - 1) + 1], x = i[2 * D], T = i[2 * D + 1], E = i[2 * (D + 1)], S = i[2 * (D + 1) + 1], w = -(b - T), A = y - x, I = Math.sqrt(w * w + A * A), w /= I, A /= I, w *= m, A *= m, R = -(T - S), O = x - E, I = Math.sqrt(R * R + O * O), R /= I, O /= I, R *= m, O *= m; var L = x - y, F = b - T, N = x - E, B = S - T, U = L * N + F * B, k = F * N - B * L, G = k < 0; if (Math.abs(k) < .001 * Math.abs(U)) d.push(x - w * M, T - A * M), d.push(x + w * C, T + A * C), U >= 0 && (o.join === Fe.ROUND ? p += tr(x, T, x - w * M, T - A * M, x - R * M, T - O * M, d, !1) + 4 : p += 2, d.push(x - R * C, T - O * C), d.push(x + R * M, T + O * M)); else { var X = (-w + y) * (-A + T) - (-w + x) * (-A + b), j = (-R + E) * (-O + T) - (-R + x) * (-O + S), V = (L * j - N * X) / k, z = (B * X - F * j) / k, Y = (V - x) * (V - x) + (z - T) * (z - T), W = x + (V - x) * M, $ = T + (z - T) * M, q = x - (V - x) * C, K = T - (z - T) * C, Z = Math.min(L * L + F * F, N * N + B * B), J = G ? M : C, Q = Z + J * J * g, tt = Y <= Q; tt ? o.join === Fe.BEVEL || Y / g > v ? (G ? (d.push(W, $), d.push(x + w * C, T + A * C), d.push(W, $), d.push(x + R * C, T + O * C)) : (d.push(x - w * M, T - A * M), d.push(q, K), d.push(x - R * M, T - O * M), d.push(q, K)), p += 2) : o.join === Fe.ROUND ? G ? (d.push(W, $), d.push(x + w * C, T + A * C), p += tr(x, T, x + w * C, T + A * C, x + R * C, T + O * C, d, !0) + 4, d.push(W, $), d.push(x + R * C, T + O * C)) : (d.push(x - w * M, T - A * M), d.push(q, K), p += tr(x, T, x - w * M, T - A * M, x - R * M, T - O * M, d, !1) + 4, d.push(x - R * M, T - O * M), d.push(q, K)) : (d.push(W, $), d.push(q, K)) : (d.push(x - w * M, T - A * M), d.push(x + w * C, T + A * C), o.join === Fe.ROUND ? p += G ? tr(x, T, x + w * C, T + A * C, x + R * C, T + O * C, d, !0) + 2 : tr(x, T, x - w * M, T - A * M, x - R * M, T - O * M, d, !1) + 2 : o.join === Fe.MITER && Y / g <= v && (G ? (d.push(q, K), d.push(q, K)) : (d.push(W, $), d.push(W, $)), p += 2), d.push(x - R * M, T - O * M), d.push(x + R * C, T + O * C), p += 2) } } y = i[2 * (f - 2)], b = i[2 * (f - 2) + 1], x = i[2 * (f - 1)], T = i[2 * (f - 1) + 1], w = -(b - T), A = y - x, I = Math.sqrt(w * w + A * A), w /= I, A /= I, w *= m, A *= m, d.push(x - w * M, T - A * M), d.push(x + w * C, T + A * C), u || (o.cap === Ne.ROUND ? p += tr(x - w * (M - C) * .5, T - A * (M - C) * .5, x - w * M, T - A * M, x + w * C, T + A * C, d, !1) + 2 : o.cap === Ne.SQUARE && (p += Qe(x, T, w, A, M, C, !1, d))); var et = e.indices, rt = je.epsilon * je.epsilon; for (D = _; D < p + _ - 2; ++D)y = d[2 * D], b = d[2 * D + 1], x = d[2 * (D + 1)], T = d[2 * (D + 1) + 1], E = d[2 * (D + 2)], S = d[2 * (D + 2) + 1], Math.abs(y * (T - S) + x * (S - b) + E * (b - T)) < rt || et.push(D, D + 1, D + 2) } } function rr(t, e) { var r = 0, i = t.shape, n = t.points || i.points, o = i.type !== H.HS.POLY || i.closeStroke; if (0 !== n.length) { var s = e.points, a = e.indices, u = n.length / 2, h = s.length / 2, l = h; for (s.push(n[0], n[1]), r = 1; r < u; r++)s.push(n[2 * r], n[2 * r + 1]), a.push(l, l + 1), l++; o && a.push(l, h) } } function ir(t, e) { t.lineStyle.native ? rr(t, e) : er(t, e) } var nr, or = function () { function t() { } return t.curveTo = function (t, e, r, i, n, o) { var s = o[o.length - 2], a = o[o.length - 1], u = a - e, h = s - t, l = i - e, c = r - t, d = Math.abs(u * c - h * l); if (d < 1e-8 || 0 === n) return o[o.length - 2] === t && o[o.length - 1] === e || o.push(t, e), null; var f = u * u + h * h, p = l * l + c * c, _ = u * l + h * c, m = n * Math.sqrt(f) / d, g = n * Math.sqrt(p) / d, v = m * _ / f, y = g * _ / p, b = m * c + g * h, x = m * l + g * u, T = h * (g + v), E = u * (g + v), S = c * (m + y), w = l * (m + y), A = Math.atan2(E - x, T - b), R = Math.atan2(w - x, S - b); return { cx: b + t, cy: x + e, radius: n, startAngle: A, endAngle: R, anticlockwise: h * l > c * u } }, t.arc = function (t, e, r, i, n, o, s, a, u) { for (var h = s - o, l = je._segmentsCount(Math.abs(h) * n, 40 * Math.ceil(Math.abs(h) / H._b)), c = h / (2 * l), d = 2 * c, f = Math.cos(c), p = Math.sin(c), _ = l - 1, m = _ % 1 / _, g = 0; g <= _; ++g) { var v = g + m * g, y = c + o + d * v, b = Math.cos(y), x = -Math.sin(y); u.push((f * b + p * x) * n + r, (f * -x + p * b) * n + i) } }, t }(), sr = function () { function t() { } return t.curveLength = function (t, e, r, i, n, o, s, a) { for (var u = 10, h = 0, l = 0, c = 0, d = 0, f = 0, p = 0, _ = 0, m = 0, g = 0, v = 0, y = 0, b = t, x = e, T = 1; T <= u; ++T)l = T / u, c = l * l, d = c * l, f = 1 - l, p = f * f, _ = p * f, m = _ * t + 3 * p * l * r + 3 * f * c * n + d * s, g = _ * e + 3 * p * l * i + 3 * f * c * o + d * a, v = b - m, y = x - g, b = m, x = g, h += Math.sqrt(v * v + y * y); return h }, t.curveTo = function (e, r, i, n, o, s, a) { var u = a[a.length - 2], h = a[a.length - 1]; a.length -= 2; var l = je._segmentsCount(t.curveLength(u, h, e, r, i, n, o, s)), c = 0, d = 0, f = 0, p = 0, _ = 0; a.push(u, h); for (var m = 1, g = 0; m <= l; ++m)g = m / l, c = 1 - g, d = c * c, f = d * c, p = g * g, _ = p * g, a.push(f * u + 3 * d * g * e + 3 * c * p * i + _ * o, f * h + 3 * d * g * r + 3 * c * p * n + _ * s) }, t }(), ar = function () { function t() { } return t.curveLength = function (t, e, r, i, n, o) { var s = t - 2 * r + n, a = e - 2 * i + o, u = 2 * r - 2 * t, h = 2 * i - 2 * e, l = 4 * (s * s + a * a), c = 4 * (s * u + a * h), d = u * u + h * h, f = 2 * Math.sqrt(l + c + d), p = Math.sqrt(l), _ = 2 * l * p, m = 2 * Math.sqrt(d), g = c / p; return (_ * f + p * c * (f - m) + (4 * d * l - c * c) * Math.log((2 * p + g + f) / (g + m))) / (4 * _) }, t.curveTo = function (e, r, i, n, o) { for (var s = o[o.length - 2], a = o[o.length - 1], u = je._segmentsCount(t.curveLength(s, a, e, r, i, n)), h = 0, l = 0, c = 1; c <= u; ++c) { var d = c / u; h = s + (e - s) * d, l = a + (r - a) * d, o.push(h + (e + (i - e) * d - h) * d, l + (r + (n - r) * d - l) * d) } }, t }(), ur = function () { function t() { this.reset() } return t.prototype.begin = function (t, e, r) { this.reset(), this.style = t, this.start = e, this.attribStart = r }, t.prototype.end = function (t, e) { this.attribSize = e - this.attribStart, this.size = t - this.start }, t.prototype.reset = function () { this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0 }, t }(), hr = (nr = {}, nr[H.HS.POLY] = We, nr[H.HS.CIRC] = $e, nr[H.HS.ELIP] = $e, nr[H.HS.RECT] = qe, nr[H.HS.RREC] = Je, nr), lr = [], cr = [], dr = function () { function t(t, e, r, i) { void 0 === e && (e = null), void 0 === r && (r = null), void 0 === i && (i = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = i, this.type = t.type } return t.prototype.clone = function () { return new t(this.shape, this.fillStyle, this.lineStyle, this.matrix) }, t.prototype.destroy = function () { this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null }, t }(), fr = new H.E9, pr = function (t) { function e() { var e = t.call(this) || this; return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new P.YZ, e.boundsDirty = -1, e } return ze(e, t), Object.defineProperty(e.prototype, "bounds", { get: function () { return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds }, enumerable: !1, configurable: !0 }), e.prototype.invalidate = function () { this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0; for (var t = 0; t < this.drawCalls.length; t++)this.drawCalls[t].texArray.clear(), cr.push(this.drawCalls[t]); this.drawCalls.length = 0; for (t = 0; t < this.batches.length; t++) { var e = this.batches[t]; e.reset(), lr.push(e) } this.batches.length = 0 }, e.prototype.clear = function () { return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this }, e.prototype.drawShape = function (t, e, r, i) { void 0 === e && (e = null), void 0 === r && (r = null), void 0 === i && (i = null); var n = new dr(t, e, r, i); return this.graphicsData.push(n), this.dirty++, this }, e.prototype.drawHole = function (t, e) { if (void 0 === e && (e = null), !this.graphicsData.length) return null; var r = new dr(t, null, null, e), i = this.graphicsData[this.graphicsData.length - 1]; return r.lineStyle = i.lineStyle, i.holes.push(r), this.dirty++, this }, e.prototype.destroy = function () { t.prototype.destroy.call(this); for (var e = 0; e < this.graphicsData.length; ++e)this.graphicsData[e].destroy(); this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null }, e.prototype.containsPoint = function (t) { for (var e = this.graphicsData, r = 0; r < e.length; ++r) { var i = e[r]; if (i.fillStyle.visible && (i.shape && (i.matrix ? i.matrix.applyInverse(t, fr) : fr.copyFrom(t), i.shape.contains(fr.x, fr.y)))) { var n = !1; if (i.holes) for (var o = 0; o < i.holes.length; o++) { var s = i.holes[o]; if (s.shape.contains(fr.x, fr.y)) { n = !0; break } } if (!n) return !0 } } return !1 }, e.prototype.updateBatches = function () { if (this.graphicsData.length) { if (this.validateBatching()) { this.cacheDirty = this.dirty; var t = this.uvs, e = this.graphicsData, r = null, i = null; this.batches.length > 0 && (r = this.batches[this.batches.length - 1], i = r.style); for (var n = this.shapeIndex; n < e.length; n++) { this.shapeIndex++; var o = e[n], s = o.fillStyle, a = o.lineStyle, u = hr[o.type]; u.build(o), o.matrix && this.transformPoints(o.points, o.matrix), (s.visible || a.visible) && this.processHoles(o.holes); for (var h = 0; h < 2; h++) { var l = 0 === h ? s : a; if (l.visible) { var c = l.texture.baseTexture, d = this.indices.length, f = this.points.length / 2; c.wrapMode = et.Nt.REPEAT, 0 === h ? this.processFill(o) : this.processLine(o); var p = this.points.length / 2 - f; 0 !== p && (r && !this._compareStyles(i, l) && (r.end(d, f), r = null), r || (r = lr.pop() || new ur, r.begin(l, d, f), this.batches.push(r), i = l), this.addUvs(this.points, t, l.texture, f, p, l.matrix)) } } } var _ = this.indices.length, m = this.points.length / 2; if (r && r.end(_, m), 0 !== this.batches.length) { var g = m > 65535; this.indicesUint16 && this.indices.length === this.indicesUint16.length && g === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = g ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls() } else this.batchable = !0 } } else this.batchable = !0 }, e.prototype._compareStyles = function (t, e) { return !(!t || !e) && (t.texture.baseTexture === e.texture.baseTexture && (t.color + t.alpha === e.color + e.alpha && !!t.native === !!e.native)) }, e.prototype.validateBatching = function () { if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1; for (var t = 0, e = this.graphicsData.length; t < e; t++) { var r = this.graphicsData[t], i = r.fillStyle, n = r.lineStyle; if (i && !i.texture.baseTexture.valid) return !1; if (n && !n.texture.baseTexture.valid) return !1 } return !0 }, e.prototype.packBatches = function () { this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs); for (var t = this.batches, e = 0, r = t.length; e < r; e++)for (var i = t[e], n = 0; n < i.size; n++) { var o = i.start + n; this.indicesUint16[o] = this.indicesUint16[o] - i.attribStart } }, e.prototype.isBatchable = function () { if (this.points.length > 131070) return !1; for (var t = this.batches, r = 0; r < t.length; r++)if (t[r].style.native) return !1; return this.points.length < 2 * e.BATCHABLE_SIZE }, e.prototype.buildDrawCalls = function () { for (var t = ++M.VL._globalBatch, e = 0; e < this.drawCalls.length; e++)this.drawCalls[e].texArray.clear(), cr.push(this.drawCalls[e]); this.drawCalls.length = 0; var r = this.colors, i = this.textureIds, n = cr.pop(); n || (n = new M.a$, n.texArray = new M.Ie), n.texArray.count = 0, n.start = 0, n.size = 0, n.type = et.lg.TRIANGLES; var o = 0, s = null, a = 0, u = !1, h = et.lg.TRIANGLES, l = 0; this.drawCalls.push(n); for (e = 0; e < this.batches.length; e++) { var c = this.batches[e], d = 8, f = c.style, p = f.texture.baseTexture; u !== !!f.native && (u = !!f.native, h = u ? et.lg.LINES : et.lg.TRIANGLES, s = null, o = d, t++), s !== p && (s = p, p._batchEnabled !== t && (o === d && (t++, o = 0, n.size > 0 && (n = cr.pop(), n || (n = new M.a$, n.texArray = new M.Ie), this.drawCalls.push(n)), n.start = l, n.size = 0, n.texArray.count = 0, n.type = h), p.touched = 1, p._batchEnabled = t, p._batchLocation = o, p.wrapMode = et.Nt.REPEAT, n.texArray.elements[n.texArray.count++] = p, o++)), n.size += c.size, l += c.size, a = p._batchLocation, this.addColors(r, f.color, f.alpha, c.attribSize, c.attribStart), this.addTextureIds(i, a, c.attribSize, c.attribStart) } M.VL._globalBatch = t, this.packAttributes() }, e.prototype.packAttributes = function () { for (var t = this.points, e = this.uvs, r = this.colors, i = this.textureIds, n = new ArrayBuffer(3 * t.length * 4), o = new Float32Array(n), s = new Uint32Array(n), a = 0, u = 0; u < t.length / 2; u++)o[a++] = t[2 * u], o[a++] = t[2 * u + 1], o[a++] = e[2 * u], o[a++] = e[2 * u + 1], s[a++] = r[u], o[a++] = i[u]; this._buffer.update(n), this._indexBuffer.update(this.indicesUint16) }, e.prototype.processFill = function (t) { if (t.holes.length) We.triangulate(t, this); else { var e = hr[t.type]; e.triangulate(t, this) } }, e.prototype.processLine = function (t) { ir(t, this); for (var e = 0; e < t.holes.length; e++)ir(t.holes[e], this) }, e.prototype.processHoles = function (t) { for (var e = 0; e < t.length; e++) { var r = t[e], i = hr[r.type]; i.build(r), r.matrix && this.transformPoints(r.points, r.matrix) } }, e.prototype.calculateBounds = function () { var t = this._bounds; t.clear(), t.addVertexData(this.points, 0, this.points.length), t.pad(this.boundsPadding, this.boundsPadding) }, e.prototype.transformPoints = function (t, e) { for (var r = 0; r < t.length / 2; r++) { var i = t[2 * r], n = t[2 * r + 1]; t[2 * r] = e.a * i + e.c * n + e.tx, t[2 * r + 1] = e.b * i + e.d * n + e.ty } }, e.prototype.addColors = function (t, e, r, i, n) { void 0 === n && (n = 0); var o = (e >> 16) + (65280 & e) + ((255 & e) << 16), s = (0, I.premultiplyTint)(o, r); t.length = Math.max(t.length, n + i); for (var a = 0; a < i; a++)t[n + a] = s }, e.prototype.addTextureIds = function (t, e, r, i) { void 0 === i && (i = 0), t.length = Math.max(t.length, i + r); for (var n = 0; n < r; n++)t[i + n] = e }, e.prototype.addUvs = function (t, e, r, i, n, o) { void 0 === o && (o = null); var s = 0, a = e.length, u = r.frame; while (s < n) { var h = t[2 * (i + s)], l = t[2 * (i + s) + 1]; if (o) { var c = o.a * h + o.c * l + o.tx; l = o.b * h + o.d * l + o.ty, h = c } s++, e.push(h / u.width, l / u.height) } var d = r.baseTexture; (u.width < d.width || u.height < d.height) && this.adjustUvs(e, r, a, n) }, e.prototype.adjustUvs = function (t, e, r, i) { for (var n = e.baseTexture, o = 1e-6, s = r + 2 * i, a = e.frame, u = a.width / n.width, h = a.height / n.height, l = a.x / a.width, c = a.y / a.height, d = Math.floor(t[r] + o), f = Math.floor(t[r + 1] + o), p = r + 2; p < s; p += 2)d = Math.min(d, Math.floor(t[p] + o)), f = Math.min(f, Math.floor(t[p + 1] + o)); l -= d, c -= f; for (p = r; p < s; p += 2)t[p] = (t[p] + l) * u, t[p + 1] = (t[p + 1] + c) * h }, e.BATCHABLE_SIZE = 100, e }(M.JZ), _r = function (t) { function e() { var e = null !== t && t.apply(this, arguments) || this; return e.width = 0, e.alignment = .5, e.native = !1, e.cap = Ne.BUTT, e.join = Fe.MITER, e.miterLimit = 10, e } return ze(e, t), e.prototype.clone = function () { var t = new e; return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t }, e.prototype.reset = function () { t.prototype.reset.call(this), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1 }, e }(He), mr = new Float32Array(3), gr = {}, vr = function (t) { function e(e) { void 0 === e && (e = null); var r = t.call(this) || this; return r.shader = null, r.pluginName = "batch", r.currentPath = null, r.batches = [], r.batchTint = -1, r.batchDirty = -1, r.vertexData = null, r._fillStyle = new He, r._lineStyle = new _r, r._matrix = null, r._holeMode = !1, r.state = M.ZM.for2d(), r._geometry = e || new pr, r._geometry.refCount++, r._transformID = -1, r.tint = 16777215, r.blendMode = et.T$.NORMAL, r } return ze(e, t), Object.defineProperty(e.prototype, "geometry", { get: function () { return this._geometry }, enumerable: !1, configurable: !0 }), e.prototype.clone = function () { return this.finishPoly(), new e(this._geometry) }, Object.defineProperty(e.prototype, "blendMode", { get: function () { return this.state.blendMode }, set: function (t) { this.state.blendMode = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tint", { get: function () { return this._tint }, set: function (t) { this._tint = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "fill", { get: function () { return this._fillStyle }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "line", { get: function () { return this._lineStyle }, enumerable: !1, configurable: !0 }), e.prototype.lineStyle = function (t, e, r, i, n) { return void 0 === t && (t = null), void 0 === e && (e = 0), void 0 === r && (r = 1), void 0 === i && (i = .5), void 0 === n && (n = !1), "number" === typeof t && (t = { width: t, color: e, alpha: r, alignment: i, native: n }), this.lineTextureStyle(t) }, e.prototype.lineTextureStyle = function (t) { t = Object.assign({ width: 0, texture: M.xE.WHITE, color: t && t.texture ? 16777215 : 0, alpha: 1, matrix: null, alignment: .5, native: !1, cap: Ne.BUTT, join: Fe.MITER, miterLimit: 10 }, t), this.currentPath && this.startPoly(); var e = t.width > 0 && t.alpha > 0; return e ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._lineStyle, { visible: e }, t)) : this._lineStyle.reset(), this }, e.prototype.startPoly = function () { if (this.currentPath) { var t = this.currentPath.points, e = this.currentPath.points.length; e > 2 && (this.drawShape(this.currentPath), this.currentPath = new H.mg, this.currentPath.closeStroke = !1, this.currentPath.points.push(t[e - 2], t[e - 1])) } else this.currentPath = new H.mg, this.currentPath.closeStroke = !1 }, e.prototype.finishPoly = function () { this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0) }, e.prototype.moveTo = function (t, e) { return this.startPoly(), this.currentPath.points[0] = t, this.currentPath.points[1] = e, this }, e.prototype.lineTo = function (t, e) { this.currentPath || this.moveTo(0, 0); var r = this.currentPath.points, i = r[r.length - 2], n = r[r.length - 1]; return i === t && n === e || r.push(t, e), this }, e.prototype._initCurve = function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [t, e]) : this.moveTo(t, e) }, e.prototype.quadraticCurveTo = function (t, e, r, i) { this._initCurve(); var n = this.currentPath.points; return 0 === n.length && this.moveTo(0, 0), ar.curveTo(t, e, r, i, n), this }, e.prototype.bezierCurveTo = function (t, e, r, i, n, o) { return this._initCurve(), sr.curveTo(t, e, r, i, n, o, this.currentPath.points), this }, e.prototype.arcTo = function (t, e, r, i, n) { this._initCurve(t, e); var o = this.currentPath.points, s = or.curveTo(t, e, r, i, n, o); if (s) { var a = s.cx, u = s.cy, h = s.radius, l = s.startAngle, c = s.endAngle, d = s.anticlockwise; this.arc(a, u, h, l, c, d) } return this }, e.prototype.arc = function (t, e, r, i, n, o) { if (void 0 === o && (o = !1), i === n) return this; !o && n <= i ? n += H._b : o && i <= n && (i += H._b); var s = n - i; if (0 === s) return this; var a = t + Math.cos(i) * r, u = e + Math.sin(i) * r, h = this._geometry.closePointEps, l = this.currentPath ? this.currentPath.points : null; if (l) { var c = Math.abs(l[l.length - 2] - a), d = Math.abs(l[l.length - 1] - u); c < h && d < h || l.push(a, u) } else this.moveTo(a, u), l = this.currentPath.points; return or.arc(a, u, t, e, r, i, n, o, l), this }, e.prototype.beginFill = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 1), this.beginTextureFill({ texture: M.xE.WHITE, color: t, alpha: e }) }, e.prototype.beginTextureFill = function (t) { t = Object.assign({ texture: M.xE.WHITE, color: 16777215, alpha: 1, matrix: null }, t), this.currentPath && this.startPoly(); var e = t.alpha > 0; return e ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._fillStyle, { visible: e }, t)) : this._fillStyle.reset(), this }, e.prototype.endFill = function () { return this.finishPoly(), this._fillStyle.reset(), this }, e.prototype.drawRect = function (t, e, r, i) { return this.drawShape(new H.Ae(t, e, r, i)) }, e.prototype.drawRoundedRect = function (t, e, r, i, n) { return this.drawShape(new H.c9(t, e, r, i, n)) }, e.prototype.drawCircle = function (t, e, r) { return this.drawShape(new H.Cd(t, e, r)) }, e.prototype.drawEllipse = function (t, e, r, i) { return this.drawShape(new H.Pj(t, e, r, i)) }, e.prototype.drawPolygon = function () { for (var t, e = arguments, r = [], i = 0; i < arguments.length; i++)r[i] = e[i]; var n = !0, o = r[0]; o.points ? (n = o.closeStroke, t = o.points) : t = Array.isArray(r[0]) ? r[0] : r; var s = new H.mg(t); return s.closeStroke = n, this.drawShape(s), this }, e.prototype.drawShape = function (t) { return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this }, e.prototype.clear = function () { return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this }, e.prototype.isFastRect = function () { var t = this._geometry.graphicsData; return 1 === t.length && t[0].shape.type === H.HS.RECT && !t[0].matrix && !t[0].holes.length && !(t[0].lineStyle.visible && t[0].lineStyle.width) }, e.prototype._render = function (t) { this.finishPoly(); var e = this._geometry; e.updateBatches(), e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(), this._renderBatched(t)) : (t.batch.flush(), this._renderDirect(t)) }, e.prototype._populateBatches = function () { var t = this._geometry, e = this.blendMode, r = t.batches.length; this.batchTint = -1, this._transformID = -1, this.batchDirty = t.batchDirty, this.batches.length = r, this.vertexData = new Float32Array(t.points); for (var i = 0; i < r; i++) { var n = t.batches[i], o = n.style.color, s = new Float32Array(this.vertexData.buffer, 4 * n.attribStart * 2, 2 * n.attribSize), a = new Float32Array(t.uvsFloat32.buffer, 4 * n.attribStart * 2, 2 * n.attribSize), u = new Uint16Array(t.indicesUint16.buffer, 2 * n.start, n.size), h = { vertexData: s, blendMode: e, indices: u, uvs: a, _batchRGB: (0, I.hex2rgb)(o), _tintRGB: o, _texture: n.style.texture, alpha: n.style.alpha, worldAlpha: 1 }; this.batches[i] = h } }, e.prototype._renderBatched = function (t) { if (this.batches.length) { t.batch.setObjectRenderer(t.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints(); for (var e = 0, r = this.batches.length; e < r; e++) { var i = this.batches[e]; i.worldAlpha = this.worldAlpha * i.alpha, t.plugins[this.pluginName].render(i) } } }, e.prototype._renderDirect = function (t) { var e = this._resolveDirectShader(t), r = this._geometry, i = this.tint, n = this.worldAlpha, o = e.uniforms, s = r.drawCalls; o.translationMatrix = this.transform.worldTransform, o.tint[0] = (i >> 16 & 255) / 255 * n, o.tint[1] = (i >> 8 & 255) / 255 * n, o.tint[2] = (255 & i) / 255 * n, o.tint[3] = n, t.shader.bind(e), t.geometry.bind(r, e), t.state.set(this.state); for (var a = 0, u = s.length; a < u; a++)this._renderDrawCallDirect(t, r.drawCalls[a]) }, e.prototype._renderDrawCallDirect = function (t, e) { for (var r = e.texArray, i = e.type, n = e.size, o = e.start, s = r.count, a = 0; a < s; a++)t.texture.bind(r.elements[a], a); t.geometry.draw(i, n, o) }, e.prototype._resolveDirectShader = function (t) { var e = this.shader, r = this.pluginName; if (!e) { if (!gr[r]) { for (var i = t.plugins[r].MAX_TEXTURES, n = new Int32Array(i), o = 0; o < i; o++)n[o] = o; var s = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new H.y3, default: M.oo.from({ uSamplers: n }, !0) }, a = t.plugins[r]._shader.program; gr[r] = new M.ex(a, s) } e = gr[r] } return e }, e.prototype._calculateBounds = function () { this.finishPoly(); var t = this._geometry; if (t.graphicsData.length) { var e = t.bounds, r = e.minX, i = e.minY, n = e.maxX, o = e.maxY; this._bounds.addFrame(this.transform, r, i, n, o) } }, e.prototype.containsPoint = function (t) { return this.worldTransform.applyInverse(t, e._TEMP_POINT), this._geometry.containsPoint(e._TEMP_POINT) }, e.prototype.calculateTints = function () { if (this.batchTint !== this.tint) { this.batchTint = this.tint; for (var t = (0, I.hex2rgb)(this.tint, mr), e = 0; e < this.batches.length; e++) { var r = this.batches[e], i = r._batchRGB, n = t[0] * i[0] * 255, o = t[1] * i[1] * 255, s = t[2] * i[2] * 255, a = (n << 16) + (o << 8) + (0 | s); r._tintRGB = (a >> 16) + (65280 & a) + ((255 & a) << 16) } } }, e.prototype.calculateVertices = function () { var t = this.transform._worldID; if (this._transformID !== t) { this._transformID = t; for (var e = this.transform.worldTransform, r = e.a, i = e.b, n = e.c, o = e.d, s = e.tx, a = e.ty, u = this._geometry.points, h = this.vertexData, l = 0, c = 0; c < u.length; c += 2) { var d = u[c], f = u[c + 1]; h[l++] = r * d + n * f + s, h[l++] = o * f + i * d + a } } }, e.prototype.closePath = function () { var t = this.currentPath; return t && (t.closeStroke = !0, this.finishPoly()), this }, e.prototype.setMatrix = function (t) { return this._matrix = t, this }, e.prototype.beginHole = function () { return this.finishPoly(), this._holeMode = !0, this }, e.prototype.endHole = function () { return this.finishPoly(), this._holeMode = !1, this }, e.prototype.destroy = function (e) { this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, t.prototype.destroy.call(this, e) }, e.nextRoundedRectBehavior = !1, e._TEMP_POINT = new H.E9, e }(P.W2), yr = { buildPoly: We, buildCircle: $e, buildRectangle: qe, buildRoundedRectangle: Je, buildLine: ir, ArcUtils: or, BezierUtils: sr, QuadraticUtils: ar, BatchPart: ur, FILL_COMMANDS: hr, BATCH_POOL: lr, DRAW_CALL_POOL: cr }, br = function (t, e) { return br = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, br(t, e) }; function xr(t, e) { function r() { this.constructor = t } br(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var Tr, Er = new H.E9, Sr = new Uint16Array([0, 1, 2, 0, 2, 3]), wr = function (t) { function e(e) { var r = t.call(this) || this; return r._anchor = new H.AB(r._onAnchorUpdate, r, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), r._texture = null, r._width = 0, r._height = 0, r._tint = null, r._tintRGB = null, r.tint = 16777215, r.blendMode = et.T$.NORMAL, r._cachedTint = 16777215, r.uvs = null, r.texture = e || M.xE.EMPTY, r.vertexData = new Float32Array(8), r.vertexTrimmedData = null, r._transformID = -1, r._textureID = -1, r._transformTrimmedID = -1, r._textureTrimmedID = -1, r.indices = Sr, r.pluginName = "batch", r.isSprite = !0, r._roundPixels = Ft.Xd.ROUND_PIXELS, r } return xr(e, t), e.prototype._onTextureUpdate = function () { this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = (0, I.sign)(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = (0, I.sign)(this.scale.y) * this._height / this._texture.orig.height) }, e.prototype._onAnchorUpdate = function () { this._transformID = -1, this._transformTrimmedID = -1 }, e.prototype.calculateVertices = function () { var t = this._texture; if (this._transformID !== this.transform._worldID || this._textureID !== t._updateID) { this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID; var e = this.transform.worldTransform, r = e.a, i = e.b, n = e.c, o = e.d, s = e.tx, a = e.ty, u = this.vertexData, h = t.trim, l = t.orig, c = this._anchor, d = 0, f = 0, p = 0, _ = 0; if (h ? (f = h.x - c._x * l.width, d = f + h.width, _ = h.y - c._y * l.height, p = _ + h.height) : (f = -c._x * l.width, d = f + l.width, _ = -c._y * l.height, p = _ + l.height), u[0] = r * f + n * _ + s, u[1] = o * _ + i * f + a, u[2] = r * d + n * _ + s, u[3] = o * _ + i * d + a, u[4] = r * d + n * p + s, u[5] = o * p + i * d + a, u[6] = r * f + n * p + s, u[7] = o * p + i * f + a, this._roundPixels) for (var m = Ft.Xd.RESOLUTION, g = 0; g < u.length; ++g)u[g] = Math.round((u[g] * m | 0) / m) } }, e.prototype.calculateTrimmedVertices = function () { if (this.vertexTrimmedData) { if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return } else this.vertexTrimmedData = new Float32Array(8); this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID; var t = this._texture, e = this.vertexTrimmedData, r = t.orig, i = this._anchor, n = this.transform.worldTransform, o = n.a, s = n.b, a = n.c, u = n.d, h = n.tx, l = n.ty, c = -i._x * r.width, d = c + r.width, f = -i._y * r.height, p = f + r.height; e[0] = o * c + a * f + h, e[1] = u * f + s * c + l, e[2] = o * d + a * f + h, e[3] = u * f + s * d + l, e[4] = o * d + a * p + h, e[5] = u * p + s * d + l, e[6] = o * c + a * p + h, e[7] = u * p + s * c + l }, e.prototype._render = function (t) { this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this) }, e.prototype._calculateBounds = function () { var t = this._texture.trim, e = this._texture.orig; !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData)) }, e.prototype.getLocalBounds = function (e) { return 0 === this.children.length ? (this._localBounds || (this._localBounds = new P.YZ), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new H.Ae), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e) }, e.prototype.containsPoint = function (t) { this.worldTransform.applyInverse(t, Er); var e = this._texture.orig.width, r = this._texture.orig.height, i = -e * this.anchor.x, n = 0; return Er.x >= i && Er.x < i + e && (n = -r * this.anchor.y, Er.y >= n && Er.y < n + r) }, e.prototype.destroy = function (e) { t.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null; var r = "boolean" === typeof e ? e : e && e.texture; if (r) { var i = "boolean" === typeof e ? e : e && e.baseTexture; this._texture.destroy(!!i) } this._texture = null }, e.from = function (t, r) { var i = t instanceof M.xE ? t : M.xE.from(t, r); return new e(i) }, Object.defineProperty(e.prototype, "roundPixels", { get: function () { return this._roundPixels }, set: function (t) { this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "width", { get: function () { return Math.abs(this.scale.x) * this._texture.orig.width }, set: function (t) { var e = (0, I.sign)(this.scale.x) || 1; this.scale.x = e * t / this._texture.orig.width, this._width = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return Math.abs(this.scale.y) * this._texture.orig.height }, set: function (t) { var e = (0, I.sign)(this.scale.y) || 1; this.scale.y = e * t / this._texture.orig.height, this._height = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "anchor", { get: function () { return this._anchor }, set: function (t) { this._anchor.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tint", { get: function () { return this._tint }, set: function (t) { this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "texture", { get: function () { return this._texture }, set: function (t) { this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || M.xE.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this))) }, enumerable: !1, configurable: !0 }), e }(P.W2), Ar = function (t, e) { return Ar = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, Ar(t, e) }; function Rr(t, e) { function r() { this.constructor = t } Ar(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } (function (t) { t[t["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL", t[t["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL" })(Tr || (Tr = {})); var Or = { align: "left", breakWords: !1, dropShadow: !1, dropShadowAlpha: 1, dropShadowAngle: Math.PI / 6, dropShadowBlur: 0, dropShadowColor: "black", dropShadowDistance: 5, fill: "black", fillGradientType: Tr.LINEAR_VERTICAL, fillGradientStops: [], fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", letterSpacing: 0, lineHeight: 0, lineJoin: "miter", miterLimit: 10, padding: 0, stroke: "black", strokeThickness: 0, textBaseline: "alphabetic", trim: !1, whiteSpace: "pre", wordWrap: !1, wordWrapWidth: 100, leading: 0 }, Ir = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"], Pr = function () { function t(t) { this.styleID = 0, this.reset(), Lr(this, t, t) } return t.prototype.clone = function () { var e = {}; return Lr(e, this, Or), new t(e) }, t.prototype.reset = function () { Lr(this, Or, Or) }, Object.defineProperty(t.prototype, "align", { get: function () { return this._align }, set: function (t) { this._align !== t && (this._align = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "breakWords", { get: function () { return this._breakWords }, set: function (t) { this._breakWords !== t && (this._breakWords = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadow", { get: function () { return this._dropShadow }, set: function (t) { this._dropShadow !== t && (this._dropShadow = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowAlpha", { get: function () { return this._dropShadowAlpha }, set: function (t) { this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowAngle", { get: function () { return this._dropShadowAngle }, set: function (t) { this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowBlur", { get: function () { return this._dropShadowBlur }, set: function (t) { this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowColor", { get: function () { return this._dropShadowColor }, set: function (t) { var e = Cr(t); this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dropShadowDistance", { get: function () { return this._dropShadowDistance }, set: function (t) { this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fill", { get: function () { return this._fill }, set: function (t) { var e = Cr(t); this._fill !== e && (this._fill = e, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fillGradientType", { get: function () { return this._fillGradientType }, set: function (t) { this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fillGradientStops", { get: function () { return this._fillGradientStops }, set: function (t) { Dr(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontFamily", { get: function () { return this._fontFamily }, set: function (t) { this.fontFamily !== t && (this._fontFamily = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontSize", { get: function () { return this._fontSize }, set: function (t) { this._fontSize !== t && (this._fontSize = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontStyle", { get: function () { return this._fontStyle }, set: function (t) { this._fontStyle !== t && (this._fontStyle = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontVariant", { get: function () { return this._fontVariant }, set: function (t) { this._fontVariant !== t && (this._fontVariant = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "fontWeight", { get: function () { return this._fontWeight }, set: function (t) { this._fontWeight !== t && (this._fontWeight = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "letterSpacing", { get: function () { return this._letterSpacing }, set: function (t) { this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "lineHeight", { get: function () { return this._lineHeight }, set: function (t) { this._lineHeight !== t && (this._lineHeight = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "leading", { get: function () { return this._leading }, set: function (t) { this._leading !== t && (this._leading = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "lineJoin", { get: function () { return this._lineJoin }, set: function (t) { this._lineJoin !== t && (this._lineJoin = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "miterLimit", { get: function () { return this._miterLimit }, set: function (t) { this._miterLimit !== t && (this._miterLimit = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "padding", { get: function () { return this._padding }, set: function (t) { this._padding !== t && (this._padding = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "stroke", { get: function () { return this._stroke }, set: function (t) { var e = Cr(t); this._stroke !== e && (this._stroke = e, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "strokeThickness", { get: function () { return this._strokeThickness }, set: function (t) { this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "textBaseline", { get: function () { return this._textBaseline }, set: function (t) { this._textBaseline !== t && (this._textBaseline = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "trim", { get: function () { return this._trim }, set: function (t) { this._trim !== t && (this._trim = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "whiteSpace", { get: function () { return this._whiteSpace }, set: function (t) { this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "wordWrap", { get: function () { return this._wordWrap }, set: function (t) { this._wordWrap !== t && (this._wordWrap = t, this.styleID++) }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "wordWrapWidth", { get: function () { return this._wordWrapWidth }, set: function (t) { this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++) }, enumerable: !1, configurable: !0 }), t.prototype.toFontString = function () { var t = "number" === typeof this.fontSize ? this.fontSize + "px" : this.fontSize, e = this.fontFamily; Array.isArray(this.fontFamily) || (e = this.fontFamily.split(",")); for (var r = e.length - 1; r >= 0; r--) { var i = e[r].trim(); !/([\"\'])[^\'\"]+\1/.test(i) && Ir.indexOf(i) < 0 && (i = '"' + i + '"'), e[r] = i } return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",") }, t }(); function Mr(t) { return "number" === typeof t ? (0, I.hex2string)(t) : ("string" === typeof t && 0 === t.indexOf("0x") && (t = t.replace("0x", "#")), t) } function Cr(t) { if (Array.isArray(t)) { for (var e = 0; e < t.length; ++e)t[e] = Mr(t[e]); return t } return Mr(t) } function Dr(t, e) { if (!Array.isArray(t) || !Array.isArray(e)) return !1; if (t.length !== e.length) return !1; for (var r = 0; r < t.length; ++r)if (t[r] !== e[r]) return !1; return !0 } function Lr(t, e, r) { for (var i in r) Array.isArray(e[i]) ? t[i] = e[i].slice() : t[i] = e[i] } var Fr = { willReadFrequently: !0 }, Nr = function () { function t(t, e, r, i, n, o, s, a, u) { this.text = t, this.style = e, this.width = r, this.height = i, this.lines = n, this.lineWidths = o, this.lineHeight = s, this.maxLineWidth = a, this.fontProperties = u } return t.measureText = function (e, r, i, n) { void 0 === n && (n = t._canvas), i = void 0 === i || null === i ? r.wordWrap : i; var o = r.toFontString(), s = t.measureFont(o); 0 === s.fontSize && (s.fontSize = r.fontSize, s.ascent = r.fontSize); var a = n.getContext("2d", Fr); a.font = o; for (var u = i ? t.wordWrap(e, r, n) : e, h = u.split(/(?:\r\n|\r|\n)/), l = new Array(h.length), c = 0, d = 0; d < h.length; d++) { var f = a.measureText(h[d]).width + (h[d].length - 1) * r.letterSpacing; l[d] = f, c = Math.max(c, f) } var p = c + r.strokeThickness; r.dropShadow && (p += r.dropShadowDistance); var _ = r.lineHeight || s.fontSize + r.strokeThickness, m = Math.max(_, s.fontSize + r.strokeThickness) + (h.length - 1) * (_ + r.leading); return r.dropShadow && (m += r.dropShadowDistance), new t(e, r, p, m, h, l, _ + r.leading, c, s) }, t.wordWrap = function (e, r, i) { void 0 === i && (i = t._canvas); for (var n = i.getContext("2d", Fr), o = 0, s = "", a = "", u = Object.create(null), h = r.letterSpacing, l = r.whiteSpace, c = t.collapseSpaces(l), d = t.collapseNewlines(l), f = !c, p = r.wordWrapWidth + h, _ = t.tokenize(e), m = 0; m < _.length; m++) { var g = _[m]; if (t.isNewline(g)) { if (!d) { a += t.addLine(s), f = !c, s = "", o = 0; continue } g = " " } if (c) { var v = t.isBreakingSpace(g), y = t.isBreakingSpace(s[s.length - 1]); if (v && y) continue } var b = t.getFromCache(g, h, u, n); if (b > p) if ("" !== s && (a += t.addLine(s), s = "", o = 0), t.canBreakWords(g, r.breakWords)) for (var x = t.wordWrapSplit(g), T = 0; T < x.length; T++) { var E = x[T], S = 1; while (x[T + S]) { var w = x[T + S], A = E[E.length - 1]; if (t.canBreakChars(A, w, g, T, r.breakWords)) break; E += w, S++ } T += E.length - 1; var R = t.getFromCache(E, h, u, n); R + o > p && (a += t.addLine(s), f = !1, s = "", o = 0), s += E, o += R } else { s.length > 0 && (a += t.addLine(s), s = "", o = 0); var O = m === _.length - 1; a += t.addLine(g, !O), f = !1, s = "", o = 0 } else b + o > p && (f = !1, a += t.addLine(s), s = "", o = 0), (s.length > 0 || !t.isBreakingSpace(g) || f) && (s += g, o += b) } return a += t.addLine(s, !1), a }, t.addLine = function (e, r) { return void 0 === r && (r = !0), e = t.trimRight(e), e = r ? e + "\n" : e, e }, t.getFromCache = function (t, e, r, i) { var n = r[t]; if ("number" !== typeof n) { var o = t.length * e; n = i.measureText(t).width + o, r[t] = n } return n }, t.collapseSpaces = function (t) { return "normal" === t || "pre-line" === t }, t.collapseNewlines = function (t) { return "normal" === t }, t.trimRight = function (e) { if ("string" !== typeof e) return ""; for (var r = e.length - 1; r >= 0; r--) { var i = e[r]; if (!t.isBreakingSpace(i)) break; e = e.slice(0, -1) } return e }, t.isNewline = function (e) { return "string" === typeof e && t._newlines.indexOf(e.charCodeAt(0)) >= 0 }, t.isBreakingSpace = function (e, r) { return "string" === typeof e && t._breakingSpaces.indexOf(e.charCodeAt(0)) >= 0 }, t.tokenize = function (e) { var r = [], i = ""; if ("string" !== typeof e) return r; for (var n = 0; n < e.length; n++) { var o = e[n], s = e[n + 1]; t.isBreakingSpace(o, s) || t.isNewline(o) ? ("" !== i && (r.push(i), i = ""), r.push(o)) : i += o } return "" !== i && r.push(i), r }, t.canBreakWords = function (t, e) { return e }, t.canBreakChars = function (t, e, r, i, n) { return !0 }, t.wordWrapSplit = function (t) { return t.split("") }, t.measureFont = function (e) { if (t._fonts[e]) return t._fonts[e]; var r = { ascent: 0, descent: 0, fontSize: 0 }, i = t._canvas, n = t._context; n.font = e; var o = t.METRICS_STRING + t.BASELINE_SYMBOL, s = Math.ceil(n.measureText(o).width), a = Math.ceil(n.measureText(t.BASELINE_SYMBOL).width), u = Math.ceil(t.HEIGHT_MULTIPLIER * a); a = a * t.BASELINE_MULTIPLIER | 0, i.width = s, i.height = u, n.fillStyle = "#f00", n.fillRect(0, 0, s, u), n.font = e, n.textBaseline = "alphabetic", n.fillStyle = "#000", n.fillText(o, 0, a); var h = n.getImageData(0, 0, s, u).data, l = h.length, c = 4 * s, d = 0, f = 0, p = !1; for (d = 0; d < a; ++d) { for (var _ = 0; _ < c; _ += 4)if (255 !== h[f + _]) { p = !0; break } if (p) break; f += c } for (r.ascent = a - d, f = l - c, p = !1, d = u; d > a; --d) { for (_ = 0; _ < c; _ += 4)if (255 !== h[f + _]) { p = !0; break } if (p) break; f -= c } return r.descent = d - a, r.fontSize = r.ascent + r.descent, t._fonts[e] = r, r }, t.clearMetrics = function (e) { void 0 === e && (e = ""), e ? delete t._fonts[e] : t._fonts = {} }, Object.defineProperty(t, "_canvas", { get: function () { if (!t.__canvas) { var e = void 0; try { var r = new OffscreenCanvas(0, 0), i = r.getContext("2d", Fr); if (i && i.measureText) return t.__canvas = r, r; e = Ft.Xd.ADAPTER.createCanvas() } catch (n) { e = Ft.Xd.ADAPTER.createCanvas() } e.width = e.height = 10, t.__canvas = e } return t.__canvas }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "_context", { get: function () { return t.__context || (t.__context = t._canvas.getContext("2d", Fr)), t.__context }, enumerable: !1, configurable: !0 }), t }(); Nr._fonts = {}, Nr.METRICS_STRING = "|ÃqÃ", Nr.BASELINE_SYMBOL = "M", Nr.BASELINE_MULTIPLIER = 1.4, Nr.HEIGHT_MULTIPLIER = 2, Nr._newlines = [10, 13], Nr._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288]; var Br = { texture: !0, children: !1, baseTexture: !0 }, Ur = function (t) { function e(e, r, i) { var n = this, o = !1; i || (i = Ft.Xd.ADAPTER.createCanvas(), o = !0), i.width = 3, i.height = 3; var s = M.xE.from(i); return s.orig = new H.Ae, s.trim = new H.Ae, n = t.call(this, s) || this, n._ownCanvas = o, n.canvas = i, n.context = i.getContext("2d", { willReadFrequently: !0 }), n._resolution = Ft.Xd.RESOLUTION, n._autoResolution = !0, n._text = null, n._style = null, n._styleListener = null, n._font = "", n.text = e, n.style = r, n.localStyleID = -1, n } return Rr(e, t), e.prototype.updateText = function (t) { var r = this._style; if (this.localStyleID !== r.styleID && (this.dirty = !0, this.localStyleID = r.styleID), this.dirty || !t) { this._font = this._style.toFontString(); var i, n, o = this.context, s = Nr.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), a = s.width, u = s.height, h = s.lines, l = s.lineHeight, c = s.lineWidths, d = s.maxLineWidth, f = s.fontProperties; this.canvas.width = Math.ceil(Math.ceil(Math.max(1, a) + 2 * r.padding) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, u) + 2 * r.padding) * this._resolution), o.scale(this._resolution, this._resolution), o.clearRect(0, 0, this.canvas.width, this.canvas.height), o.font = this._font, o.lineWidth = r.strokeThickness, o.textBaseline = r.textBaseline, o.lineJoin = r.lineJoin, o.miterLimit = r.miterLimit; for (var p = r.dropShadow ? 2 : 1, _ = 0; _ < p; ++_) { var m = r.dropShadow && 0 === _, g = m ? Math.ceil(Math.max(1, u) + 2 * r.padding) : 0, v = g * this._resolution; if (m) { o.fillStyle = "black", o.strokeStyle = "black"; var y = r.dropShadowColor, b = (0, I.hex2rgb)("number" === typeof y ? y : (0, I.string2hex)(y)), x = r.dropShadowBlur * this._resolution, T = r.dropShadowDistance * this._resolution; o.shadowColor = "rgba(" + 255 * b[0] + "," + 255 * b[1] + "," + 255 * b[2] + "," + r.dropShadowAlpha + ")", o.shadowBlur = x, o.shadowOffsetX = Math.cos(r.dropShadowAngle) * T, o.shadowOffsetY = Math.sin(r.dropShadowAngle) * T + v } else o.fillStyle = this._generateFillStyle(r, h, s), o.strokeStyle = r.stroke, o.shadowColor = "black", o.shadowBlur = 0, o.shadowOffsetX = 0, o.shadowOffsetY = 0; var E = (l - f.fontSize) / 2; (!e.nextLineHeightBehavior || l - f.fontSize < 0) && (E = 0); for (var S = 0; S < h.length; S++)i = r.strokeThickness / 2, n = r.strokeThickness / 2 + S * l + f.ascent + E, "right" === r.align ? i += d - c[S] : "center" === r.align && (i += (d - c[S]) / 2), r.stroke && r.strokeThickness && this.drawLetterSpacing(h[S], i + r.padding, n + r.padding - g, !0), r.fill && this.drawLetterSpacing(h[S], i + r.padding, n + r.padding - g) } this.updateTexture() } }, e.prototype.drawLetterSpacing = function (t, r, i, n) { void 0 === n && (n = !1); var o = this._style, s = o.letterSpacing, a = e.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype); if (0 === s || a) return a && (this.context.letterSpacing = s, this.context.textLetterSpacing = s), void (n ? this.context.strokeText(t, r, i) : this.context.fillText(t, r, i)); for (var u = r, h = Array.from ? Array.from(t) : t.split(""), l = this.context.measureText(t).width, c = 0, d = 0; d < h.length; ++d) { var f = h[d]; n ? this.context.strokeText(f, u, i) : this.context.fillText(f, u, i); for (var p = "", _ = d + 1; _ < h.length; ++_)p += h[_]; c = this.context.measureText(p).width, u += l - c + s, l = c } }, e.prototype.updateTexture = function () { var t = this.canvas; if (this._style.trim) { var e = (0, I.trimCanvas)(t); e.data && (t.width = e.width, t.height = e.height, this.context.putImageData(e.data, 0, 0)) } var r = this._texture, i = this._style, n = i.trim ? 0 : i.padding, o = r.baseTexture; r.trim.width = r._frame.width = t.width / this._resolution, r.trim.height = r._frame.height = t.height / this._resolution, r.trim.x = -n, r.trim.y = -n, r.orig.width = r._frame.width - 2 * n, r.orig.height = r._frame.height - 2 * n, this._onTextureUpdate(), o.setRealSize(t.width, t.height, this._resolution), r.updateUvs(), this.dirty = !1 }, e.prototype._render = function (e) { this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), t.prototype._render.call(this, e) }, e.prototype.updateTransform = function () { this.updateText(!0), t.prototype.updateTransform.call(this) }, e.prototype.getBounds = function (e, r) { return this.updateText(!0), -1 === this._textureID && (e = !1), t.prototype.getBounds.call(this, e, r) }, e.prototype.getLocalBounds = function (e) { return this.updateText(!0), t.prototype.getLocalBounds.call(this, e) }, e.prototype._calculateBounds = function () { this.calculateVertices(), this._bounds.addQuad(this.vertexData) }, e.prototype._generateFillStyle = function (t, e, r) { var i, n = t.fill; if (!Array.isArray(n)) return n; if (1 === n.length) return n[0]; var o = t.dropShadow ? t.dropShadowDistance : 0, s = t.padding || 0, a = this.canvas.width / this._resolution - o - 2 * s, u = this.canvas.height / this._resolution - o - 2 * s, h = n.slice(), l = t.fillGradientStops.slice(); if (!l.length) for (var c = h.length + 1, d = 1; d < c; ++d)l.push(d / c); if (h.unshift(n[0]), l.unshift(0), h.push(n[n.length - 1]), l.push(1), t.fillGradientType === Tr.LINEAR_VERTICAL) { i = this.context.createLinearGradient(a / 2, s, a / 2, u + s); var f = r.fontProperties.fontSize + t.strokeThickness; for (d = 0; d < e.length; d++) { var p = r.lineHeight * (d - 1) + f, _ = r.lineHeight * d, m = _; d > 0 && p > _ && (m = (_ + p) / 2); var g = _ + f, v = r.lineHeight * (d + 1), y = g; d + 1 < e.length && v < g && (y = (g + v) / 2); for (var b = (y - m) / u, x = 0; x < h.length; x++) { var T = 0; T = "number" === typeof l[x] ? l[x] : x / h.length; var E = Math.min(1, Math.max(0, m / u + T * b)); E = Number(E.toFixed(5)), i.addColorStop(E, h[x]) } } } else { i = this.context.createLinearGradient(s, u / 2, a + s, u / 2); var S = h.length + 1, w = 1; for (d = 0; d < h.length; d++) { var A = void 0; A = "number" === typeof l[d] ? l[d] : w / S, i.addColorStop(A, h[d]), w++ } } return i }, e.prototype.destroy = function (e) { "boolean" === typeof e && (e = { children: e }), e = Object.assign({}, Br, e), t.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null }, Object.defineProperty(e.prototype, "width", { get: function () { return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width }, set: function (t) { this.updateText(!0); var e = (0, I.sign)(this.scale.x) || 1; this.scale.x = e * t / this._texture.orig.width, this._width = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height }, set: function (t) { this.updateText(!0); var e = (0, I.sign)(this.scale.y) || 1; this.scale.y = e * t / this._texture.orig.height, this._height = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "style", { get: function () { return this._style }, set: function (t) { t = t || {}, this._style = t instanceof Pr ? t : new Pr(t), this.localStyleID = -1, this.dirty = !0 }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "text", { get: function () { return this._text }, set: function (t) { t = String(null === t || void 0 === t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "resolution", { get: function () { return this._resolution }, set: function (t) { this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), e.nextLineHeightBehavior = !1, e.experimentalLetterSpacing = !1, e }(wr);
        /*!
         * @pixi/prepare - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * @pixi/prepare is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        Ft.Xd.UPLOADS_PER_FRAME = 4;
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.
        
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
        
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        var kr = function (t, e) { return kr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, kr(t, e) }; function Gr(t, e) { function r() { this.constructor = t } kr(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var Xr = function () { function t(t) { this.maxItemsPerFrame = t, this.itemsLeft = 0 } return t.prototype.beginFrame = function () { this.itemsLeft = this.maxItemsPerFrame }, t.prototype.allowedToUpload = function () { return this.itemsLeft-- > 0 }, t }(); function jr(t, e) { var r = !1; if (t && t._textures && t._textures.length) for (var i = 0; i < t._textures.length; i++)if (t._textures[i] instanceof M.xE) { var n = t._textures[i].baseTexture; -1 === e.indexOf(n) && (e.push(n), r = !0) } return r } function Hr(t, e) { if (t.baseTexture instanceof M.VL) { var r = t.baseTexture; return -1 === e.indexOf(r) && e.push(r), !0 } return !1 } function Vr(t, e) { if (t._texture && t._texture instanceof M.xE) { var r = t._texture.baseTexture; return -1 === e.indexOf(r) && e.push(r), !0 } return !1 } function zr(t, e) { return e instanceof Ur && (e.updateText(!0), !0) } function Yr(t, e) { if (e instanceof Pr) { var r = e.toFontString(); return Nr.measureFont(r), !0 } return !1 } function Wr(t, e) { if (t instanceof Ur) { -1 === e.indexOf(t.style) && e.push(t.style), -1 === e.indexOf(t) && e.push(t); var r = t._texture.baseTexture; return -1 === e.indexOf(r) && e.push(r), !0 } return !1 } function $r(t, e) { return t instanceof Pr && (-1 === e.indexOf(t) && e.push(t), !0) } var qr = function () { function t(t) { var e = this; this.limiter = new Xr(Ft.Xd.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function () { e.queue && e.prepareItems() }, this.registerFindHook(Wr), this.registerFindHook($r), this.registerFindHook(jr), this.registerFindHook(Hr), this.registerFindHook(Vr), this.registerUploadHook(zr), this.registerUploadHook(Yr) } return t.prototype.upload = function (t, e) { var r = this; return "function" === typeof t && (e = t, t = null), e && (0, I.deprecation)("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead."), new Promise((function (i) { t && r.add(t); var n = function () { null === e || void 0 === e || e(), i() }; r.queue.length ? (r.completes.push(n), r.ticking || (r.ticking = !0, V.vB.system.addOnce(r.tick, r, V.uF.UTILITY))) : n() })) }, t.prototype.tick = function () { setTimeout(this.delayedTick, 0) }, t.prototype.prepareItems = function () { this.limiter.beginFrame(); while (this.queue.length && this.limiter.allowedToUpload()) { var t = this.queue[0], e = !1; if (t && !t._destroyed) for (var r = 0, i = this.uploadHooks.length; r < i; r++)if (this.uploadHooks[r](this.uploadHookHelper, t)) { this.queue.shift(), e = !0; break } e || this.queue.shift() } if (this.queue.length) V.vB.system.addOnce(this.tick, this, V.uF.UTILITY); else { this.ticking = !1; var n = this.completes.slice(0); this.completes.length = 0; for (r = 0, i = n.length; r < i; r++)n[r]() } }, t.prototype.registerFindHook = function (t) { return t && this.addHooks.push(t), this }, t.prototype.registerUploadHook = function (t) { return t && this.uploadHooks.push(t), this }, t.prototype.add = function (t) { for (var e = 0, r = this.addHooks.length; e < r; e++)if (this.addHooks[e](t, this.queue)) break; if (t instanceof P.W2) for (e = t.children.length - 1; e >= 0; e--)this.add(t.children[e]); return this }, t.prototype.destroy = function () { this.ticking && V.vB.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null }, t }(); function Kr(t, e) { return e instanceof M.VL && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e), !0) } function Zr(t, e) { if (!(e instanceof vr)) return !1; var r = e.geometry; e.finishPoly(), r.updateBatches(); for (var i = r.batches, n = 0; n < i.length; n++) { var o = i[n].style.texture; o && Kr(t, o.baseTexture) } return r.batchable || t.geometry.bind(r, e._resolveDirectShader(t)), !0 } function Jr(t, e) { return t instanceof vr && (e.push(t), !0) } var Qr = function (t) { function e(e) { var r = t.call(this, e) || this; return r.uploadHookHelper = r.renderer, r.registerFindHook(Jr), r.registerUploadHook(Kr), r.registerUploadHook(Zr), r } return Gr(e, t), e.extension = { name: "prepare", type: M.nw.RendererPlugin }, e }(qr), ti = function () { function t(t) { this.maxMilliseconds = t, this.frameStart = 0 } return t.prototype.beginFrame = function () { this.frameStart = Date.now() }, t.prototype.allowedToUpload = function () { return Date.now() - this.frameStart < this.maxMilliseconds }, t }(), ei = function () { function t(t, e, r) { void 0 === r && (r = null), this.linkedSheets = [], this._texture = t instanceof M.xE ? t : null, this.baseTexture = t instanceof M.VL ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e; var i = this.baseTexture.resource; this.resolution = this._updateResolution(r || (i ? i.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null } return t.prototype._updateResolution = function (t) { void 0 === t && (t = null); var e = this.data.meta.scale, r = (0, I.getResolutionOfUrl)(t, null); return null === r && (r = void 0 !== e ? parseFloat(e) : 1), 1 !== r && this.baseTexture.setResolution(r), r }, t.prototype.parse = function (e) { var r = this; return e && (0, I.deprecation)("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead."), new Promise((function (i) { r._callback = function (t) { null === e || void 0 === e || e(t), i(t) }, r._batchIndex = 0, r._frameKeys.length <= t.BATCH_SIZE ? (r._processFrames(0), r._processAnimations(), r._parseComplete()) : r._nextBatch() })) }, t.prototype._processFrames = function (e) { var r = e, i = t.BATCH_SIZE; while (r - e < i && r < this._frameKeys.length) { var n = this._frameKeys[r], o = this._frames[n], s = o.frame; if (s) { var a = null, u = null, h = !1 !== o.trimmed && o.sourceSize ? o.sourceSize : o.frame, l = new H.Ae(0, 0, Math.floor(h.w) / this.resolution, Math.floor(h.h) / this.resolution); a = o.rotated ? new H.Ae(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.h) / this.resolution, Math.floor(s.w) / this.resolution) : new H.Ae(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution), !1 !== o.trimmed && o.spriteSourceSize && (u = new H.Ae(Math.floor(o.spriteSourceSize.x) / this.resolution, Math.floor(o.spriteSourceSize.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution)), this.textures[n] = new M.xE(this.baseTexture, a, l, u, o.rotated ? 2 : 0, o.anchor), M.xE.addToCache(this.textures[n], n) } r++ } }, t.prototype._processAnimations = function () { var t = this.data.animations || {}; for (var e in t) { this.animations[e] = []; for (var r = 0; r < t[e].length; r++) { var i = t[e][r]; this.animations[e].push(this.textures[i]) } } }, t.prototype._parseComplete = function () { var t = this._callback; this._callback = null, this._batchIndex = 0, t.call(this, this.textures) }, t.prototype._nextBatch = function () { var e = this; this._processFrames(this._batchIndex * t.BATCH_SIZE), this._batchIndex++, setTimeout((function () { e._batchIndex * t.BATCH_SIZE < e._frameKeys.length ? e._nextBatch() : (e._processAnimations(), e._parseComplete()) }), 0) }, t.prototype.destroy = function (t) { var e; for (var r in void 0 === t && (t = !1), this.textures) this.textures[r].destroy(); this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && (null === (e = this._texture) || void 0 === e || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [] }, t.BATCH_SIZE = 1e3, t }(), ri = function () { function t() { } return t.use = function (e, r) { var i, n, o = this, s = e.name + "_image"; if (e.data && e.type === yt.TYPE.JSON && e.data.frames && !o.resources[s]) { var a = null === (n = null === (i = e.data) || void 0 === i ? void 0 : i.meta) || void 0 === n ? void 0 : n.related_multi_packs; if (Array.isArray(a)) for (var u = function (t) { if ("string" !== typeof t) return "continue"; var r = t.replace(".json", ""), i = I.url.resolve(e.url.replace(o.baseUrl, ""), t); if (o.resources[r] || Object.values(o.resources).some((function (t) { return I.url.format(I.url.parse(t.url)) === i }))) return "continue"; var n = { crossOrigin: e.crossOrigin, loadType: yt.LOAD_TYPE.XHR, xhrType: yt.XHR_RESPONSE_TYPE.JSON, parentResource: e, metadata: e.metadata }; o.add(r, i, n) }, h = 0, l = a; h < l.length; h++) { var c = l[h]; u(c) } var d = { crossOrigin: e.crossOrigin, metadata: e.metadata.imageMetadata, parentResource: e }, f = t.getResourcePath(e, o.baseUrl); o.add(s, f, d, (function (t) { if (t.error) r(t.error); else { var i = new ei(t.texture, e.data, e.url); i.parse().then((function () { e.spritesheet = i, e.textures = i.textures, r() })) } })) } else r() }, t.getResourcePath = function (t, e) { return t.isDataUrl ? t.data.meta.image : I.url.resolve(t.url.replace(e, ""), t.data.meta.image) }, t.extension = M.nw.Loader, t }(), ii = function (t, e) { return ii = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, ii(t, e) }; function ni(t, e) { function r() { this.constructor = t } ii(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var oi = new H.E9, si = function (t) { function e(e, r, i) { void 0 === r && (r = 100), void 0 === i && (i = 100); var n = t.call(this, e) || this; return n.tileTransform = new H.wx, n._width = r, n._height = i, n.uvMatrix = n.texture.uvMatrix || new M.UX(e), n.pluginName = "tilingSprite", n.uvRespectAnchor = !1, n } return ni(e, t), Object.defineProperty(e.prototype, "clampMargin", { get: function () { return this.uvMatrix.clampMargin }, set: function (t) { this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tileScale", { get: function () { return this.tileTransform.scale }, set: function (t) { this.tileTransform.scale.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tilePosition", { get: function () { return this.tileTransform.position }, set: function (t) { this.tileTransform.position.copyFrom(t) }, enumerable: !1, configurable: !0 }), e.prototype._onTextureUpdate = function () { this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215 }, e.prototype._render = function (t) { var e = this._texture; e && e.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)) }, e.prototype._calculateBounds = function () { var t = this._width * -this._anchor._x, e = this._height * -this._anchor._y, r = this._width * (1 - this._anchor._x), i = this._height * (1 - this._anchor._y); this._bounds.addFrame(this.transform, t, e, r, i) }, e.prototype.getLocalBounds = function (e) { return 0 === this.children.length ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new H.Ae), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e) }, e.prototype.containsPoint = function (t) { this.worldTransform.applyInverse(t, oi); var e = this._width, r = this._height, i = -e * this.anchor._x; if (oi.x >= i && oi.x < i + e) { var n = -r * this.anchor._y; if (oi.y >= n && oi.y < n + r) return !0 } return !1 }, e.prototype.destroy = function (e) { t.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null }, e.from = function (t, r) { var i = t instanceof M.xE ? t : M.xE.from(t, r); return new e(i, r.width, r.height) }, Object.defineProperty(e.prototype, "width", { get: function () { return this._width }, set: function (t) { this._width = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this._height }, set: function (t) { this._height = t }, enumerable: !1, configurable: !0 }), e }(wr), ai = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n", ui = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", hi = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n", li = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", ci = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n", di = new H.y3, fi = function (t) { function e(e) { var r = t.call(this, e) || this; return e.runners.contextChange.add(r), r.quad = new M.ud, r.state = M.ZM.for2d(), r } return ni(e, t), e.prototype.contextChange = function () { var t = this.renderer, e = { globals: t.globalUniforms }; this.simpleShader = M.ex.from(ui, ai, e), this.shader = t.context.webGLVersion > 1 ? M.ex.from(li, ci, e) : M.ex.from(ui, hi, e) }, e.prototype.render = function (t) { var e = this.renderer, r = this.quad, i = r.vertices; i[0] = i[6] = t._width * -t.anchor.x, i[1] = i[3] = t._height * -t.anchor.y, i[2] = i[4] = t._width * (1 - t.anchor.x), i[5] = i[7] = t._height * (1 - t.anchor.y); var n = t.uvRespectAnchor ? t.anchor.x : 0, o = t.uvRespectAnchor ? t.anchor.y : 0; i = r.uvs, i[0] = i[6] = -n, i[1] = i[3] = -o, i[2] = i[4] = 1 - n, i[5] = i[7] = 1 - o, r.invalidate(); var s = t._texture, a = s.baseTexture, u = a.alphaMode > 0, h = t.tileTransform.localTransform, l = t.uvMatrix, c = a.isPowerOfTwo && s.frame.width === a.width && s.frame.height === a.height; c && (a._glTextures[e.CONTEXT_UID] ? c = a.wrapMode !== et.Nt.CLAMP : a.wrapMode === et.Nt.CLAMP && (a.wrapMode = et.Nt.REPEAT)); var d = c ? this.simpleShader : this.shader, f = s.width, p = s.height, _ = t._width, m = t._height; di.set(h.a * f / _, h.b * f / m, h.c * p / _, h.d * p / m, h.tx / _, h.ty / m), di.invert(), c ? di.prepend(l.mapCoord) : (d.uniforms.uMapCoord = l.mapCoord.toArray(!0), d.uniforms.uClampFrame = l.uClampFrame, d.uniforms.uClampOffset = l.uClampOffset), d.uniforms.uTransform = di.toArray(!0), d.uniforms.uColor = (0, I.premultiplyTintToRgba)(t.tint, t.worldAlpha, d.uniforms.uColor, u), d.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), d.uniforms.uSampler = s, e.shader.bind(d), e.geometry.bind(r), this.state.blendMode = (0, I.correctBlendMode)(t.blendMode, u), e.state.set(this.state), e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0) }, e.extension = { name: "tilingSprite", type: M.nw.RendererPlugin }, e }(M.bO), pi = function (t, e) { return pi = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, pi(t, e) }; function _i(t, e) { function r() { this.constructor = t } pi(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var mi = function () { function t(t, e) { this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0 } return t.prototype.update = function (t) { if (t || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) { this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID; var e = this.uvBuffer.data; this.data && this.data.length === e.length || (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++ } }, t }(), gi = new H.E9, vi = new H.mg, yi = function (t) { function e(e, r, i, n) { void 0 === n && (n = et.lg.TRIANGLES); var o = t.call(this) || this; return o.geometry = e, o.shader = r, o.state = i || M.ZM.for2d(), o.drawMode = n, o.start = 0, o.size = 0, o.uvs = null, o.indices = null, o.vertexData = new Float32Array(1), o.vertexDirty = -1, o._transformID = -1, o._roundPixels = Ft.Xd.ROUND_PIXELS, o.batchUvs = null, o } return _i(e, t), Object.defineProperty(e.prototype, "geometry", { get: function () { return this._geometry }, set: function (t) { this._geometry !== t && (this._geometry && (this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose()), this._geometry = t, this._geometry && this._geometry.refCount++, this.vertexDirty = -1) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "uvBuffer", { get: function () { return this.geometry.buffers[1] }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "verticesBuffer", { get: function () { return this.geometry.buffers[0] }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "material", { get: function () { return this.shader }, set: function (t) { this.shader = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "blendMode", { get: function () { return this.state.blendMode }, set: function (t) { this.state.blendMode = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "roundPixels", { get: function () { return this._roundPixels }, set: function (t) { this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tint", { get: function () { return "tint" in this.shader ? this.shader.tint : null }, set: function (t) { this.shader.tint = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "texture", { get: function () { return "texture" in this.shader ? this.shader.texture : null }, set: function (t) { this.shader.texture = t }, enumerable: !1, configurable: !0 }), e.prototype._render = function (t) { var r = this.geometry.buffers[0].data, i = this.shader; i.batchable && this.drawMode === et.lg.TRIANGLES && r.length < 2 * e.BATCHABLE_SIZE ? this._renderToBatch(t) : this._renderDefault(t) }, e.prototype._renderDefault = function (t) { var e = this.shader; e.alpha = this.worldAlpha, e.update && e.update(), t.batch.flush(), e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), t.shader.bind(e), t.state.set(this.state), t.geometry.bind(this.geometry, e), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount) }, e.prototype._renderToBatch = function (t) { var e = this.geometry, r = this.shader; r.uvMatrix && (r.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e.indexBuffer.data, this._tintRGB = r._tintRGB, this._texture = r.texture; var i = this.material.pluginName; t.batch.setObjectRenderer(t.plugins[i]), t.plugins[i].render(this) }, e.prototype.calculateVertices = function () { var t = this.geometry, e = t.buffers[0], r = e.data, i = e._updateID; if (i !== this.vertexDirty || this._transformID !== this.transform._worldID) { this._transformID = this.transform._worldID, this.vertexData.length !== r.length && (this.vertexData = new Float32Array(r.length)); for (var n = this.transform.worldTransform, o = n.a, s = n.b, a = n.c, u = n.d, h = n.tx, l = n.ty, c = this.vertexData, d = 0; d < c.length / 2; d++) { var f = r[2 * d], p = r[2 * d + 1]; c[2 * d] = o * f + a * p + h, c[2 * d + 1] = s * f + u * p + l } if (this._roundPixels) { var _ = Ft.Xd.RESOLUTION; for (d = 0; d < c.length; ++d)c[d] = Math.round((c[d] * _ | 0) / _) } this.vertexDirty = i } }, e.prototype.calculateUvs = function () { var t = this.geometry.buffers[1], e = this.shader; e.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new mi(t, e.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data) }, e.prototype._calculateBounds = function () { this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length) }, e.prototype.containsPoint = function (t) { if (!this.getBounds().contains(t.x, t.y)) return !1; this.worldTransform.applyInverse(t, gi); for (var e = this.geometry.getBuffer("aVertexPosition").data, r = vi.points, i = this.geometry.getIndex().data, n = i.length, o = 4 === this.drawMode ? 3 : 1, s = 0; s + 2 < n; s += o) { var a = 2 * i[s], u = 2 * i[s + 1], h = 2 * i[s + 2]; if (r[0] = e[a], r[1] = e[a + 1], r[2] = e[u], r[3] = e[u + 1], r[4] = e[h], r[5] = e[h + 1], vi.contains(gi.x, gi.y)) return !0 } return !1 }, e.prototype.destroy = function (e) { t.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null }, e.BATCHABLE_SIZE = 100, e }(P.W2), bi = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n", xi = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", Ti = function (t) { function e(e, r) { var i = this, n = { uSampler: e, alpha: 1, uTextureMatrix: H.y3.IDENTITY, uColor: new Float32Array([1, 1, 1, 1]) }; return r = Object.assign({ tint: 16777215, alpha: 1, pluginName: "batch" }, r), r.uniforms && Object.assign(n, r.uniforms), i = t.call(this, r.program || M.$r.from(xi, bi), n) || this, i._colorDirty = !1, i.uvMatrix = new M.UX(e), i.batchable = void 0 === r.program, i.pluginName = r.pluginName, i.tint = r.tint, i.alpha = r.alpha, i } return _i(e, t), Object.defineProperty(e.prototype, "texture", { get: function () { return this.uniforms.uSampler }, set: function (t) { this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode !== !t.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = t, this.uvMatrix.texture = t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "alpha", { get: function () { return this._alpha }, set: function (t) { t !== this._alpha && (this._alpha = t, this._colorDirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tint", { get: function () { return this._tint }, set: function (t) { t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16), this._colorDirty = !0) }, enumerable: !1, configurable: !0 }), e.prototype.update = function () { if (this._colorDirty) { this._colorDirty = !1; var t = this.texture.baseTexture; (0, I.premultiplyTintToRgba)(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode) } this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord) }, e }(M.ex), Ei = function (t) { function e(e, r, i) { var n = t.call(this) || this, o = new M.lW(e), s = new M.lW(r, !0), a = new M.lW(i, !0, !0); return n.addAttribute("aVertexPosition", o, 2, !1, et.vK.FLOAT).addAttribute("aTextureCoord", s, 2, !1, et.vK.FLOAT).addIndex(a), n._updateId = -1, n } return _i(e, t), Object.defineProperty(e.prototype, "vertexDirtyId", { get: function () { return this.buffers[0]._updateID }, enumerable: !1, configurable: !0 }), e }(M.ZX), Si = function (t, e) { return Si = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, Si(t, e) }; function wi(t, e) { function r() { this.constructor = t } Si(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var Ai = function () { function t() { this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [] } return t }(), Ri = function () { function t() { } return t.test = function (t) { return "string" === typeof t && 0 === t.indexOf("info face=") }, t.parse = function (t) { var e = t.match(/^[a-z]+\s+.+$/gm), r = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: [] }; for (var i in e) { var n = e[i].match(/^[a-z]+/gm)[0], o = e[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), s = {}; for (var a in o) { var u = o[a].split("="), h = u[0], l = u[1].replace(/"/gm, ""), c = parseFloat(l), d = isNaN(c) ? l : c; s[h] = d } r[n].push(s) } var f = new Ai; return r.info.forEach((function (t) { return f.info.push({ face: t.face, size: parseInt(t.size, 10) }) })), r.common.forEach((function (t) { return f.common.push({ lineHeight: parseInt(t.lineHeight, 10) }) })), r.page.forEach((function (t) { return f.page.push({ id: parseInt(t.id, 10), file: t.file }) })), r.char.forEach((function (t) { return f.char.push({ id: parseInt(t.id, 10), page: parseInt(t.page, 10), x: parseInt(t.x, 10), y: parseInt(t.y, 10), width: parseInt(t.width, 10), height: parseInt(t.height, 10), xoffset: parseInt(t.xoffset, 10), yoffset: parseInt(t.yoffset, 10), xadvance: parseInt(t.xadvance, 10) }) })), r.kerning.forEach((function (t) { return f.kerning.push({ first: parseInt(t.first, 10), second: parseInt(t.second, 10), amount: parseInt(t.amount, 10) }) })), r.distanceField.forEach((function (t) { return f.distanceField.push({ distanceRange: parseInt(t.distanceRange, 10), fieldType: t.fieldType }) })), f }, t }(), Oi = function () { function t() { } return t.test = function (t) { return t instanceof XMLDocument && t.getElementsByTagName("page").length && null !== t.getElementsByTagName("info")[0].getAttribute("face") }, t.parse = function (t) { for (var e = new Ai, r = t.getElementsByTagName("info"), i = t.getElementsByTagName("common"), n = t.getElementsByTagName("page"), o = t.getElementsByTagName("char"), s = t.getElementsByTagName("kerning"), a = t.getElementsByTagName("distanceField"), u = 0; u < r.length; u++)e.info.push({ face: r[u].getAttribute("face"), size: parseInt(r[u].getAttribute("size"), 10) }); for (u = 0; u < i.length; u++)e.common.push({ lineHeight: parseInt(i[u].getAttribute("lineHeight"), 10) }); for (u = 0; u < n.length; u++)e.page.push({ id: parseInt(n[u].getAttribute("id"), 10) || 0, file: n[u].getAttribute("file") }); for (u = 0; u < o.length; u++) { var h = o[u]; e.char.push({ id: parseInt(h.getAttribute("id"), 10), page: parseInt(h.getAttribute("page"), 10) || 0, x: parseInt(h.getAttribute("x"), 10), y: parseInt(h.getAttribute("y"), 10), width: parseInt(h.getAttribute("width"), 10), height: parseInt(h.getAttribute("height"), 10), xoffset: parseInt(h.getAttribute("xoffset"), 10), yoffset: parseInt(h.getAttribute("yoffset"), 10), xadvance: parseInt(h.getAttribute("xadvance"), 10) }) } for (u = 0; u < s.length; u++)e.kerning.push({ first: parseInt(s[u].getAttribute("first"), 10), second: parseInt(s[u].getAttribute("second"), 10), amount: parseInt(s[u].getAttribute("amount"), 10) }); for (u = 0; u < a.length; u++)e.distanceField.push({ fieldType: a[u].getAttribute("fieldType"), distanceRange: parseInt(a[u].getAttribute("distanceRange"), 10) }); return e }, t }(), Ii = function () { function t() { } return t.test = function (t) { if ("string" === typeof t && t.indexOf("<font>") > -1) { var e = (new globalThis.DOMParser).parseFromString(t, "text/xml"); return Oi.test(e) } return !1 }, t.parse = function (t) { var e = (new globalThis.DOMParser).parseFromString(t, "text/xml"); return Oi.parse(e) }, t }(), Pi = [Ri, Oi, Ii]; function Mi(t) { for (var e = 0; e < Pi.length; e++)if (Pi[e].test(t)) return Pi[e]; return null } function Ci(t, e, r, i, n, o) { var s, a = r.fill; if (!Array.isArray(a)) return a; if (1 === a.length) return a[0]; var u = r.dropShadow ? r.dropShadowDistance : 0, h = r.padding || 0, l = t.width / i - u - 2 * h, c = t.height / i - u - 2 * h, d = a.slice(), f = r.fillGradientStops.slice(); if (!f.length) for (var p = d.length + 1, _ = 1; _ < p; ++_)f.push(_ / p); if (d.unshift(a[0]), f.unshift(0), d.push(a[a.length - 1]), f.push(1), r.fillGradientType === Tr.LINEAR_VERTICAL) { s = e.createLinearGradient(l / 2, h, l / 2, c + h); var m = 0, g = o.fontProperties.fontSize + r.strokeThickness, v = g / c; for (_ = 0; _ < n.length; _++)for (var y = o.lineHeight * _, b = 0; b < d.length; b++) { var x = 0; x = "number" === typeof f[b] ? f[b] : b / d.length; var T = y / c + x * v, E = Math.max(m, T); E = Math.min(E, 1), s.addColorStop(E, d[b]), m = E } } else { s = e.createLinearGradient(h, c / 2, l + h, c / 2); var S = d.length + 1, w = 1; for (_ = 0; _ < d.length; _++) { var A = void 0; A = "number" === typeof f[_] ? f[_] : w / S, s.addColorStop(A, d[_]), w++ } } return s } function Di(t, e, r, i, n, o, s) { var a = r.text, u = r.fontProperties; e.translate(i, n), e.scale(o, o); var h = s.strokeThickness / 2, l = -s.strokeThickness / 2; if (e.font = s.toFontString(), e.lineWidth = s.strokeThickness, e.textBaseline = s.textBaseline, e.lineJoin = s.lineJoin, e.miterLimit = s.miterLimit, e.fillStyle = Ci(t, e, s, o, [a], r), e.strokeStyle = s.stroke, s.dropShadow) { var c = s.dropShadowColor, d = (0, I.hex2rgb)("number" === typeof c ? c : (0, I.string2hex)(c)), f = s.dropShadowBlur * o, p = s.dropShadowDistance * o; e.shadowColor = "rgba(" + 255 * d[0] + "," + 255 * d[1] + "," + 255 * d[2] + "," + s.dropShadowAlpha + ")", e.shadowBlur = f, e.shadowOffsetX = Math.cos(s.dropShadowAngle) * p, e.shadowOffsetY = Math.sin(s.dropShadowAngle) * p } else e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0; s.stroke && s.strokeThickness && e.strokeText(a, h, l + r.lineHeight - u.descent), s.fill && e.fillText(a, h, l + r.lineHeight - u.descent), e.setTransform(1, 0, 0, 1, 0, 0), e.fillStyle = "rgba(0, 0, 0, 0)" } function Li(t) { return Array.from ? Array.from(t) : t.split("") } function Fi(t) { "string" === typeof t && (t = [t]); for (var e = [], r = 0, i = t.length; r < i; r++) { var n = t[r]; if (Array.isArray(n)) { if (2 !== n.length) throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + n.length + "."); var o = n[0].charCodeAt(0), s = n[1].charCodeAt(0); if (s < o) throw new Error("[BitmapFont]: Invalid character range."); for (var a = o, u = s; a <= u; a++)e.push(String.fromCharCode(a)) } else e.push.apply(e, Li(n)) } if (0 === e.length) throw new Error("[BitmapFont]: Empty set when resolving characters."); return e } function Ni(t) { return t.codePointAt ? t.codePointAt(0) : t.charCodeAt(0) } var Bi = function () { function t(t, e, r) { var i, n, o = t.info[0], s = t.common[0], a = t.page[0], u = t.distanceField[0], h = (0, I.getResolutionOfUrl)(a.file), l = {}; this._ownsTextures = r, this.font = o.face, this.size = o.size, this.lineHeight = s.lineHeight / h, this.chars = {}, this.pageTextures = l; for (var c = 0; c < t.page.length; c++) { var d = t.page[c], f = d.id, p = d.file; l[f] = e instanceof Array ? e[c] : e[p], (null === u || void 0 === u ? void 0 : u.fieldType) && "none" !== u.fieldType && (l[f].baseTexture.alphaMode = et.iw.NO_PREMULTIPLIED_ALPHA, l[f].baseTexture.mipmap = et.WB.OFF) } for (c = 0; c < t.char.length; c++) { var _ = t.char[c], m = (f = _.id, _.page), g = t.char[c], v = g.x, y = g.y, b = g.width, x = g.height, T = g.xoffset, E = g.yoffset, S = g.xadvance; v /= h, y /= h, b /= h, x /= h, T /= h, E /= h, S /= h; var w = new H.Ae(v + l[m].frame.x / h, y + l[m].frame.y / h, b, x); this.chars[f] = { xOffset: T, yOffset: E, xAdvance: S, kerning: {}, texture: new M.xE(l[m].baseTexture, w), page: m } } for (c = 0; c < t.kerning.length; c++) { var A = t.kerning[c], R = A.first, O = A.second, P = A.amount; R /= h, O /= h, P /= h, this.chars[O] && (this.chars[O].kerning[R] = P) } this.distanceFieldRange = null === u || void 0 === u ? void 0 : u.distanceRange, this.distanceFieldType = null !== (n = null === (i = null === u || void 0 === u ? void 0 : u.fieldType) || void 0 === i ? void 0 : i.toLowerCase()) && void 0 !== n ? n : "none" } return t.prototype.destroy = function () { for (var t in this.chars) this.chars[t].texture.destroy(), this.chars[t].texture = null; for (var t in this.pageTextures) this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null; this.chars = null, this.pageTextures = null }, t.install = function (e, r, i) { var n; if (e instanceof Ai) n = e; else { var o = Mi(e); if (!o) throw new Error("Unrecognized data format for font."); n = o.parse(e) } r instanceof M.xE && (r = [r]); var s = new t(n, r, i); return t.available[s.font] = s, s }, t.uninstall = function (e) { var r = t.available[e]; if (!r) throw new Error("No font found named '" + e + "'"); r.destroy(), delete t.available[e] }, t.from = function (e, r, i) { if (!e) throw new Error("[BitmapFont] Property `name` is required."); var n = Object.assign({}, t.defaultOptions, i), o = n.chars, s = n.padding, a = n.resolution, u = n.textureWidth, h = n.textureHeight, l = Fi(o), c = r instanceof Pr ? r : new Pr(r), d = u, f = new Ai; f.info[0] = { face: c.fontFamily, size: c.fontSize }, f.common[0] = { lineHeight: c.fontSize }; for (var p, _, m, g = 0, v = 0, y = 0, b = [], x = 0; x < l.length; x++) { p || (p = Ft.Xd.ADAPTER.createCanvas(), p.width = u, p.height = h, _ = p.getContext("2d"), m = new M.VL(p, { resolution: a }), b.push(new M.xE(m)), f.page.push({ id: b.length - 1, file: "" })); var T = l[x], E = Nr.measureText(T, c, !1, p), S = E.width, w = Math.ceil(E.height), A = Math.ceil(("italic" === c.fontStyle ? 2 : 1) * S); if (v >= h - w * a) { if (0 === v) throw new Error("[BitmapFont] textureHeight " + h + "px is too small (fontFamily: '" + c.fontFamily + "', fontSize: " + c.fontSize + "px, char: '" + T + "')"); --x, p = null, _ = null, m = null, v = 0, g = 0, y = 0 } else if (y = Math.max(w + E.fontProperties.descent, y), A * a + g >= d) { if (0 === g) throw new Error("[BitmapFont] textureWidth " + u + "px is too small (fontFamily: '" + c.fontFamily + "', fontSize: " + c.fontSize + "px, char: '" + T + "')"); --x, v += y * a, v = Math.ceil(v), g = 0, y = 0 } else { Di(p, _, E, g, v, a, c); var R = Ni(E.text); f.char.push({ id: R, page: b.length - 1, x: g / a, y: v / a, width: A, height: w, xoffset: 0, yoffset: 0, xadvance: Math.ceil(S - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0)) }), g += (A + 2 * s) * a, g = Math.ceil(g) } } x = 0; for (var O = l.length; x < O; x++)for (var I = l[x], P = 0; P < O; P++) { var C = l[P], D = _.measureText(I).width, L = _.measureText(C).width, F = _.measureText(I + C).width, N = F - (D + L); N && f.kerning.push({ first: Ni(I), second: Ni(C), amount: N }) } var B = new t(f, b, !0); return void 0 !== t.available[e] && t.uninstall(e), t.available[e] = B, B }, t.ALPHA = [["a", "z"], ["A", "Z"], " "], t.NUMERIC = [["0", "9"]], t.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], t.ASCII = [[" ", "~"]], t.defaultOptions = { resolution: 1, textureWidth: 512, textureHeight: 512, padding: 4, chars: t.ALPHANUMERIC }, t.available = {}, t }(), Ui = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n", ki = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n", Gi = [], Xi = [], ji = [], Hi = function (t) { function e(r, i) { void 0 === i && (i = {}); var n = t.call(this) || this; n._tint = 16777215; var o = Object.assign({}, e.styleDefaults, i), s = o.align, a = o.tint, u = o.maxWidth, h = o.letterSpacing, l = o.fontName, c = o.fontSize; if (!Bi.available[l]) throw new Error('Missing BitmapFont "' + l + '"'); return n._activePagesMeshData = [], n._textWidth = 0, n._textHeight = 0, n._align = s, n._tint = a, n._font = void 0, n._fontName = l, n._fontSize = c, n.text = r, n._maxWidth = u, n._maxLineHeight = 0, n._letterSpacing = h, n._anchor = new H.AB((function () { n.dirty = !0 }), n, 0, 0), n._roundPixels = Ft.Xd.ROUND_PIXELS, n.dirty = !0, n._resolution = Ft.Xd.RESOLUTION, n._autoResolution = !0, n._textureCache = {}, n } return wi(e, t), e.prototype.updateText = function () { for (var t, e = Bi.available[this._fontName], r = this.fontSize, i = r / e.size, n = new H.E9, o = [], s = [], a = [], u = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ", h = Li(u), l = this._maxWidth * e.size / r, c = "none" === e.distanceFieldType ? Gi : Xi, d = null, f = 0, p = 0, _ = 0, m = -1, g = 0, v = 0, y = 0, b = 0, x = 0; x < h.length; x++) { var T = h[x], E = Ni(T); if (/(?:\s)/.test(T) && (m = x, g = f, b++), "\r" !== T && "\n" !== T) { var S = e.chars[E]; if (S) { d && S.kerning[d] && (n.x += S.kerning[d]); var w = ji.pop() || { texture: M.xE.EMPTY, line: 0, charCode: 0, prevSpaces: 0, position: new H.E9 }; w.texture = S.texture, w.line = _, w.charCode = E, w.position.x = n.x + S.xOffset + this._letterSpacing / 2, w.position.y = n.y + S.yOffset, w.prevSpaces = b, o.push(w), f = w.position.x + Math.max(S.xAdvance - S.xOffset, S.texture.orig.width), n.x += S.xAdvance + this._letterSpacing, y = Math.max(y, S.yOffset + S.texture.height), d = E, -1 !== m && l > 0 && n.x > l && (++v, (0, I.removeItems)(o, 1 + m - v, 1 + x - m), x = m, m = -1, s.push(g), a.push(o.length > 0 ? o[o.length - 1].prevSpaces : 0), p = Math.max(p, g), _++, n.x = 0, n.y += e.lineHeight, d = null, b = 0) } } else s.push(f), a.push(-1), p = Math.max(p, f), ++_, ++v, n.x = 0, n.y += e.lineHeight, d = null, b = 0 } var A = h[h.length - 1]; "\r" !== A && "\n" !== A && (/(?:\s)/.test(A) && (f = g), s.push(f), p = Math.max(p, f), a.push(-1)); var R = []; for (x = 0; x <= _; x++) { var O = 0; "right" === this._align ? O = p - s[x] : "center" === this._align ? O = (p - s[x]) / 2 : "justify" === this._align && (O = a[x] < 0 ? 0 : (p - s[x]) / a[x]), R.push(O) } var P = o.length, C = {}, D = [], L = this._activePagesMeshData; c.push.apply(c, L); for (x = 0; x < P; x++) { var F = o[x].texture, N = F.baseTexture.uid; if (!C[N]) { var B = c.pop(); if (!B) { var U = new Ei, k = void 0, G = void 0; "none" === e.distanceFieldType ? (k = new Ti(M.xE.EMPTY), G = et.T$.NORMAL) : (k = new Ti(M.xE.EMPTY, { program: M.$r.from(ki, Ui), uniforms: { uFWidth: 0 } }), G = et.T$.NORMAL_NPM); var X = new yi(U, k); X.blendMode = G, B = { index: 0, indexCount: 0, vertexCount: 0, uvsCount: 0, total: 0, mesh: X, vertices: null, uvs: null, indices: null } } B.index = 0, B.indexCount = 0, B.vertexCount = 0, B.uvsCount = 0, B.total = 0; var j = this._textureCache; j[N] = j[N] || new M.xE(F.baseTexture), B.mesh.texture = j[N], B.mesh.tint = this._tint, D.push(B), C[N] = B } C[N].total++ } for (x = 0; x < L.length; x++)-1 === D.indexOf(L[x]) && this.removeChild(L[x].mesh); for (x = 0; x < D.length; x++)D[x].mesh.parent !== this && this.addChild(D[x].mesh); for (var x in this._activePagesMeshData = D, C) { B = C[x]; var V = B.total; if (!((null === (t = B.indices) || void 0 === t ? void 0 : t.length) > 6 * V) || B.vertices.length < 2 * yi.BATCHABLE_SIZE) B.vertices = new Float32Array(8 * V), B.uvs = new Float32Array(8 * V), B.indices = new Uint16Array(6 * V); else for (var z = B.total, Y = B.vertices, W = 4 * z * 2; W < Y.length; W++)Y[W] = 0; B.mesh.size = 6 * V } for (x = 0; x < P; x++) { T = o[x]; var $ = T.position.x + R[T.line] * ("justify" === this._align ? T.prevSpaces : 1); this._roundPixels && ($ = Math.round($)); var q = $ * i, K = T.position.y * i, Z = (F = T.texture, C[F.baseTexture.uid]), J = F.frame, Q = F._uvs, tt = Z.index++; Z.indices[6 * tt + 0] = 0 + 4 * tt, Z.indices[6 * tt + 1] = 1 + 4 * tt, Z.indices[6 * tt + 2] = 2 + 4 * tt, Z.indices[6 * tt + 3] = 0 + 4 * tt, Z.indices[6 * tt + 4] = 2 + 4 * tt, Z.indices[6 * tt + 5] = 3 + 4 * tt, Z.vertices[8 * tt + 0] = q, Z.vertices[8 * tt + 1] = K, Z.vertices[8 * tt + 2] = q + J.width * i, Z.vertices[8 * tt + 3] = K, Z.vertices[8 * tt + 4] = q + J.width * i, Z.vertices[8 * tt + 5] = K + J.height * i, Z.vertices[8 * tt + 6] = q, Z.vertices[8 * tt + 7] = K + J.height * i, Z.uvs[8 * tt + 0] = Q.x0, Z.uvs[8 * tt + 1] = Q.y0, Z.uvs[8 * tt + 2] = Q.x1, Z.uvs[8 * tt + 3] = Q.y1, Z.uvs[8 * tt + 4] = Q.x2, Z.uvs[8 * tt + 5] = Q.y2, Z.uvs[8 * tt + 6] = Q.x3, Z.uvs[8 * tt + 7] = Q.y3 } for (var x in this._textWidth = p * i, this._textHeight = (n.y + e.lineHeight) * i, C) { B = C[x]; if (0 !== this.anchor.x || 0 !== this.anchor.y) for (var rt = 0, it = this._textWidth * this.anchor.x, nt = this._textHeight * this.anchor.y, ot = 0; ot < B.total; ot++)B.vertices[rt++] -= it, B.vertices[rt++] -= nt, B.vertices[rt++] -= it, B.vertices[rt++] -= nt, B.vertices[rt++] -= it, B.vertices[rt++] -= nt, B.vertices[rt++] -= it, B.vertices[rt++] -= nt; this._maxLineHeight = y * i; var st = B.mesh.geometry.getBuffer("aVertexPosition"), at = B.mesh.geometry.getBuffer("aTextureCoord"), ut = B.mesh.geometry.getIndex(); st.data = B.vertices, at.data = B.uvs, ut.data = B.indices, st.update(), at.update(), ut.update() } for (x = 0; x < o.length; x++)ji.push(o[x]); this._font = e, this.dirty = !1 }, e.prototype.updateTransform = function () { this.validate(), this.containerUpdateTransform() }, e.prototype._render = function (e) { this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0); var r = Bi.available[this._fontName], i = r.distanceFieldRange, n = r.distanceFieldType, o = r.size; if ("none" !== n) for (var s = this.worldTransform, a = s.a, u = s.b, h = s.c, l = s.d, c = Math.sqrt(a * a + u * u), d = Math.sqrt(h * h + l * l), f = (Math.abs(c) + Math.abs(d)) / 2, p = this.fontSize / o, _ = 0, m = this._activePagesMeshData; _ < m.length; _++) { var g = m[_]; g.mesh.shader.uniforms.uFWidth = f * i * p * this._resolution } t.prototype._render.call(this, e) }, e.prototype.getLocalBounds = function () { return this.validate(), t.prototype.getLocalBounds.call(this) }, e.prototype.validate = function () { var t = Bi.available[this._fontName]; if (!t) throw new Error('Missing BitmapFont "' + this._fontName + '"'); this._font !== t && (this.dirty = !0), this.dirty && this.updateText() }, Object.defineProperty(e.prototype, "tint", { get: function () { return this._tint }, set: function (t) { if (this._tint !== t) { this._tint = t; for (var e = 0; e < this._activePagesMeshData.length; e++)this._activePagesMeshData[e].mesh.tint = t } }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "align", { get: function () { return this._align }, set: function (t) { this._align !== t && (this._align = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "fontName", { get: function () { return this._fontName }, set: function (t) { if (!Bi.available[t]) throw new Error('Missing BitmapFont "' + t + '"'); this._fontName !== t && (this._fontName = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "fontSize", { get: function () { var t; return null !== (t = this._fontSize) && void 0 !== t ? t : Bi.available[this._fontName].size }, set: function (t) { this._fontSize !== t && (this._fontSize = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "anchor", { get: function () { return this._anchor }, set: function (t) { "number" === typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "text", { get: function () { return this._text }, set: function (t) { t = String(null === t || void 0 === t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "maxWidth", { get: function () { return this._maxWidth }, set: function (t) { this._maxWidth !== t && (this._maxWidth = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "maxLineHeight", { get: function () { return this.validate(), this._maxLineHeight }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "textWidth", { get: function () { return this.validate(), this._textWidth }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "letterSpacing", { get: function () { return this._letterSpacing }, set: function (t) { this._letterSpacing !== t && (this._letterSpacing = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "roundPixels", { get: function () { return this._roundPixels }, set: function (t) { t !== this._roundPixels && (this._roundPixels = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "textHeight", { get: function () { return this.validate(), this._textHeight }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "resolution", { get: function () { return this._resolution }, set: function (t) { this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0) }, enumerable: !1, configurable: !0 }), e.prototype.destroy = function (e) { var r = this._textureCache, i = Bi.available[this._fontName], n = "none" === i.distanceFieldType ? Gi : Xi; n.push.apply(n, this._activePagesMeshData); for (var o = 0, s = this._activePagesMeshData; o < s.length; o++) { var a = s[o]; this.removeChild(a.mesh) } for (var u in this._activePagesMeshData = [], n.filter((function (t) { return r[t.mesh.texture.baseTexture.uid] })).forEach((function (t) { t.mesh.texture = M.xE.EMPTY })), r) { var h = r[u]; h.destroy(), delete r[u] } this._font = null, this._textureCache = null, t.prototype.destroy.call(this, e) }, e.styleDefaults = { align: "left", tint: 16777215, maxWidth: 0, letterSpacing: 0 }, e }(P.W2), Vi = function () { function t() { } return t.add = function () { yt.setExtensionXhrType("fnt", yt.XHR_RESPONSE_TYPE.TEXT) }, t.use = function (e, r) { var i = Mi(e.data); if (i) for (var n = t.getBaseUrl(this, e), o = i.parse(e.data), s = {}, a = function (t) { s[t.metadata.pageFile] = t.texture, Object.keys(s).length === o.page.length && (e.bitmapFont = Bi.install(o, s, !0), r()) }, u = 0; u < o.page.length; ++u) { var h = o.page[u].file, l = n + h, c = !1; for (var d in this.resources) { var f = this.resources[d]; if (f.url === l) { f.metadata.pageFile = h, f.texture ? a(f) : f.onAfterMiddleware.add(a), c = !0; break } } if (!c) { var p = { crossOrigin: e.crossOrigin, loadType: yt.LOAD_TYPE.IMAGE, metadata: Object.assign({ pageFile: h }, e.metadata.imageMetadata), parentResource: e }; this.add(l, p, a) } } else r() }, t.getBaseUrl = function (e, r) { var i = r.isDataUrl ? "" : t.dirname(r.url); return r.isDataUrl && ("." === i && (i = ""), e.baseUrl && i && "/" === e.baseUrl.charAt(e.baseUrl.length - 1) && (i += "/")), i = i.replace(e.baseUrl, ""), i && "/" !== i.charAt(i.length - 1) && (i += "/"), i }, t.dirname = function (t) { var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, ""); return e === t ? "." : "" === e ? "/" : e }, t.extension = M.nw.Loader, t }(), zi = function (t, e) { return zi = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, zi(t, e) }; function Yi(t, e) { function r() { this.constructor = t } zi(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var Wi = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", $i = function (t) { function e(e) { void 0 === e && (e = 1); var r = t.call(this, M.kP, Wi, { uAlpha: 1 }) || this; return r.alpha = e, r } return Yi(e, t), Object.defineProperty(e.prototype, "alpha", { get: function () { return this.uniforms.uAlpha }, set: function (t) { this.uniforms.uAlpha = t }, enumerable: !1, configurable: !0 }), e }(M.wn), qi = function (t, e) { return qi = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, qi(t, e) }; function Ki(t, e) { function r() { this.constructor = t } qi(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var Zi = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }"; function Ji(t, e) { var r, i = Math.ceil(t / 2), n = Zi, o = ""; r = e ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);"; for (var s = 0; s < t; s++) { var a = r.replace("%index%", s.toString()); a = a.replace("%sampleIndex%", s - (i - 1) + ".0"), o += a, o += "\n" } return n = n.replace("%blur%", o), n = n.replace("%size%", t.toString()), n } var Qi = { 5: [.153388, .221461, .250301], 7: [.071303, .131514, .189879, .214607], 9: [.028532, .067234, .124009, .179044, .20236], 11: [.0093, .028002, .065984, .121703, .175713, .198596], 13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641], 15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448] }, tn = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n"); function en(t) { for (var e, r = Qi[t], i = r.length, n = tn, o = "", s = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", a = 0; a < t; a++) { var u = s.replace("%index%", a.toString()); e = a, a >= i && (e = t - a - 1), u = u.replace("%value%", r[e].toString()), o += u, o += "\n" } return n = n.replace("%blur%", o), n = n.replace("%size%", t.toString()), n } var rn = function (t) { function e(e, r, i, n, o) { void 0 === r && (r = 8), void 0 === i && (i = 4), void 0 === n && (n = Ft.Xd.FILTER_RESOLUTION), void 0 === o && (o = 5); var s = this, a = Ji(o, e), u = en(o); return s = t.call(this, a, u) || this, s.horizontal = e, s.resolution = n, s._quality = 0, s.quality = i, s.blur = r, s } return Ki(e, t), e.prototype.apply = function (t, e, r, i) { if (r ? this.horizontal ? this.uniforms.strength = 1 / r.width * (r.width / e.width) : this.uniforms.strength = 1 / r.height * (r.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, 1 === this.passes) t.applyFilter(this, e, r, i); else { var n = t.getFilterTexture(), o = t.renderer, s = e, a = n; this.state.blend = !1, t.applyFilter(this, s, a, et.yl.CLEAR); for (var u = 1; u < this.passes - 1; u++) { t.bindAndClear(s, et.yl.BLIT), this.uniforms.uSampler = a; var h = a; a = s, s = h, o.shader.bind(this), o.geometry.draw(5) } this.state.blend = !0, t.applyFilter(this, a, r, i), t.returnFilterTexture(n) } }, Object.defineProperty(e.prototype, "blur", { get: function () { return this.strength }, set: function (t) { this.padding = 1 + 2 * Math.abs(t), this.strength = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "quality", { get: function () { return this._quality }, set: function (t) { this._quality = t, this.passes = t }, enumerable: !1, configurable: !0 }), e }(M.wn), nn = function (t) { function e(e, r, i, n) { void 0 === e && (e = 8), void 0 === r && (r = 4), void 0 === i && (i = Ft.Xd.FILTER_RESOLUTION), void 0 === n && (n = 5); var o = t.call(this) || this; return o.blurXFilter = new rn(!0, e, r, i, n), o.blurYFilter = new rn(!1, e, r, i, n), o.resolution = i, o.quality = r, o.blur = e, o.repeatEdgePixels = !1, o } return Ki(e, t), e.prototype.apply = function (t, e, r, i) { var n = Math.abs(this.blurXFilter.strength), o = Math.abs(this.blurYFilter.strength); if (n && o) { var s = t.getFilterTexture(); this.blurXFilter.apply(t, e, s, et.yl.CLEAR), this.blurYFilter.apply(t, s, r, i), t.returnFilterTexture(s) } else o ? this.blurYFilter.apply(t, e, r, i) : this.blurXFilter.apply(t, e, r, i) }, e.prototype.updatePadding = function () { this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) }, Object.defineProperty(e.prototype, "blur", { get: function () { return this.blurXFilter.blur }, set: function (t) { this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "quality", { get: function () { return this.blurXFilter.quality }, set: function (t) { this.blurXFilter.quality = this.blurYFilter.quality = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "blurX", { get: function () { return this.blurXFilter.blur }, set: function (t) { this.blurXFilter.blur = t, this.updatePadding() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "blurY", { get: function () { return this.blurYFilter.blur }, set: function (t) { this.blurYFilter.blur = t, this.updatePadding() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "blendMode", { get: function () { return this.blurYFilter.blendMode }, set: function (t) { this.blurYFilter.blendMode = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "repeatEdgePixels", { get: function () { return this._repeatEdgePixels }, set: function (t) { this._repeatEdgePixels = t, this.updatePadding() }, enumerable: !1, configurable: !0 }), e }(M.wn), on = function (t, e) { return on = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, on(t, e) }; function sn(t, e) { function r() { this.constructor = t } on(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var an = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", un = function (t) { function e() { var e = this, r = { m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]), uAlpha: 1 }; return e = t.call(this, M.Y9, an, r) || this, e.alpha = 1, e } return sn(e, t), e.prototype._loadMatrix = function (t, e) { void 0 === e && (e = !1); var r = t; e && (this._multiply(r, this.uniforms.m, t), r = this._colorMatrix(r)), this.uniforms.m = r }, e.prototype._multiply = function (t, e, r) { return t[0] = e[0] * r[0] + e[1] * r[5] + e[2] * r[10] + e[3] * r[15], t[1] = e[0] * r[1] + e[1] * r[6] + e[2] * r[11] + e[3] * r[16], t[2] = e[0] * r[2] + e[1] * r[7] + e[2] * r[12] + e[3] * r[17], t[3] = e[0] * r[3] + e[1] * r[8] + e[2] * r[13] + e[3] * r[18], t[4] = e[0] * r[4] + e[1] * r[9] + e[2] * r[14] + e[3] * r[19] + e[4], t[5] = e[5] * r[0] + e[6] * r[5] + e[7] * r[10] + e[8] * r[15], t[6] = e[5] * r[1] + e[6] * r[6] + e[7] * r[11] + e[8] * r[16], t[7] = e[5] * r[2] + e[6] * r[7] + e[7] * r[12] + e[8] * r[17], t[8] = e[5] * r[3] + e[6] * r[8] + e[7] * r[13] + e[8] * r[18], t[9] = e[5] * r[4] + e[6] * r[9] + e[7] * r[14] + e[8] * r[19] + e[9], t[10] = e[10] * r[0] + e[11] * r[5] + e[12] * r[10] + e[13] * r[15], t[11] = e[10] * r[1] + e[11] * r[6] + e[12] * r[11] + e[13] * r[16], t[12] = e[10] * r[2] + e[11] * r[7] + e[12] * r[12] + e[13] * r[17], t[13] = e[10] * r[3] + e[11] * r[8] + e[12] * r[13] + e[13] * r[18], t[14] = e[10] * r[4] + e[11] * r[9] + e[12] * r[14] + e[13] * r[19] + e[14], t[15] = e[15] * r[0] + e[16] * r[5] + e[17] * r[10] + e[18] * r[15], t[16] = e[15] * r[1] + e[16] * r[6] + e[17] * r[11] + e[18] * r[16], t[17] = e[15] * r[2] + e[16] * r[7] + e[17] * r[12] + e[18] * r[17], t[18] = e[15] * r[3] + e[16] * r[8] + e[17] * r[13] + e[18] * r[18], t[19] = e[15] * r[4] + e[16] * r[9] + e[17] * r[14] + e[18] * r[19] + e[19], t }, e.prototype._colorMatrix = function (t) { var e = new Float32Array(t); return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e }, e.prototype.brightness = function (t, e) { var r = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(r, e) }, e.prototype.tint = function (t, e) { var r = t >> 16 & 255, i = t >> 8 & 255, n = 255 & t, o = [r / 255, 0, 0, 0, 0, 0, i / 255, 0, 0, 0, 0, 0, n / 255, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(o, e) }, e.prototype.greyscale = function (t, e) { var r = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(r, e) }, e.prototype.blackAndWhite = function (t) { var e = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.hue = function (t, e) { t = (t || 0) / 180 * Math.PI; var r = Math.cos(t), i = Math.sin(t), n = Math.sqrt, o = 1 / 3, s = n(o), a = r + (1 - r) * o, u = o * (1 - r) - s * i, h = o * (1 - r) + s * i, l = o * (1 - r) + s * i, c = r + o * (1 - r), d = o * (1 - r) - s * i, f = o * (1 - r) - s * i, p = o * (1 - r) + s * i, _ = r + o * (1 - r), m = [a, u, h, 0, 0, l, c, d, 0, 0, f, p, _, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(m, e) }, e.prototype.contrast = function (t, e) { var r = (t || 0) + 1, i = -.5 * (r - 1), n = [r, 0, 0, 0, i, 0, r, 0, 0, i, 0, 0, r, 0, i, 0, 0, 0, 1, 0]; this._loadMatrix(n, e) }, e.prototype.saturate = function (t, e) { void 0 === t && (t = 0); var r = 2 * t / 3 + 1, i = -.5 * (r - 1), n = [r, i, i, 0, 0, i, r, i, 0, 0, i, i, r, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(n, e) }, e.prototype.desaturate = function () { this.saturate(-1) }, e.prototype.negative = function (t) { var e = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.sepia = function (t) { var e = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.technicolor = function (t) { var e = [1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.polaroid = function (t) { var e = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.toBGR = function (t) { var e = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.kodachrome = function (t) { var e = [1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.browni = function (t) { var e = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.vintage = function (t) { var e = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.colorTone = function (t, e, r, i, n) { t = t || .2, e = e || .15, r = r || 16770432, i = i || 3375104; var o = (r >> 16 & 255) / 255, s = (r >> 8 & 255) / 255, a = (255 & r) / 255, u = (i >> 16 & 255) / 255, h = (i >> 8 & 255) / 255, l = (255 & i) / 255, c = [.3, .59, .11, 0, 0, o, s, a, t, 0, u, h, l, e, 0, o - u, s - h, a - l, 0, 0]; this._loadMatrix(c, n) }, e.prototype.night = function (t, e) { t = t || .1; var r = [-2 * t, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(r, e) }, e.prototype.predator = function (t, e) { var r = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0]; this._loadMatrix(r, e) }, e.prototype.lsd = function (t) { var e = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(e, t) }, e.prototype.reset = function () { var t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]; this._loadMatrix(t, !1) }, Object.defineProperty(e.prototype, "matrix", { get: function () { return this.uniforms.m }, set: function (t) { this.uniforms.m = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "alpha", { get: function () { return this.uniforms.uAlpha }, set: function (t) { this.uniforms.uAlpha = t }, enumerable: !1, configurable: !0 }), e }(M.wn); un.prototype.grayscale = un.prototype.greyscale;
        /*!
         * @pixi/filter-displacement - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * @pixi/filter-displacement is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.
        
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
        
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        var hn = function (t, e) { return hn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, hn(t, e) }; function ln(t, e) { function r() { this.constructor = t } hn(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var cn = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", dn = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", fn = function (t) { function e(e, r) { var i = this, n = new H.y3; return e.renderable = !1, i = t.call(this, dn, cn, { mapSampler: e._texture, filterMatrix: n, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]) }) || this, i.maskSprite = e, i.maskMatrix = n, null !== r && void 0 !== r || (r = 20), i.scale = new H.E9(r, r), i } return ln(e, t), e.prototype.apply = function (t, e, r, i) { this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y; var n = this.maskSprite.worldTransform, o = Math.sqrt(n.a * n.a + n.b * n.b), s = Math.sqrt(n.c * n.c + n.d * n.d); 0 !== o && 0 !== s && (this.uniforms.rotation[0] = n.a / o, this.uniforms.rotation[1] = n.b / o, this.uniforms.rotation[2] = n.c / s, this.uniforms.rotation[3] = n.d / s), t.applyFilter(this, e, r, i) }, Object.defineProperty(e.prototype, "map", { get: function () { return this.uniforms.mapSampler }, set: function (t) { this.uniforms.mapSampler = t }, enumerable: !1, configurable: !0 }), e }(M.wn), pn = function (t, e) { return pn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, pn(t, e) }; function _n(t, e) { function r() { this.constructor = t } pn(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var mn = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", gn = 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n', vn = function (t) { function e() { return t.call(this, mn, gn) || this } return _n(e, t), e }(M.wn), yn = function (t, e) { return yn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, yn(t, e) }; function bn(t, e) { function r() { this.constructor = t } yn(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var xn = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", Tn = function (t) { function e(e, r) { void 0 === e && (e = .5), void 0 === r && (r = Math.random()); var i = t.call(this, M.Y9, xn, { uNoise: 0, uSeed: 0 }) || this; return i.noise = e, i.seed = r, i } return bn(e, t), Object.defineProperty(e.prototype, "noise", { get: function () { return this.uniforms.uNoise }, set: function (t) { this.uniforms.uNoise = t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "seed", { get: function () { return this.uniforms.uSeed }, set: function (t) { this.uniforms.uSeed = t }, enumerable: !1, configurable: !0 }), e }(M.wn), En = new H.y3; P.s$.prototype._cacheAsBitmap = !1, P.s$.prototype._cacheData = null, P.s$.prototype._cacheAsBitmapResolution = null, P.s$.prototype._cacheAsBitmapMultisample = et.G5.NONE; var Sn = function () { function t() { this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null } return t }(); Object.defineProperties(P.s$.prototype, { cacheAsBitmapResolution: { get: function () { return this._cacheAsBitmapResolution }, set: function (t) { t !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0)) } }, cacheAsBitmapMultisample: { get: function () { return this._cacheAsBitmapMultisample }, set: function (t) { t !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0)) } }, cacheAsBitmap: { get: function () { return this._cacheAsBitmap }, set: function (t) { var e; this._cacheAsBitmap !== t && (this._cacheAsBitmap = t, t ? (this._cacheData || (this._cacheData = new Sn), e = this._cacheData, e.originalRender = this.render, e.originalRenderCanvas = this.renderCanvas, e.originalUpdateTransform = this.updateTransform, e.originalCalculateBounds = this.calculateBounds, e.originalGetLocalBounds = this.getLocalBounds, e.originalDestroy = this.destroy, e.originalContainsPoint = this.containsPoint, e.originalMask = this._mask, e.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (e = this._cacheData, e.sprite && this._destroyCachedDisplayObject(), this.render = e.originalRender, this.renderCanvas = e.originalRenderCanvas, this.calculateBounds = e.originalCalculateBounds, this.getLocalBounds = e.originalGetLocalBounds, this.destroy = e.originalDestroy, this.updateTransform = e.originalUpdateTransform, this.containsPoint = e.originalContainsPoint, this._mask = e.originalMask, this.filterArea = e.originalFilterArea)) } } }), P.s$.prototype._renderCached = function (t) { !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t)) }, P.s$.prototype._initCachedDisplayObject = function (t) { var e; if (!this._cacheData || !this._cacheData.sprite) { var r = this.alpha; this.alpha = 1, t.batch.flush(); var i = this.getLocalBounds(null, !0).clone(); if (this.filters && this.filters.length) { var n = this.filters[0].padding; i.pad(n) } i.ceil(Ft.Xd.RESOLUTION); var o = t.renderTexture.current, s = t.renderTexture.sourceFrame.clone(), a = t.renderTexture.destinationFrame.clone(), u = t.projection.transform, h = M.TI.create({ width: i.width, height: i.height, resolution: this.cacheAsBitmapResolution || t.resolution, multisample: null !== (e = this.cacheAsBitmapMultisample) && void 0 !== e ? e : t.multisample }), l = "cacheAsBitmap_" + (0, I.uid)(); this._cacheData.textureCacheId = l, M.VL.addToCache(h.baseTexture, l), M.xE.addToCache(h, l); var c = this.transform.localTransform.copyTo(En).invert().translate(-i.x, -i.y); this.render = this._cacheData.originalRender, t.render(this, { renderTexture: h, clear: !0, transform: c, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = u, t.renderTexture.bind(o, s, a), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r; var d = new wr(h); d.transform.worldTransform = this.transform.worldTransform, d.anchor.x = -i.x / i.width, d.anchor.y = -i.y / i.height, d.alpha = r, d._bounds = this._bounds, this._cacheData.sprite = d, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = d.containsPoint.bind(d) } }, P.s$.prototype._renderCachedCanvas = function (t) { !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t)) }, P.s$.prototype._initCachedDisplayObjectCanvas = function (t) { if (!this._cacheData || !this._cacheData.sprite) { var e = this.getLocalBounds(null, !0), r = this.alpha; this.alpha = 1; var i = t.context, n = t._projTransform; e.ceil(Ft.Xd.RESOLUTION); var o = M.TI.create({ width: e.width, height: e.height }), s = "cacheAsBitmap_" + (0, I.uid)(); this._cacheData.textureCacheId = s, M.VL.addToCache(o.baseTexture, s), M.xE.addToCache(o, s); var a = En; this.transform.localTransform.copyTo(a), a.invert(), a.tx -= e.x, a.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: o, clear: !0, transform: a, skipUpdateTransform: !1 }), t.context = i, t._projTransform = n, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r; var u = new wr(o); u.transform.worldTransform = this.transform.worldTransform, u.anchor.x = -e.x / e.width, u.anchor.y = -e.y / e.height, u.alpha = r, u._bounds = this._bounds, this._cacheData.sprite = u, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = u.containsPoint.bind(u) } }, P.s$.prototype._calculateCachedBounds = function () { this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID }, P.s$.prototype._getCachedLocalBounds = function () { return this._cacheData.sprite.getLocalBounds(null) }, P.s$.prototype._destroyCachedDisplayObject = function () { this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, M.VL.removeFromCache(this._cacheData.textureCacheId), M.xE.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null }, P.s$.prototype._cacheAsBitmapDestroy = function (t) { this.cacheAsBitmap = !1, this.destroy(t) },
            /*!
             * @pixi/mixin-get-child-by-name - v6.5.9
             * Compiled Wed, 25 Jan 2023 05:01:45 UTC
             *
             * @pixi/mixin-get-child-by-name is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
            P.s$.prototype.name = null, P.W2.prototype.getChildByName = function (t, e) { for (var r = 0, i = this.children.length; r < i; r++)if (this.children[r].name === t) return this.children[r]; if (e) for (r = 0, i = this.children.length; r < i; r++) { var n = this.children[r]; if (n.getChildByName) { var o = n.getChildByName(t, !0); if (o) return o } } return null },
            /*!
             * @pixi/mixin-get-global-position - v6.5.9
             * Compiled Wed, 25 Jan 2023 05:01:45 UTC
             *
             * @pixi/mixin-get-global-position is licensed under the MIT License.
             * http://www.opensource.org/licenses/mit-license
             */
            P.s$.prototype.getGlobalPosition = function (t, e) { return void 0 === t && (t = new H.E9), void 0 === e && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t };
        /*!
         * @pixi/app - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * @pixi/app is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        var wn = function () { function t() { } return t.init = function (t) { var e = this; Object.defineProperty(this, "resizeTo", { set: function (t) { globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = t, t && (globalThis.addEventListener("resize", this.queueResize), this.resize()) }, get: function () { return this._resizeTo } }), this.queueResize = function () { e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame((function () { return e.resize() }))) }, this.cancelResize = function () { e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null) }, this.resize = function () { if (e._resizeTo) { var t, r; if (e.cancelResize(), e._resizeTo === globalThis.window) t = globalThis.innerWidth, r = globalThis.innerHeight; else { var i = e._resizeTo, n = i.clientWidth, o = i.clientHeight; t = n, r = o } e.renderer.resize(t, r) } }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null }, t.destroy = function () { globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null }, t.extension = M.nw.Application, t }(), An = function () { function t(e) { var r = this; this.stage = new P.W2, e = Object.assign({ forceCanvas: !1 }, e), this.renderer = (0, M.e6)(e), t._plugins.forEach((function (t) { t.init.call(r, e) })) } return t.registerPlugin = function (t) { (0, I.deprecation)("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()"), M.Rw.add({ type: M.nw.Application, ref: t }) }, t.prototype.render = function () { this.renderer.render(this.stage) }, Object.defineProperty(t.prototype, "view", { get: function () { return this.renderer.view }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "screen", { get: function () { return this.renderer.screen }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function (e, r) { var i = this, n = t._plugins.slice(0); n.reverse(), n.forEach((function (t) { t.destroy.call(i) })), this.stage.destroy(r), this.stage = null, this.renderer.destroy(e), this.renderer = null }, t._plugins = [], t }(); M.Rw.handleByList(M.nw.Application, An._plugins), M.Rw.add(wn);
        /*!
         * @pixi/mesh-extras - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * @pixi/mesh-extras is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.
        
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
        
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        var Rn = function (t, e) { return Rn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, Rn(t, e) }; function On(t, e) { function r() { this.constructor = t } Rn(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var In = function (t) { function e(e, r, i, n) { void 0 === e && (e = 100), void 0 === r && (r = 100), void 0 === i && (i = 10), void 0 === n && (n = 10); var o = t.call(this) || this; return o.segWidth = i, o.segHeight = n, o.width = e, o.height = r, o.build(), o } return On(e, t), e.prototype.build = function () { for (var t = this.segWidth * this.segHeight, e = [], r = [], i = [], n = this.segWidth - 1, o = this.segHeight - 1, s = this.width / n, a = this.height / o, u = 0; u < t; u++) { var h = u % this.segWidth, l = u / this.segWidth | 0; e.push(h * s, l * a), r.push(h / n, l / o) } var c = n * o; for (u = 0; u < c; u++) { var d = u % n, f = u / n | 0, p = f * this.segWidth + d, _ = f * this.segWidth + d + 1, m = (f + 1) * this.segWidth + d, g = (f + 1) * this.segWidth + d + 1; i.push(p, _, m, _, g, m) } this.buffers[0].data = new Float32Array(e), this.buffers[1].data = new Float32Array(r), this.indexBuffer.data = new Uint16Array(i), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update() }, e }(Ei), Pn = function (t) { function e(e, r, i) { void 0 === e && (e = 200), void 0 === i && (i = 0); var n = t.call(this, new Float32Array(4 * r.length), new Float32Array(4 * r.length), new Uint16Array(6 * (r.length - 1))) || this; return n.points = r, n._width = e, n.textureScale = i, n.build(), n } return On(e, t), Object.defineProperty(e.prototype, "width", { get: function () { return this._width }, enumerable: !1, configurable: !0 }), e.prototype.build = function () { var t = this.points; if (t) { var e = this.getBuffer("aVertexPosition"), r = this.getBuffer("aTextureCoord"), i = this.getIndex(); if (!(t.length < 1)) { e.data.length / 4 !== t.length && (e.data = new Float32Array(4 * t.length), r.data = new Float32Array(4 * t.length), i.data = new Uint16Array(6 * (t.length - 1))); var n = r.data, o = i.data; n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1; for (var s = 0, a = t[0], u = this._width * this.textureScale, h = t.length, l = 0; l < h; l++) { var c = 4 * l; if (this.textureScale > 0) { var d = a.x - t[l].x, f = a.y - t[l].y, p = Math.sqrt(d * d + f * f); a = t[l], s += p / u } else s = l / (h - 1); n[c] = s, n[c + 1] = 0, n[c + 2] = s, n[c + 3] = 1 } var _ = 0; for (l = 0; l < h - 1; l++) { c = 2 * l; o[_++] = c, o[_++] = c + 1, o[_++] = c + 2, o[_++] = c + 2, o[_++] = c + 1, o[_++] = c + 3 } r.update(), i.update(), this.updateVertices() } } }, e.prototype.updateVertices = function () { var t = this.points; if (!(t.length < 1)) { for (var e, r = t[0], i = 0, n = 0, o = this.buffers[0].data, s = t.length, a = 0; a < s; a++) { var u = t[a], h = 4 * a; e = a < t.length - 1 ? t[a + 1] : u, n = -(e.x - r.x), i = e.y - r.y; var l = Math.sqrt(i * i + n * n), c = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2; i /= l, n /= l, i *= c, n *= c, o[h] = u.x + i, o[h + 1] = u.y + n, o[h + 2] = u.x - i, o[h + 3] = u.y - n, r = u } this.buffers[0].update() } }, e.prototype.update = function () { this.textureScale > 0 ? this.build() : this.updateVertices() }, e }(Ei), Mn = function (t) { function e(e, r, i) { void 0 === i && (i = 0); var n = this, o = new Pn(e.height, r, i), s = new Ti(e); return i > 0 && (e.baseTexture.wrapMode = et.Nt.REPEAT), n = t.call(this, o, s) || this, n.autoUpdate = !0, n } return On(e, t), e.prototype._render = function (e) { var r = this.geometry; (this.autoUpdate || r._width !== this.shader.texture.height) && (r._width = this.shader.texture.height, r.update()), t.prototype._render.call(this, e) }, e }(yi), Cn = function (t) { function e(e, r, i) { var n = this, o = new In(e.width, e.height, r, i), s = new Ti(M.xE.WHITE); return n = t.call(this, o, s) || this, n.texture = e, n.autoResize = !0, n } return On(e, t), e.prototype.textureUpdated = function () { this._textureID = this.shader.texture._updateID; var t = this.geometry, e = this.shader.texture, r = e.width, i = e.height; !this.autoResize || t.width === r && t.height === i || (t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build()) }, Object.defineProperty(e.prototype, "texture", { get: function () { return this.shader.texture }, set: function (t) { this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this)) }, enumerable: !1, configurable: !0 }), e.prototype._render = function (e) { this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t.prototype._render.call(this, e) }, e.prototype.destroy = function (e) { this.shader.texture.off("update", this.textureUpdated, this), t.prototype.destroy.call(this, e) }, e }(yi), Dn = function (t) { function e(e, r, i, n, o) { void 0 === e && (e = M.xE.EMPTY); var s = this, a = new Ei(r, i, n); a.getBuffer("aVertexPosition").static = !1; var u = new Ti(e); return s = t.call(this, a, u, null, o) || this, s.autoUpdate = !0, s } return On(e, t), Object.defineProperty(e.prototype, "vertices", { get: function () { return this.geometry.getBuffer("aVertexPosition").data }, set: function (t) { this.geometry.getBuffer("aVertexPosition").data = t }, enumerable: !1, configurable: !0 }), e.prototype._render = function (e) { this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), t.prototype._render.call(this, e) }, e }(yi), Ln = 10, Fn = function (t) { function e(e, r, i, n, o) { void 0 === r && (r = Ln), void 0 === i && (i = Ln), void 0 === n && (n = Ln), void 0 === o && (o = Ln); var s = t.call(this, M.xE.WHITE, 4, 4) || this; return s._origWidth = e.orig.width, s._origHeight = e.orig.height, s._width = s._origWidth, s._height = s._origHeight, s._leftWidth = r, s._rightWidth = n, s._topHeight = i, s._bottomHeight = o, s.texture = e, s } return On(e, t), e.prototype.textureUpdated = function () { this._textureID = this.shader.texture._updateID, this._refresh() }, Object.defineProperty(e.prototype, "vertices", { get: function () { return this.geometry.getBuffer("aVertexPosition").data }, set: function (t) { this.geometry.getBuffer("aVertexPosition").data = t }, enumerable: !1, configurable: !0 }), e.prototype.updateHorizontalVertices = function () { var t = this.vertices, e = this._getMinScale(); t[9] = t[11] = t[13] = t[15] = this._topHeight * e, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * e, t[25] = t[27] = t[29] = t[31] = this._height }, e.prototype.updateVerticalVertices = function () { var t = this.vertices, e = this._getMinScale(); t[2] = t[10] = t[18] = t[26] = this._leftWidth * e, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e, t[6] = t[14] = t[22] = t[30] = this._width }, e.prototype._getMinScale = function () { var t = this._leftWidth + this._rightWidth, e = this._width > t ? 1 : this._width / t, r = this._topHeight + this._bottomHeight, i = this._height > r ? 1 : this._height / r, n = Math.min(e, i); return n }, Object.defineProperty(e.prototype, "width", { get: function () { return this._width }, set: function (t) { this._width = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "height", { get: function () { return this._height }, set: function (t) { this._height = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "leftWidth", { get: function () { return this._leftWidth }, set: function (t) { this._leftWidth = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "rightWidth", { get: function () { return this._rightWidth }, set: function (t) { this._rightWidth = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "topHeight", { get: function () { return this._topHeight }, set: function (t) { this._topHeight = t, this._refresh() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "bottomHeight", { get: function () { return this._bottomHeight }, set: function (t) { this._bottomHeight = t, this._refresh() }, enumerable: !1, configurable: !0 }), e.prototype._refresh = function () { var t = this.texture, e = this.geometry.buffers[1].data; this._origWidth = t.orig.width, this._origHeight = t.orig.height; var r = 1 / this._origWidth, i = 1 / this._origHeight; e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1, e[2] = e[10] = e[18] = e[26] = r * this._leftWidth, e[4] = e[12] = e[20] = e[28] = 1 - r * this._rightWidth, e[9] = e[11] = e[13] = e[15] = i * this._topHeight, e[17] = e[19] = e[21] = e[23] = 1 - i * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update() }, e }(Cn), Nn = r(1922), Bn = function (t, e) { return Bn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]) }, Bn(t, e) }; function Un(t, e) { function r() { this.constructor = t } Bn(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r) } var kn = function (t) { function e(e, r) { void 0 === r && (r = !0); var i = t.call(this, e[0] instanceof M.xE ? e[0] : e[0].texture) || this; return i._textures = null, i._durations = null, i._autoUpdate = r, i._isConnectedToTicker = !1, i.animationSpeed = 1, i.loop = !0, i.updateAnchor = !1, i.onComplete = null, i.onFrameChange = null, i.onLoop = null, i._currentTime = 0, i._playing = !1, i._previousFrame = null, i.textures = e, i } return Un(e, t), e.prototype.stop = function () { this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (V.vB.shared.remove(this.update, this), this._isConnectedToTicker = !1)) }, e.prototype.play = function () { this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (V.vB.shared.add(this.update, this, V.uF.HIGH), this._isConnectedToTicker = !0)) }, e.prototype.gotoAndStop = function (t) { this.stop(); var e = this.currentFrame; this._currentTime = t, e !== this.currentFrame && this.updateTexture() }, e.prototype.gotoAndPlay = function (t) { var e = this.currentFrame; this._currentTime = t, e !== this.currentFrame && this.updateTexture(), this.play() }, e.prototype.update = function (t) { if (this._playing) { var e = this.animationSpeed * t, r = this.currentFrame; if (null !== this._durations) { var i = this._currentTime % 1 * this._durations[this.currentFrame]; i += e / 60 * 1e3; while (i < 0) this._currentTime--, i += this._durations[this.currentFrame]; var n = Math.sign(this.animationSpeed * t); this._currentTime = Math.floor(this._currentTime); while (i >= this._durations[this.currentFrame]) i -= this._durations[this.currentFrame] * n, this._currentTime += n; this._currentTime += i / this._durations[this.currentFrame] } else this._currentTime += e; this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : r !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < r || this.animationSpeed < 0 && this.currentFrame > r) && this.onLoop(), this.updateTexture()) } }, e.prototype.updateTexture = function () { var t = this.currentFrame; this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame)) }, e.prototype.destroy = function (e) { this.stop(), t.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null }, e.fromFrames = function (t) { for (var r = [], i = 0; i < t.length; ++i)r.push(M.xE.from(t[i])); return new e(r) }, e.fromImages = function (t) { for (var r = [], i = 0; i < t.length; ++i)r.push(M.xE.from(t[i])); return new e(r) }, Object.defineProperty(e.prototype, "totalFrames", { get: function () { return this._textures.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "textures", { get: function () { return this._textures }, set: function (t) { if (t[0] instanceof M.xE) this._textures = t, this._durations = null; else { this._textures = [], this._durations = []; for (var e = 0; e < t.length; e++)this._textures.push(t[e].texture), this._durations.push(t[e].time) } this._previousFrame = null, this.gotoAndStop(0), this.updateTexture() }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "currentFrame", { get: function () { var t = Math.floor(this._currentTime) % this._textures.length; return t < 0 && (t += this._textures.length), t }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "playing", { get: function () { return this._playing }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "autoUpdate", { get: function () { return this._autoUpdate }, set: function (t) { t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (V.vB.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (V.vB.shared.add(this.update, this), this._isConnectedToTicker = !0)) }, enumerable: !1, configurable: !0 }), e }(wr);
        /*!
         * pixi.js - v6.5.9
         * Compiled Wed, 25 Jan 2023 05:01:45 UTC
         *
         * pixi.js is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        M.Rw.add(j, nt, tt, Xe, Qr, M.Bv, fi, Vi, zt, Me, Ce, ri, V.Sb, Rt); var Gn = { AlphaFilter: $i, BlurFilter: nn, BlurFilterPass: rn, ColorMatrixFilter: un, DisplacementFilter: fn, FXAAFilter: vn, NoiseFilter: Tn }
    }
}]);
//# sourceMappingURL=chunk-vendors.0beb96a0.js.map